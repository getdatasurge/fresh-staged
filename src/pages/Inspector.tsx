import { useEffect, useState, useMemo } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { useUser } from '@stackframe/react';
import { useMutation } from '@tanstack/react-query';
import { useTRPC, useTRPCClient } from '@/lib/trpc';
import DashboardLayout from '@/components/DashboardLayout';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Calendar } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { toast } from 'sonner';
import { format, subDays, startOfDay, endOfDay } from 'date-fns';
import {
  Eye,
  Download,
  Calendar as CalendarIcon,
  Loader2,
  Thermometer,
  AlertTriangle,
  ClipboardCheck,
  WifiOff,
  Building2,
  Clock,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { useEffectiveIdentity } from '@/hooks/useEffectiveIdentity';

interface Site {
  id: string;
  name: string;
  timezone: string;
}

interface Unit {
  id: string;
  name: string;
  unit_type: string;
  temp_limit_high: number;
  temp_limit_low: number | null;
  area: { name: string };
}

interface TemperatureLog {
  id: string;
  unit_id: string;
  unit_name: string;
  temperature: number;
  logged_at: string;
  type: 'sensor' | 'manual';
  logged_by: string;
  is_in_range: boolean;
  notes?: string;
}

interface ExceptionLog {
  id: string;
  unit_id: string;
  unit_name: string;
  event_type: string;
  details: string;
  temperature?: number;
  severity: string;
  recorded_at: string;
  acknowledged_by?: string;
  action_taken?: string;
}

interface CorrectiveAction {
  id: string;
  unit_id: string;
  unit_name: string;
  action_taken: string;
  root_cause?: string;
  completed_at: string;
  created_by: string;
}

interface MonitoringGap {
  id: string;
  unit_id: string;
  unit_name: string;
  gap_type: string;
  start_at: string;
  end_at?: string;
  duration_minutes: number;
}

const Inspector = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const tokenFromUrl = searchParams.get('token');
  const user = useUser();
  const { effectiveOrgId, isInitialized } = useEffectiveIdentity();
  const trpc = useTRPC();
  const trpcClient = useTRPCClient();

  const [isLoading, setIsLoading] = useState(true);
  const [organizationId, setOrganizationId] = useState<string | null>(null);
  const [organizationName, setOrganizationName] = useState('');
  const [timezone, setTimezone] = useState('America/New_York');

  // Filters
  const [sites, setSites] = useState<Site[]>([]);
  const [units, setUnits] = useState<Unit[]>([]);
  const [selectedSiteId, setSelectedSiteId] = useState<string>('all');
  const [selectedUnitId, setSelectedUnitId] = useState<string>('all');
  const [dateRange, setDateRange] = useState<{ from: Date; to: Date }>({
    from: startOfDay(new Date()),
    to: endOfDay(new Date()),
  });

  // Data
  const [temperatureLogs, setTemperatureLogs] = useState<TemperatureLog[]>([]);
  const [exceptions, setExceptions] = useState<ExceptionLog[]>([]);
  const [correctiveActions, setCorrectiveActions] = useState<CorrectiveAction[]>([]);
  const [monitoringGaps, setMonitoringGaps] = useState<MonitoringGap[]>([]);

  // tRPC mutation for exporting reports
  const exportMutation = useMutation({
    ...trpc.reports.export.mutationOptions(),
    onSuccess: (data) => {
      // Add inspector watermark
      let content = data.content;
      const watermark = `\n# ──────────────────────────────────────────────────\n# INSPECTOR VIEW – READ-ONLY\n# Generated by FrostGuard\n# Export Timestamp: ${new Date().toISOString()}\n# Timezone: ${timezone}\n# Site: ${selectedSiteId === 'all' ? 'All Sites' : sites.find((s) => s.id === selectedSiteId)?.name || 'Unknown'}\n# Unit: ${selectedUnitId === 'all' ? 'All Units' : units.find((u) => u.id === selectedUnitId)?.name || 'Unknown'}\n# ──────────────────────────────────────────────────\n`;
      content = content + watermark;

      // Download file
      const blob = new Blob([content], { type: data.contentType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = data.filename.replace(/\.csv$/, `-inspector.csv`);
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      toast.success('Report exported');
    },
    onError: (err) => {
      console.error('Export error:', err);
      toast.error('Failed to export report');
    },
  });

  useEffect(() => {
    if (tokenFromUrl || isInitialized) {
      initializeInspector();
    }
  }, [tokenFromUrl, isInitialized, effectiveOrgId]);

  useEffect(() => {
    if (organizationId && selectedSiteId) {
      loadUnits();
    }
  }, [organizationId, selectedSiteId]);

  useEffect(() => {
    if (organizationId) {
      loadData();
    }
  }, [organizationId, selectedSiteId, selectedUnitId, dateRange]);

  const initializeInspector = async () => {
    try {
      // Check if using token-based access
      if (tokenFromUrl) {
        try {
          const session = await trpcClient.inspector.validateSession.mutate({
            token: tokenFromUrl,
          });
          setOrganizationId(session.organizationId);
          await loadOrgData(session.organizationId, session.allowedSiteIds || null);
        } catch (err: unknown) {
          console.error('Token validation error:', err);
          toast.error('Invalid or expired inspector link');
          navigate('/auth');
          return;
        }
      } else {
        // Check user auth and inspector role - use effectiveOrgId for impersonation
        if (!user) {
          navigate('/auth');
          return;
        }

        // Wait for effective identity to be initialized
        if (!isInitialized) {
          return;
        }

        if (!effectiveOrgId) {
          navigate('/onboarding');
          return;
        }

        // Check if user has inspector access via tRPC
        try {
          await trpcClient.inspector.checkUserAccess.query({ organizationId: effectiveOrgId });
        } catch (err: unknown) {
          console.error('User access error:', err);
          toast.error('No access to inspector mode');
          navigate('/');
          return;
        }

        setOrganizationId(effectiveOrgId);
        await loadOrgData(effectiveOrgId, null);
      }
    } catch (error) {
      console.error('Error initializing inspector:', error);
      toast.error('Failed to load inspector mode');
    }
    setIsLoading(false);
  };

  const loadOrgData = async (orgId: string, allowedSiteIds: string[] | null) => {
    try {
      const orgData = await trpcClient.inspector.getOrgData.query({
        organizationId: orgId,
        allowedSiteIds: allowedSiteIds || undefined,
      });

      setOrganizationName(orgData.name);
      setTimezone(orgData.timezone);
      setSites(orgData.sites);
    } catch (error) {
      console.error('Error loading org data:', error);
    }
  };

  const loadUnits = async () => {
    if (!organizationId) return;

    try {
      const unitsData = await trpcClient.inspector.getUnits.query({
        organizationId,
        siteId: selectedSiteId !== 'all' ? selectedSiteId : undefined,
      });

      setUnits(
        unitsData.map((u) => ({
          id: u.id,
          name: u.name,
          unit_type: u.unit_type,
          temp_limit_high: u.temp_limit_high,
          temp_limit_low: u.temp_limit_low ?? null,
          area: u.area,
        })),
      );
    } catch (error) {
      console.error('Error loading units:', error);
    }
  };

  const loadData = async () => {
    if (!organizationId) return;

    const startDate = dateRange.from.toISOString();
    const endDate = dateRange.to.toISOString();

    // Get unit IDs to filter
    const unitIds = selectedUnitId !== 'all' ? [selectedUnitId] : units.map((u) => u.id);

    if (unitIds.length === 0) return;

    try {
      const data = await trpcClient.inspector.getInspectionData.query({
        organizationId,
        unitIds,
        startDate,
        endDate,
      });

      // Create unit map
      const unitMap: Record<string, Unit> = {};
      units.forEach((u) => {
        unitMap[u.id] = u;
      });

      // Combine sensor readings and manual logs into temperature logs
      const logs: TemperatureLog[] = [];

      data.sensorReadings.forEach((r) => {
        const unit = unitMap[r.unit_id];
        if (!unit) return;
        const inRange =
          r.temperature <= unit.temp_limit_high &&
          (unit.temp_limit_low === null || r.temperature >= unit.temp_limit_low);
        logs.push({
          id: r.id,
          unit_id: r.unit_id,
          unit_name: unit.name,
          temperature: r.temperature,
          logged_at: r.recorded_at,
          type: 'sensor',
          logged_by: 'Automated',
          is_in_range: inRange,
        });
      });

      data.manualLogs.forEach((m) => {
        const unit = unitMap[m.unit_id];
        if (!unit) return;
        const inRange =
          m.temperature <= unit.temp_limit_high &&
          (unit.temp_limit_low === null || m.temperature >= unit.temp_limit_low);
        logs.push({
          id: m.id,
          unit_id: m.unit_id,
          unit_name: unit.name,
          temperature: m.temperature,
          logged_at: m.logged_at,
          type: 'manual',
          logged_by: m.logged_by,
          is_in_range: inRange,
          notes: m.notes || undefined,
        });
      });

      logs.sort((a, b) => new Date(b.logged_at).getTime() - new Date(a.logged_at).getTime());
      setTemperatureLogs(logs);

      // Transform alerts to exceptions
      const exceptionsData: ExceptionLog[] = data.alerts.map((a) => ({
        id: a.id,
        unit_id: a.unit_id,
        unit_name: unitMap[a.unit_id]?.name || 'Unknown',
        event_type: a.alert_type,
        details: a.title,
        severity: a.severity,
        recorded_at: a.triggered_at,
        acknowledged_by: a.acknowledged_by || undefined,
        action_taken: a.acknowledgment_notes || undefined,
      }));
      setExceptions(exceptionsData);

      // Transform corrective actions
      const caData: CorrectiveAction[] = data.correctiveActions.map((ca) => ({
        id: ca.id,
        unit_id: ca.unit_id,
        unit_name: unitMap[ca.unit_id]?.name || 'Unknown',
        action_taken: ca.action_taken,
        root_cause: ca.root_cause || undefined,
        completed_at: ca.completed_at,
        created_by: ca.created_by,
      }));
      setCorrectiveActions(caData);

      // Transform monitoring gaps
      const gapsData: MonitoringGap[] = data.monitoringGaps.map((g) => ({
        id: g.id,
        unit_id: g.unit_id,
        unit_name: unitMap[g.unit_id]?.name || 'Unknown',
        gap_type: g.gap_type,
        start_at: g.start_at,
        duration_minutes: g.duration_minutes,
      }));
      setMonitoringGaps(gapsData);
    } catch (error) {
      console.error('Error loading inspection data:', error);
    }
  };

  const handleQuickDate = (days: number) => {
    const to = endOfDay(new Date());
    const from = startOfDay(subDays(new Date(), days - 1));
    setDateRange({ from, to });
  };

  const handleExport = (reportType: 'daily' | 'exceptions') => {
    if (!user || !organizationId) {
      toast.error('Session expired. Please sign in again.');
      navigate('/auth');
      return;
    }

    // Use tRPC mutation for export
    exportMutation.mutate({
      organizationId,
      startDate: format(dateRange.from, 'yyyy-MM-dd'),
      endDate: format(dateRange.to, 'yyyy-MM-dd'),
      reportType,
      format: 'csv',
      siteId: selectedSiteId !== 'all' ? selectedSiteId : undefined,
      unitId: selectedUnitId !== 'all' ? selectedUnitId : undefined,
    });
  };

  if (isLoading) {
    return (
      <DashboardLayout title="Inspector Mode">
        <div className="flex items-center justify-center py-12">
          <Loader2 className="w-8 h-8 animate-spin text-accent" />
        </div>
      </DashboardLayout>
    );
  }

  return (
    <DashboardLayout title="Inspector Mode">
      {/* Read-only Badge */}
      <div className="mb-6 flex items-center gap-3">
        <Badge
          variant="outline"
          className="bg-accent/10 text-accent border-accent/30 px-3 py-1 text-sm"
        >
          <Eye className="w-4 h-4 mr-2" />
          Read-Only View
        </Badge>
        <span className="text-sm text-muted-foreground">
          {organizationName} • Timezone: {timezone}
        </span>
      </div>

      {/* Filters */}
      <Card className="mb-6">
        <CardHeader className="pb-3">
          <CardTitle className="text-lg flex items-center gap-2">
            <Building2 className="w-5 h-5" />
            Filter Data
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid gap-4 sm:grid-cols-4">
            {/* Site Select */}
            <div className="space-y-2">
              <label htmlFor="inspector-site-select" className="text-sm font-medium">
                Site
              </label>
              <Select value={selectedSiteId} onValueChange={setSelectedSiteId}>
                <SelectTrigger id="inspector-site-select">
                  <SelectValue placeholder="Select site" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Sites</SelectItem>
                  {sites.map((site) => (
                    <SelectItem key={site.id} value={site.id}>
                      {site.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            {/* Unit Select */}
            <div className="space-y-2">
              <label htmlFor="inspector-unit-select" className="text-sm font-medium">
                Unit
              </label>
              <Select value={selectedUnitId} onValueChange={setSelectedUnitId}>
                <SelectTrigger id="inspector-unit-select">
                  <SelectValue placeholder="Select unit" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Units</SelectItem>
                  {units.map((unit) => (
                    <SelectItem key={unit.id} value={unit.id}>
                      {unit.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            {/* Date Range */}
            <div className="space-y-2">
              <span className="text-sm font-medium">Date Range</span>
              <Popover>
                <PopoverTrigger asChild>
                  <Button
                    variant="outline"
                    aria-label={`Date Range: ${format(dateRange.from, 'MMM d')} - ${format(dateRange.to, 'MMM d')}`}
                    className={cn('w-full justify-start text-left font-normal')}
                  >
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {format(dateRange.from, 'MMM d')} - {format(dateRange.to, 'MMM d')}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0" align="start">
                  <Calendar
                    mode="range"
                    selected={{ from: dateRange.from, to: dateRange.to }}
                    onSelect={(range) => {
                      if (range?.from && range?.to) {
                        setDateRange({ from: startOfDay(range.from), to: endOfDay(range.to) });
                      }
                    }}
                    numberOfMonths={2}
                  />
                </PopoverContent>
              </Popover>
            </div>

            {/* Quick Buttons */}
            <div className="space-y-2">
              <span className="text-sm font-medium" id="inspector-quick-select-label">
                Quick Select
              </span>
              <div
                className="flex gap-2"
                role="group"
                aria-labelledby="inspector-quick-select-label"
              >
                <Button variant="outline" size="sm" onClick={() => handleQuickDate(1)}>
                  Today
                </Button>
                <Button variant="outline" size="sm" onClick={() => handleQuickDate(7)}>
                  7 Days
                </Button>
                <Button variant="outline" size="sm" onClick={() => handleQuickDate(30)}>
                  30 Days
                </Button>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Data Tabs */}
      <Tabs defaultValue="daily" className="space-y-4">
        <div className="flex justify-between items-center">
          <TabsList>
            <TabsTrigger value="daily" className="flex items-center gap-2">
              <Thermometer className="w-4 h-4" />
              Daily Log ({temperatureLogs.length})
            </TabsTrigger>
            <TabsTrigger value="exceptions" className="flex items-center gap-2">
              <AlertTriangle className="w-4 h-4" />
              Exceptions ({exceptions.length})
            </TabsTrigger>
            <TabsTrigger value="corrective" className="flex items-center gap-2">
              <ClipboardCheck className="w-4 h-4" />
              Corrective ({correctiveActions.length})
            </TabsTrigger>
            <TabsTrigger value="gaps" className="flex items-center gap-2">
              <WifiOff className="w-4 h-4" />
              Gaps ({monitoringGaps.length})
            </TabsTrigger>
          </TabsList>

          <div className="flex gap-2">
            <Button
              variant="outline"
              onClick={() => handleExport('daily')}
              disabled={exportMutation.isPending}
            >
              <Download className="w-4 h-4 mr-2" />
              Export Daily CSV
            </Button>
            <Button
              variant="outline"
              onClick={() => handleExport('exceptions')}
              disabled={exportMutation.isPending}
            >
              <Download className="w-4 h-4 mr-2" />
              Export Exceptions CSV
            </Button>
          </div>
        </div>

        {/* Daily Temperature Log */}
        <TabsContent value="daily">
          <Card>
            <CardHeader>
              <CardTitle>Daily Temperature Log</CardTitle>
              <CardDescription>All temperature readings for the selected period</CardDescription>
            </CardHeader>
            <CardContent>
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Date/Time</TableHead>
                    <TableHead>Unit</TableHead>
                    <TableHead>Type</TableHead>
                    <TableHead>Temp (°F)</TableHead>
                    <TableHead>In Range</TableHead>
                    <TableHead>Logged By</TableHead>
                    <TableHead>Notes</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {temperatureLogs.slice(0, 100).map((log) => (
                    <TableRow key={log.id}>
                      <TableCell className="whitespace-nowrap">
                        {format(new Date(log.logged_at), 'MMM d, yyyy HH:mm')}
                      </TableCell>
                      <TableCell>{log.unit_name}</TableCell>
                      <TableCell>
                        <Badge variant={log.type === 'manual' ? 'default' : 'secondary'}>
                          {log.type}
                        </Badge>
                      </TableCell>
                      <TableCell className="font-mono">{log.temperature.toFixed(1)}°</TableCell>
                      <TableCell>
                        <Badge variant={log.is_in_range ? 'outline' : 'destructive'}>
                          {log.is_in_range ? 'Yes' : 'No'}
                        </Badge>
                      </TableCell>
                      <TableCell>{log.logged_by}</TableCell>
                      <TableCell className="max-w-[200px] truncate">{log.notes || '-'}</TableCell>
                    </TableRow>
                  ))}
                  {temperatureLogs.length === 0 && (
                    <TableRow>
                      <TableCell colSpan={7} className="text-center text-muted-foreground py-8">
                        No temperature logs for this period
                      </TableCell>
                    </TableRow>
                  )}
                </TableBody>
              </Table>
              {temperatureLogs.length > 100 && (
                <p className="text-sm text-muted-foreground mt-4 text-center">
                  Showing first 100 of {temperatureLogs.length} records. Export CSV for full data.
                </p>
              )}
            </CardContent>
          </Card>
        </TabsContent>

        {/* Exceptions */}
        <TabsContent value="exceptions">
          <Card>
            <CardHeader>
              <CardTitle>Exceptions Only</CardTitle>
              <CardDescription>Alerts and out-of-range readings</CardDescription>
            </CardHeader>
            <CardContent>
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Date/Time</TableHead>
                    <TableHead>Unit</TableHead>
                    <TableHead>Event Type</TableHead>
                    <TableHead>Severity</TableHead>
                    <TableHead>Details</TableHead>
                    <TableHead>Acknowledged By</TableHead>
                    <TableHead>Action</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {exceptions.map((exc) => (
                    <TableRow key={exc.id}>
                      <TableCell className="whitespace-nowrap">
                        {format(new Date(exc.recorded_at), 'MMM d, yyyy HH:mm')}
                      </TableCell>
                      <TableCell>{exc.unit_name}</TableCell>
                      <TableCell>{exc.event_type}</TableCell>
                      <TableCell>
                        <Badge variant={exc.severity === 'critical' ? 'destructive' : 'secondary'}>
                          {exc.severity}
                        </Badge>
                      </TableCell>
                      <TableCell className="max-w-[200px] truncate">{exc.details}</TableCell>
                      <TableCell>{exc.acknowledged_by || '-'}</TableCell>
                      <TableCell className="max-w-[150px] truncate">
                        {exc.action_taken || '-'}
                      </TableCell>
                    </TableRow>
                  ))}
                  {exceptions.length === 0 && (
                    <TableRow>
                      <TableCell colSpan={7} className="text-center text-muted-foreground py-8">
                        No exceptions for this period
                      </TableCell>
                    </TableRow>
                  )}
                </TableBody>
              </Table>
            </CardContent>
          </Card>
        </TabsContent>

        {/* Corrective Actions */}
        <TabsContent value="corrective">
          <Card>
            <CardHeader>
              <CardTitle>Corrective Actions</CardTitle>
              <CardDescription>Actions taken to address issues</CardDescription>
            </CardHeader>
            <CardContent>
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Date/Time</TableHead>
                    <TableHead>Unit</TableHead>
                    <TableHead>Root Cause</TableHead>
                    <TableHead>Action Taken</TableHead>
                    <TableHead>Completed By</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {correctiveActions.map((ca) => (
                    <TableRow key={ca.id}>
                      <TableCell className="whitespace-nowrap">
                        {format(new Date(ca.completed_at), 'MMM d, yyyy HH:mm')}
                      </TableCell>
                      <TableCell>{ca.unit_name}</TableCell>
                      <TableCell className="max-w-[200px] truncate">
                        {ca.root_cause || '-'}
                      </TableCell>
                      <TableCell className="max-w-[300px]">{ca.action_taken}</TableCell>
                      <TableCell>{ca.created_by}</TableCell>
                    </TableRow>
                  ))}
                  {correctiveActions.length === 0 && (
                    <TableRow>
                      <TableCell colSpan={5} className="text-center text-muted-foreground py-8">
                        No corrective actions for this period
                      </TableCell>
                    </TableRow>
                  )}
                </TableBody>
              </Table>
            </CardContent>
          </Card>
        </TabsContent>

        {/* Monitoring Gaps */}
        <TabsContent value="gaps">
          <Card>
            <CardHeader>
              <CardTitle>Monitoring Gaps / Offline Periods</CardTitle>
              <CardDescription>Periods where monitoring was interrupted</CardDescription>
            </CardHeader>
            <CardContent>
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Date/Time</TableHead>
                    <TableHead>Unit</TableHead>
                    <TableHead>Gap Type</TableHead>
                    <TableHead>Duration</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {monitoringGaps.map((gap) => (
                    <TableRow key={gap.id}>
                      <TableCell className="whitespace-nowrap">
                        {format(new Date(gap.start_at), 'MMM d, yyyy HH:mm')}
                      </TableCell>
                      <TableCell>{gap.unit_name}</TableCell>
                      <TableCell>{gap.gap_type}</TableCell>
                      <TableCell>
                        <div className="flex items-center gap-1">
                          <Clock className="w-4 h-4 text-muted-foreground" />
                          {gap.duration_minutes > 0 ? `${gap.duration_minutes} min` : 'Ongoing'}
                        </div>
                      </TableCell>
                    </TableRow>
                  ))}
                  {monitoringGaps.length === 0 && (
                    <TableRow>
                      <TableCell colSpan={4} className="text-center text-muted-foreground py-8">
                        No monitoring gaps for this period
                      </TableCell>
                    </TableRow>
                  )}
                </TableBody>
              </Table>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>

      {/* Footer with timezone */}
      <div className="mt-6 pt-4 border-t text-center text-sm text-muted-foreground">
        <p>All times shown in {timezone}</p>
        <p className="mt-1">FrostGuard Inspector View • Read-Only</p>
      </div>
    </DashboardLayout>
  );
};

export default Inspector;
