---
phase: 25-deployment-orchestration
plan: 02
type: execute
wave: 2
depends_on: ['01']
files_modified:
  - scripts/deploy-automated.sh
autonomous: true
user_setup: []

must_haves:
  truths:
    - 'Script verifies all critical Docker services are healthy'
    - 'Script displays completion summary with access URLs'
    - 'All services reach healthy state before script reports success'
  artifacts:
    - path: 'scripts/deploy-automated.sh'
      provides: 'Health verification and completion summary'
      contains: 'wait_for_all_services_healthy'
  key_links:
    - from: 'scripts/deploy-automated.sh'
      to: 'docker compose'
      via: 'health check commands'
      pattern: "docker compose.*ps\\|exec\\|health"
---

<objective>
Add all-services-healthy verification and completion summary to the deployment orchestrator.

Purpose: Satisfy DEPLOY-04 and DEPLOY-05 by verifying all Docker services reach healthy state after deploy.sh completes, and displaying a clear completion summary with access URLs.

Output: Enhanced `scripts/deploy-automated.sh` with health verification and completion summary functions
</objective>

<execution_context>
@/home/skynet/.claude/get-shit-done/workflows/execute-plan.md
@/home/skynet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-deployment-orchestration/25-RESEARCH.md
@.planning/phases/25-deployment-orchestration/25-01-SUMMARY.md
@scripts/deploy-automated.sh
@compose.production.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add wait_for_all_services_healthy function</name>
  <files>scripts/deploy-automated.sh</files>
  <action>
Add a health verification function that waits for all critical services to be healthy. This runs AFTER deploy.sh completes (deploy.sh already waits for backend, this adds broader verification).

**Function: wait_for_all_services_healthy()**

Parameters:

- $1 = max_attempts (default: 60)
- $2 = interval in seconds (default: 5)

Services to check (in order of criticality):

1. **postgres**: `docker compose -f docker-compose.yml -f compose.production.yaml exec -T postgres pg_isready -U frostguard`
2. **redis**: `docker compose -f docker-compose.yml -f compose.production.yaml exec -T redis redis-cli ping`
3. **backend**: `curl -sf --max-time 5 http://localhost:3000/health`
4. **caddy**: Check container is running: `docker compose -f docker-compose.yml -f compose.production.yaml ps caddy --format json | grep -q '"running"'`

Logic:

```bash
wait_for_all_services_healthy() {
    local max_attempts="${1:-60}"
    local interval="${2:-5}"
    local attempt=1

    step "Verifying all services are healthy..."

    while [[ $attempt -le $max_attempts ]]; do
        local all_healthy=true
        local failed_service=""

        # Check postgres
        if ! docker compose -f docker-compose.yml -f compose.production.yaml exec -T postgres pg_isready -U frostguard &>/dev/null; then
            all_healthy=false
            failed_service="postgres"
        # Check redis
        elif ! docker compose -f docker-compose.yml -f compose.production.yaml exec -T redis redis-cli ping &>/dev/null; then
            all_healthy=false
            failed_service="redis"
        # Check backend health endpoint
        elif ! curl -sf --max-time 5 http://localhost:3000/health &>/dev/null; then
            all_healthy=false
            failed_service="backend"
        # Check caddy is running
        elif ! docker compose -f docker-compose.yml -f compose.production.yaml ps caddy --format '{{.State}}' 2>/dev/null | grep -q "running"; then
            all_healthy=false
            failed_service="caddy"
        fi

        if [[ "$all_healthy" == "true" ]]; then
            success "All critical services are healthy"
            return 0
        fi

        echo "Waiting for $failed_service... (attempt $attempt/$max_attempts)"
        sleep "$interval"
        attempt=$((attempt + 1))
    done

    error "Services did not become healthy within timeout"
    echo "  Failed service: $failed_service"
    echo "  Check logs: docker compose logs $failed_service"
    return 1
}
```

**Integration into orchestration**:
Add as a fifth step after deployment:

```bash
run_step "deploy-verify-health" wait_for_all_services_healthy
```

**Important**: This function must be defined BEFORE the main() function that uses it. Place it in the "Wrapper functions" section of the script.
</action>
<verify>

1. Function exists: `grep -A 5 "wait_for_all_services_healthy()" scripts/deploy-automated.sh`
2. Checks postgres: `grep "pg_isready" scripts/deploy-automated.sh`
3. Checks redis: `grep "redis-cli ping" scripts/deploy-automated.sh`
4. Checks backend: `grep "localhost:3000/health" scripts/deploy-automated.sh`
5. Checks caddy: `grep "ps caddy" scripts/deploy-automated.sh`
6. Added to orchestration: `grep "deploy-verify-health" scripts/deploy-automated.sh`
   </verify>
   <done>
   wait_for_all_services_healthy() function exists in deploy-automated.sh, checks postgres (pg_isready), redis (redis-cli ping), backend (health endpoint), and caddy (container state). Function is called via run_step after deployment completes.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Add display_completion_summary function</name>
  <files>scripts/deploy-automated.sh</files>
  <action>
Add a completion summary function that displays access URLs and next steps after successful deployment.

**Function: display_completion_summary()**

The function should:

1. Read DOMAIN from environment (set by config-lib.sh during configuration)
2. Display a formatted completion banner
3. Show all access URLs
4. Provide next steps guidance

**Implementation**:

```bash
display_completion_summary() {
    local domain="${DOMAIN:-}"

    # If DOMAIN not set, try to read from .env.production
    if [[ -z "$domain" ]] && [[ -f "${PROJECT_ROOT}/.env.production" ]]; then
        domain=$(grep "^DOMAIN=" "${PROJECT_ROOT}/.env.production" | cut -d= -f2)
    fi

    echo ""
    echo -e "${GREEN}========================================"
    echo "     FreshTrack Pro Deployment Complete!"
    echo "========================================${NC}"
    echo ""
    echo "End time: $(date '+%Y-%m-%d %H:%M:%S')"
    echo ""

    if [[ -n "$domain" ]]; then
        echo -e "${BLUE}Access URLs:${NC}"
        echo "  Dashboard:    https://${domain}"
        echo "  API:          https://${domain}/api"
        echo "  Health:       https://${domain}/api/health"
        echo "  Monitoring:   https://monitoring.${domain}"
        echo "  Status:       https://status.${domain}"
        echo ""
    else
        echo -e "${YELLOW}Note: Domain not detected. Check .env.production${NC}"
        echo ""
    fi

    echo -e "${BLUE}Service Status:${NC}"
    docker compose -f docker-compose.yml -f compose.production.yaml ps --format "table {{.Name}}\t{{.Status}}" 2>/dev/null || \
        docker compose -f docker-compose.yml -f compose.production.yaml ps
    echo ""

    echo -e "${BLUE}Next Steps:${NC}"
    echo "  1. Visit the dashboard to verify the application is working"
    echo "  2. Create your first organization and user"
    echo "  3. Configure alerting thresholds"
    echo ""
    echo -e "${BLUE}Useful Commands:${NC}"
    echo "  View logs:        docker compose logs -f"
    echo "  Service status:   docker compose ps"
    echo "  Backend logs:     docker compose logs -f backend"
    echo "  Restart:          docker compose restart"
    echo "  Stop:             docker compose down"
    echo ""
    echo -e "${BLUE}Troubleshooting:${NC}"
    echo "  Re-run deployment:  ./scripts/deploy-automated.sh"
    echo "  Full reset:         ./scripts/deploy-automated.sh --reset"
    echo "  Rollback:           ./scripts/rollback.sh"
    echo ""
}
```

**Integration into orchestration**:
Call display_completion_summary() at the end of main(), after all run_step calls complete successfully (NOT as a run_step - this should always run on success, not be checkpointed).
</action>
<verify>

1. Function exists: `grep -A 3 "display_completion_summary()" scripts/deploy-automated.sh`
2. Shows URLs: `grep "https://" scripts/deploy-automated.sh | grep -E "Dashboard|API|Monitoring"`
3. Shows docker compose ps: `grep "docker compose.*ps" scripts/deploy-automated.sh`
4. Shows next steps: `grep "Next Steps" scripts/deploy-automated.sh`
5. Called at end: Script calls display_completion_summary in main after run_step calls
   </verify>
   <done>
   display_completion_summary() function exists in deploy-automated.sh, displays access URLs (Dashboard, API, Monitoring, Status), shows service status via docker compose ps, and provides next steps and troubleshooting commands. Function is called at the end of successful deployment.
   </done>
   </task>

<task type="auto">
  <name>Task 3: Update main() to include health verification and summary</name>
  <files>scripts/deploy-automated.sh</files>
  <action>
Update the main() function to include the new health verification step and call the completion summary:

**Updated main() structure**:

```bash
main() {
    echo "========================================"
    echo "FreshTrack Pro Automated Deployment"
    echo "========================================"
    echo ""
    echo "Start time: $(date '+%Y-%m-%d %H:%M:%S')"
    echo ""

    # Reset checkpoints if requested
    if [[ "$RESET_CHECKPOINTS" == "true" ]]; then
        checkpoint_clear_all
        echo ""
    fi

    # Run orchestrated deployment phases
    run_step "deploy-preflight" do_preflight
    run_step "deploy-prerequisites" do_prerequisites
    run_step "deploy-configuration" do_configuration
    run_step "deploy-deployment" do_deployment
    run_step "deploy-verify-health" wait_for_all_services_healthy

    # Display completion summary (not checkpointed - always show on success)
    display_completion_summary
}
```

**Key points**:

- 5 run_step calls now (added deploy-verify-health)
- display_completion_summary is NOT a run_step (always runs on success)
- Checkpoint names use "deploy-" prefix for namespace isolation
  </action>
  <verify>

1. Main has 5 run_step calls: `grep -c "run_step" scripts/deploy-automated.sh` (should be 5)
2. Health verification step exists: `grep "deploy-verify-health" scripts/deploy-automated.sh`
3. Summary called at end: `grep "display_completion_summary" scripts/deploy-automated.sh`
4. Summary is NOT a run_step: `! grep "run_step.*display_completion_summary" scripts/deploy-automated.sh`
   </verify>
   <done>
   main() function includes all 5 deployment phases via run_step (preflight, prerequisites, configuration, deployment, verify-health), and calls display_completion_summary after all steps complete successfully.
   </done>
   </task>

</tasks>

<verification>
After completing all tasks:

1. **Function existence verification**:

   ```bash
   # Check both new functions exist
   grep -c "wait_for_all_services_healthy()" scripts/deploy-automated.sh  # Should be 1
   grep -c "display_completion_summary()" scripts/deploy-automated.sh     # Should be 1
   ```

2. **Health check verification**:

   ```bash
   # All 4 services checked
   grep -E "pg_isready|redis-cli ping|localhost:3000/health|ps caddy" scripts/deploy-automated.sh
   ```

3. **Orchestration verification**:

   ```bash
   # 5 run_step calls (including verify-health)
   grep -c "run_step" scripts/deploy-automated.sh  # Should be 5

   # Summary NOT checkpointed
   grep "display_completion_summary" scripts/deploy-automated.sh | grep -v "run_step"
   ```

4. **Full script validation**:

   ```bash
   # Syntax check
   bash -n scripts/deploy-automated.sh

   # Help still works
   ./scripts/deploy-automated.sh --help
   ```

5. **DEPLOY requirement verification**:
   - DEPLOY-04 (Docker Compose production): wait_for_all_services_healthy uses correct compose files
   - DEPLOY-05 (all services healthy): Checks postgres, redis, backend, caddy before success
     </verification>

<success_criteria>

1. wait_for_all_services_healthy() function exists and checks 4 services
2. display_completion_summary() function exists and shows URLs
3. main() has 5 run_step calls (preflight, prerequisites, configuration, deployment, verify-health)
4. display_completion_summary is called but NOT as a run_step
5. Script passes bash -n syntax check
6. --help still works correctly
7. Health checks use correct docker compose file layering
   </success_criteria>

<output>
After completion, create `.planning/phases/25-deployment-orchestration/25-02-SUMMARY.md`
</output>
