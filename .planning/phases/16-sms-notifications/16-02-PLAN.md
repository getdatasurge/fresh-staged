---
phase: 16-sms-notifications
plan: 02
type: execute
wave: 2
depends_on: ['16-01']
files_modified:
  - backend/src/workers/processors/sms-notification.processor.ts
  - backend/src/services/queue.service.ts
autonomous: true

must_haves:
  truths:
    - 'SMS processor sends SMS via TelnyxService'
    - 'Unrecoverable errors throw UnrecoverableError to skip retries'
    - 'Retryable errors throw normal errors to trigger BullMQ retry'
    - 'Notification delivery records updated after send attempts'
  artifacts:
    - path: 'backend/src/workers/processors/sms-notification.processor.ts'
      provides: 'Complete SMS notification processor'
      min_lines: 80
      exports: ['processSmsNotification']
    - path: 'backend/src/services/queue.service.ts'
      provides: 'SMS-specific addSmsJob method'
      exports: ['QueueService']
  key_links:
    - from: 'backend/src/workers/processors/sms-notification.processor.ts'
      to: 'backend/src/services/telnyx.service.ts'
      via: 'TelnyxService import'
      pattern: 'TelnyxService'
    - from: 'backend/src/workers/processors/sms-notification.processor.ts'
      to: 'backend/src/config/telnyx.config.ts'
      via: 'error categorization'
      pattern: 'categorizeError'
    - from: 'backend/src/workers/processors/sms-notification.processor.ts'
      to: 'bullmq'
      via: 'UnrecoverableError'
      pattern: 'UnrecoverableError'
---

<objective>
Implement SMS notification processor with Telnyx integration and error handling

Purpose: Replace the stub processor with a complete implementation that sends SMS via Telnyx, handles errors correctly (unrecoverable vs retryable), and updates notification delivery records.

Output:

- Fully implemented SMS processor with TelnyxService integration
- Error categorization applied (UnrecoverableError for permanent failures)
- Notification delivery record updates after send attempts
- QueueService helper method for adding SMS jobs with correct options
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-sms-notifications/16-RESEARCH.md
@.planning/phases/16-sms-notifications/16-01-SUMMARY.md

# Dependencies from Plan 01

@backend/src/services/telnyx.service.ts
@backend/src/config/telnyx.config.ts
@backend/src/jobs/index.ts

# Existing infrastructure

@backend/src/workers/processors/sms-notification.processor.ts
@backend/src/workers/index.ts
@backend/src/services/queue.service.ts
@backend/src/db/schema/notifications.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SMS notification processor</name>
  <files>
    backend/src/workers/processors/sms-notification.processor.ts
  </files>
  <action>
Replace the stub implementation in `backend/src/workers/processors/sms-notification.processor.ts` with complete Telnyx integration:

```typescript
/**
 * SMS notification processor
 *
 * Sends SMS notifications via Telnyx with proper error handling:
 * - Unrecoverable errors (opted-out, invalid number) skip retries
 * - Retryable errors trigger BullMQ exponential backoff
 * - Updates notification_deliveries record on completion/failure
 */

import { Job, UnrecoverableError } from 'bullmq';
import { eq } from 'drizzle-orm';
import type { SmsNotificationJobData } from '../../jobs/index.js';
import { TelnyxService, getTelnyxService } from '../../services/telnyx.service.js';
import {
  categorizeError,
  extractErrorCode,
  extractErrorMessage,
  validateE164,
} from '../../config/telnyx.config.js';
import { db } from '../../db/client.js';
import { notificationDeliveries } from '../../db/schema/notifications.js';

export interface SmsProcessorResult {
  success: boolean;
  messageId?: string;
  error?: string;
  errorCode?: string;
}

export async function processSmsNotification(
  job: Job<SmsNotificationJobData>,
): Promise<SmsProcessorResult> {
  const { phoneNumber, message, organizationId, alertId, deliveryId } = job.data;

  console.log(`[SMS Processor] Processing job ${job.id} for org ${organizationId}`);
  console.log(`[SMS Processor] Phone: ${phoneNumber.slice(0, 5)}***${phoneNumber.slice(-2)}`);
  console.log(`[SMS Processor] Attempt ${job.attemptsMade + 1}/${job.opts.attempts || 5}`);

  // Validate E.164 format before attempting send
  if (!validateE164(phoneNumber)) {
    const error = `Invalid phone number format: ${phoneNumber}. Must be E.164 format.`;
    console.error(`[SMS Processor] ${error}`);

    // Update delivery record if exists
    if (deliveryId) {
      await updateDeliveryFailed(deliveryId, error);
    }

    // Invalid format is unrecoverable
    throw new UnrecoverableError(error);
  }

  // Get TelnyxService instance
  const telnyxService = getTelnyxService();
  if (!telnyxService) {
    throw new Error('TelnyxService not initialized');
  }

  try {
    const result = await telnyxService.sendSms({
      to: phoneNumber,
      message,
    });

    console.log(
      `[SMS Processor] Sent message ${result.messageId} to ${phoneNumber.slice(0, 5)}***`,
    );
    console.log(`[SMS Processor] Status: ${result.status}`);

    // Update delivery record on success
    if (deliveryId) {
      await updateDeliverySent(deliveryId, result.messageId);
    }

    return {
      success: true,
      messageId: result.messageId,
    };
  } catch (error: unknown) {
    const errorCode = extractErrorCode(error);
    const errorMessage = extractErrorMessage(error);
    const category = categorizeError(errorCode);

    console.error(`[SMS Processor] Send failed: ${errorCode} - ${errorMessage}`);
    console.log(`[SMS Processor] Error category: ${category}`);

    if (category === 'unrecoverable') {
      console.log(`[SMS Processor] Permanent failure - will not retry`);

      // Update delivery record with failure
      if (deliveryId) {
        await updateDeliveryFailed(deliveryId, `${errorCode}: ${errorMessage}`);
      }

      // Throw UnrecoverableError to skip remaining retries
      throw new UnrecoverableError(`Permanent SMS failure: ${errorCode} - ${errorMessage}`);
    }

    // For retryable or unknown errors, update retry count and throw
    if (deliveryId) {
      await updateDeliveryRetry(deliveryId, job.attemptsMade + 1);
    }

    // Throw normal error to trigger BullMQ retry with backoff
    throw new Error(`SMS send failed (retryable): ${errorCode} - ${errorMessage}`);
  }
}

// Helper functions for updating notification_deliveries

async function updateDeliverySent(deliveryId: string, externalId: string): Promise<void> {
  try {
    await db
      .update(notificationDeliveries)
      .set({
        status: 'sent',
        externalId,
        sentAt: new Date(),
      })
      .where(eq(notificationDeliveries.id, deliveryId));
  } catch (err) {
    console.error(`[SMS Processor] Failed to update delivery record: ${err}`);
    // Don't throw - delivery update failure shouldn't fail the job
  }
}

async function updateDeliveryFailed(deliveryId: string, errorMessage: string): Promise<void> {
  try {
    await db
      .update(notificationDeliveries)
      .set({
        status: 'failed',
        errorMessage,
        failedAt: new Date(),
      })
      .where(eq(notificationDeliveries.id, deliveryId));
  } catch (err) {
    console.error(`[SMS Processor] Failed to update delivery record: ${err}`);
  }
}

async function updateDeliveryRetry(deliveryId: string, retryCount: number): Promise<void> {
  try {
    await db
      .update(notificationDeliveries)
      .set({
        retryCount: String(retryCount),
        lastRetryAt: new Date(),
      })
      .where(eq(notificationDeliveries.id, deliveryId));
  } catch (err) {
    console.error(`[SMS Processor] Failed to update delivery record: ${err}`);
  }
}
```

  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Processor imports TelnyxService, categorizeError, validateE164, UnrecoverableError
3. File is > 80 lines with complete implementation
  </verify>
  <done>
SMS processor fully implemented with Telnyx integration, error categorization (UnrecoverableError for permanent failures), notification delivery updates
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SMS job helper method to QueueService</name>
  <files>
    backend/src/services/queue.service.ts
  </files>
  <action>
Update `backend/src/services/queue.service.ts` to add a convenience method for SMS jobs:

1. Import smsJobOptions from jobs/index.js:

```typescript
import {
  QueueNames,
  defaultJobOptions,
  smsJobOptions,
  type BaseJobData,
  type SmsNotificationJobData,
} from '../jobs/index.js';
```

2. Add a new method `addSmsJob` after `addJob`:

```typescript
/**
 * Add an SMS notification job with SMS-specific options
 *
 * Convenience method that applies smsJobOptions (5 attempts, exponential backoff)
 * automatically. Use this instead of addJob for SMS notifications.
 *
 * @param data - SMS job data (must include organizationId, phoneNumber, message)
 * @returns Job ID if queued, null if queues disabled
 *
 * @example
 * await queueService.addSmsJob({
 *   organizationId: 'org-123',
 *   phoneNumber: '+15551234567',
 *   message: 'Temperature alert!',
 *   alertId: 'alert-456',
 * });
 */
async addSmsJob(data: SmsNotificationJobData): Promise<string | null> {
  return this.addJob<SmsNotificationJobData>(
    QueueNames.SMS_NOTIFICATIONS,
    'sms:send',
    data,
    smsJobOptions
  );
}
```

3. Update the import statement at the top to include JobNames:

```typescript
import {
  QueueNames,
  JobNames,
  defaultJobOptions,
  smsJobOptions,
  type BaseJobData,
  type SmsNotificationJobData,
} from '../jobs/index.js';
```

4. Use JobNames.SMS_SEND constant instead of string literal in addSmsJob.
   </action>
   <verify>
1. `npx tsc --noEmit` passes
1. QueueService has addSmsJob method
1. addSmsJob uses smsJobOptions with 5 attempts
   </verify>
   <done>
   QueueService has addSmsJob convenience method that applies SMS-specific job options automatically
   </done>
   </task>

</tasks>

<verification>
After completing all tasks:
1. `cd backend && npx tsc --noEmit` compiles without errors
2. SMS processor file > 80 lines with complete implementation
3. Processor uses:
   - TelnyxService for sending
   - categorizeError for error handling
   - UnrecoverableError for permanent failures
   - Database updates for notification_deliveries
4. QueueService.addSmsJob method exists and uses smsJobOptions
</verification>

<success_criteria>

- SMS processor sends SMS via TelnyxService
- E.164 validation rejects invalid numbers with UnrecoverableError
- Unrecoverable Telnyx errors (opted-out, invalid) throw UnrecoverableError
- Retryable errors throw normal Error for BullMQ retry
- notification_deliveries updated on success/failure/retry
- QueueService.addSmsJob applies 5-attempt exponential backoff
- All TypeScript compiles cleanly
  </success_criteria>

<output>
After completion, create `.planning/phases/16-sms-notifications/16-02-SUMMARY.md`
</output>
