---
phase: 16-sms-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/package.json
  - backend/src/services/telnyx.service.ts
  - backend/src/config/telnyx.config.ts
  - backend/src/jobs/index.ts
autonomous: true
user_setup:
  - service: telnyx
    why: 'SMS delivery provider'
    env_vars:
      - name: TELNYX_API_KEY
        source: 'Telnyx Dashboard -> API Keys'
      - name: TELNYX_PHONE_NUMBER
        source: 'Telnyx Dashboard -> Numbers (toll-free in E.164 format)'
      - name: TELNYX_MESSAGING_PROFILE_ID
        source: 'Telnyx Dashboard -> Messaging -> Profiles'

must_haves:
  truths:
    - 'TelnyxService can send SMS via Telnyx API'
    - 'Error codes are categorized as retryable or unrecoverable'
    - 'SMS job options use exponential backoff with jitter'
  artifacts:
    - path: 'backend/src/services/telnyx.service.ts'
      provides: 'TelnyxService class with sendSms method'
      exports: ['TelnyxService']
    - path: 'backend/src/config/telnyx.config.ts'
      provides: 'Error categorization and E.164 validation'
      exports: ['categorizeError', 'validateE164', 'UNRECOVERABLE_CODES', 'RETRYABLE_CODES']
    - path: 'backend/src/jobs/index.ts'
      provides: 'SMS-specific job options'
      exports: ['smsJobOptions']
  key_links:
    - from: 'backend/src/services/telnyx.service.ts'
      to: 'telnyx SDK'
      via: "import Telnyx from 'telnyx'"
      pattern: 'new Telnyx'
    - from: 'backend/src/config/telnyx.config.ts'
      to: 'BullMQ UnrecoverableError'
      via: 'error categorization'
      pattern: 'UNRECOVERABLE_CODES'
---

<objective>
Install Telnyx SDK and create TelnyxService with error categorization

Purpose: Establish the foundation layer for SMS delivery - the Telnyx API wrapper and error handling configuration that the SMS processor will use.

Output:

- Telnyx SDK installed in backend
- TelnyxService class wrapping SDK with typed interface
- Error code categorization for retry behavior
- E.164 validation helper (ported from Edge Function)
- SMS-specific job options with exponential backoff and jitter
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-sms-notifications/16-RESEARCH.md

# Existing infrastructure

@backend/src/jobs/index.ts
@backend/src/services/queue.service.ts

# Reference implementation for patterns

@supabase/functions/send-sms-alert/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Telnyx SDK and create TelnyxService</name>
  <files>
    backend/package.json
    backend/src/services/telnyx.service.ts
  </files>
  <action>
Install Telnyx Node.js SDK:
```bash
cd backend && npm install telnyx
```

Create TelnyxService class in `backend/src/services/telnyx.service.ts`:

1. Import Telnyx SDK (default import, not named)
2. Create TelnyxService class with:
   - Constructor that initializes Telnyx client with API key from env
   - Set maxRetries: 0 (we handle retries via BullMQ)
   - Set timeout: 30000 (30 seconds)
3. Implement `sendSms` method:
   - Parameters: `{ to: string, message: string, messagingProfileId?: string }`
   - Returns: `Promise<{ messageId: string; status: string }>`
   - Uses `client.messages.send()` with from, to, text, messaging_profile_id
   - Extracts messageId and status from response
4. Add proper TypeScript types for parameters and return values
5. Export singleton getter pattern (like QueueService):
   - Private instance variable
   - `setTelnyxService(service)` and `getTelnyxService()` functions

Key patterns from Edge Function reference:

- Use TELNYX_API_KEY, TELNYX_PHONE_NUMBER, TELNYX_MESSAGING_PROFILE_ID from env
- Response has data.id for messageId, data.to[0].status for status
  </action>
  <verify>

1. `cd backend && npm ls telnyx` shows telnyx installed
2. `npx tsc --noEmit` passes without errors
3. TelnyxService exports are importable
   </verify>
   <done>
   TelnyxService class exists with sendSms method, uses Telnyx SDK, environment variables configured, TypeScript compiles cleanly
   </done>
   </task>

<task type="auto">
  <name>Task 2: Create error categorization config and E.164 validation</name>
  <files>
    backend/src/config/telnyx.config.ts
  </files>
  <action>
Create `backend/src/config/telnyx.config.ts` with:

1. UNRECOVERABLE_CODES Set (from research - do NOT retry these):
   - '10001': Inactive phone number
   - '10002': Invalid phone number
   - '20012': Account inactive
   - '20013': Account blocked
   - '40001': Not routable (landline)
   - '40003': Blocked as spam - permanent
   - '40008': Undeliverable
   - '40009': Invalid message body
   - '40012': Invalid destination number
   - '40300': Opted out (STOP)
   - '40301': Do-not-contact list

2. RETRYABLE_CODES Set (transient, retry with backoff):
   - '10007': Unexpected error
   - '10011': Too many requests (rate limit)
   - '40002': Blocked as spam - temporary
   - '40004': Rejected by destination (may succeed later)
   - '40005': Message expired during transmission
   - '40006': Recipient server unavailable
   - '40014': Message expired in queue
   - '40018': AT&T rate limit
   - '50000': Internal Telnyx error
   - '50001': Service temporarily unavailable

3. Error categorization function:

```typescript
export function categorizeError(errorCode: string): 'unrecoverable' | 'retryable' | 'unknown' {
  if (UNRECOVERABLE_CODES.has(errorCode)) return 'unrecoverable';
  if (RETRYABLE_CODES.has(errorCode)) return 'retryable';
  return 'unknown'; // Default to retry for unknown errors
}
```

4. E.164 validation (from Edge Function):

```typescript
const E164_REGEX = /^\+[1-9]\d{1,14}$/;
export function validateE164(phone: string): boolean {
  return E164_REGEX.test(phone);
}
```

5. Error extraction helper (for Telnyx SDK errors):

```typescript
export function extractErrorCode(error: unknown): string {
  // Telnyx SDK error structure: error.code or error.data.errors[0].code
  if (typeof error === 'object' && error !== null) {
    const e = error as Record<string, unknown>;
    if (typeof e.code === 'string') return e.code;
    if (e.data && typeof e.data === 'object') {
      const data = e.data as Record<string, unknown>;
      if (Array.isArray(data.errors) && data.errors[0]?.code) {
        return String(data.errors[0].code);
      }
    }
  }
  return '';
}

export function extractErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}
```

Export all functions and sets.
</action>
<verify>

1. `npx tsc --noEmit` passes
2. All exports are importable: `categorizeError`, `validateE164`, `extractErrorCode`, `extractErrorMessage`, `UNRECOVERABLE_CODES`, `RETRYABLE_CODES`
   </verify>
   <done>
   Error categorization config exists with all error codes from research, E.164 validation helper works, error extraction helpers work
   </done>
   </task>

<task type="auto">
  <name>Task 3: Add SMS-specific job options to jobs index</name>
  <files>
    backend/src/jobs/index.ts
  </files>
  <action>
Update `backend/src/jobs/index.ts` to add SMS-specific job options:

1. Add new export for SMS job options (after defaultJobOptions):

```typescript
// SMS notification job options with custom backoff for Telnyx
export const smsJobOptions: JobsOptions = {
  attempts: 5,
  backoff: {
    type: 'exponential',
    delay: 2000, // 2s initial, then 4s, 8s, 16s, 32s
  },
  removeOnComplete: 100,
  removeOnFail: 500,
};
```

Note: BullMQ does not natively support jitter in backoff options. The jitter must be implemented in a custom backoff function or accepted as a limitation. For this phase, use standard exponential backoff. If jitter is critical, a future enhancement can add a custom backoff strategy.

2. Extend SmsNotificationJobData with optional fields for tracking:

```typescript
export interface SmsNotificationJobData extends BaseJobData {
  phoneNumber: string;
  message: string;
  alertId?: string;
  // For delivery tracking
  deliveryId?: string;
  // For rate limiting context
  userId?: string;
  alertType?: string;
}
```

  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `smsJobOptions` is exported and has attempts: 5, backoff.type: 'exponential'
  </verify>
  <done>
SMS job options exported with 5 attempts and exponential backoff, SmsNotificationJobData extended with tracking fields
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cd backend && npm ls telnyx` shows package installed
2. `cd backend && npx tsc --noEmit` compiles without errors
3. Files exist:
   - backend/src/services/telnyx.service.ts
   - backend/src/config/telnyx.config.ts
4. Exports are available:
   - TelnyxService from services
   - categorizeError, validateE164 from config
   - smsJobOptions from jobs
</verification>

<success_criteria>

- Telnyx SDK installed in backend/package.json
- TelnyxService wraps SDK with sendSms method
- Error codes categorized (11 unrecoverable, 10 retryable)
- E.164 validation helper exported
- SMS job options with 5 attempts, exponential backoff
- All TypeScript compiles cleanly
  </success_criteria>

<output>
After completion, create `.planning/phases/16-sms-notifications/16-01-SUMMARY.md`
</output>
