---
phase: 16-sms-notifications
plan: 03
type: execute
wave: 3
depends_on: ['16-02']
files_modified:
  - backend/src/services/alert-evaluator.service.ts
  - backend/src/services/telnyx.service.ts
  - backend/src/plugins/queue.plugin.ts
  - backend/tests/workers/sms-notification.test.ts
autonomous: true

must_haves:
  truths:
    - 'Alert escalation to critical severity queues SMS notifications'
    - 'SMS jobs include alertId and deliveryId for tracking'
    - 'TelnyxService initialized on API startup'
    - 'Integration tests verify processor behavior'
  artifacts:
    - path: 'backend/src/services/alert-evaluator.service.ts'
      provides: 'SMS queueing on alert escalation'
      contains: 'addSmsJob'
    - path: 'backend/tests/workers/sms-notification.test.ts'
      provides: 'SMS processor integration tests'
      min_lines: 100
  key_links:
    - from: 'backend/src/services/alert-evaluator.service.ts'
      to: 'backend/src/services/queue.service.ts'
      via: 'getQueueService().addSmsJob()'
      pattern: 'addSmsJob'
    - from: 'backend/src/plugins/queue.plugin.ts'
      to: 'backend/src/services/telnyx.service.ts'
      via: 'TelnyxService initialization'
      pattern: 'setTelnyxService'
---

<objective>
Wire alert escalation to SMS queue and add integration tests

Purpose: Complete the SMS notification pipeline by connecting alert evaluation to the job queue, and verify the entire flow works correctly with integration tests.

Output:

- Alert evaluator queues SMS jobs when alerts escalate to critical
- TelnyxService initialized during API startup
- Integration tests for SMS processor covering success/error cases
- Rate limiting check before queueing (15-minute window)
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-sms-notifications/16-RESEARCH.md
@.planning/phases/16-sms-notifications/16-01-SUMMARY.md
@.planning/phases/16-sms-notifications/16-02-SUMMARY.md

# Dependencies from prior plans

@backend/src/services/telnyx.service.ts
@backend/src/config/telnyx.config.ts
@backend/src/workers/processors/sms-notification.processor.ts
@backend/src/services/queue.service.ts

# Files to modify

@backend/src/services/alert-evaluator.service.ts
@backend/src/plugins/queue.plugin.ts

# Reference patterns

@supabase/functions/send-sms-alert/index.ts
@backend/src/db/schema/notifications.ts
@backend/src/db/schema/users.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize TelnyxService in queue plugin</name>
  <files>
    backend/src/plugins/queue.plugin.ts
    backend/src/services/telnyx.service.ts
  </files>
  <action>
Update `backend/src/plugins/queue.plugin.ts` to initialize TelnyxService alongside QueueService:

1. Import TelnyxService:

```typescript
import { TelnyxService, setTelnyxService } from '../services/telnyx.service.js';
```

2. In the plugin registration (after QueueService initialization), add:

```typescript
// Initialize TelnyxService for SMS notifications
const telnyxService = new TelnyxService();
setTelnyxService(telnyxService);
fastify.log.info('[Queue Plugin] TelnyxService initialized');
```

3. In the shutdown handler (onClose hook), add cleanup:

```typescript
// TelnyxService doesn't need explicit cleanup, but log for consistency
fastify.log.info('[Queue Plugin] TelnyxService shutdown');
```

Note: TelnyxService only needs environment variables to be set. It will fail gracefully if TELNYX_API_KEY is not configured (logged warning, no crash).

Update `backend/src/services/telnyx.service.ts` to handle missing env vars gracefully:

Add validation in constructor:

```typescript
constructor() {
  const apiKey = process.env.TELNYX_API_KEY;
  if (!apiKey) {
    console.warn('[TelnyxService] TELNYX_API_KEY not configured - SMS sending disabled');
    this.enabled = false;
    return;
  }
  this.enabled = true;
  this.client = new Telnyx({
    apiKey,
    maxRetries: 0,
    timeout: 30000,
  });
}
```

Add enabled check in sendSms:

```typescript
async sendSms(...) {
  if (!this.enabled || !this.client) {
    throw new Error('TelnyxService not configured - set TELNYX_API_KEY');
  }
  // ... rest of implementation
}
```

Add `isEnabled()` method for checking if SMS is available.
</action>
<verify>

1. `npx tsc --noEmit` passes
2. Queue plugin imports and initializes TelnyxService
3. TelnyxService handles missing env vars gracefully (logs warning, doesn't crash)
   </verify>
   <done>
   TelnyxService initialized during API startup via queue plugin, handles missing configuration gracefully
   </done>
   </task>

<task type="auto">
  <name>Task 2: Wire alert escalation to SMS queue</name>
  <files>
    backend/src/services/alert-evaluator.service.ts
  </files>
  <action>
Update `backend/src/services/alert-evaluator.service.ts` to queue SMS notifications when alerts escalate:

1. Add imports at top:

```typescript
import { getQueueService } from './queue.service.js';
import { db } from '../db/client.js';
import { notificationDeliveries, profiles } from '../db/schema/index.js';
import { eq, and, gte, inArray } from 'drizzle-orm';
```

2. Add rate limit constant (matching Edge Function):

```typescript
// Rate limit window in milliseconds (15 minutes)
const RATE_LIMIT_WINDOW_MS = 15 * 60 * 1000;
```

3. Create helper function to get alert recipients (users with phone numbers in org):

```typescript
async function getAlertRecipients(
  organizationId: string,
): Promise<Array<{ userId: string; phoneNumber: string }>> {
  // Get users with phone numbers who should receive alerts
  // For now, get all users in org with phone numbers
  // Future: Add notification preferences filtering
  const recipients = await db
    .select({
      userId: profiles.id,
      phoneNumber: profiles.phone,
    })
    .from(profiles)
    .where(
      and(
        eq(profiles.organizationId, organizationId),
        // Only users with phone numbers
        // profiles.phone is not null check
      ),
    );

  return recipients.filter((r) => r.phoneNumber && r.phoneNumber.startsWith('+'));
}
```

4. Create helper function to check rate limit:

```typescript
async function isRateLimited(userId: string, alertType: string): Promise<boolean> {
  const rateLimitCutoff = new Date(Date.now() - RATE_LIMIT_WINDOW_MS);

  const [recentDelivery] = await db
    .select({ id: notificationDeliveries.id })
    .from(notificationDeliveries)
    .where(
      and(
        eq(notificationDeliveries.profileId, userId),
        eq(notificationDeliveries.channel, 'sms'),
        inArray(notificationDeliveries.status, ['sent', 'delivered']),
        gte(notificationDeliveries.sentAt, rateLimitCutoff),
      ),
    )
    .limit(1);

  return !!recentDelivery;
}
```

5. Create helper function to queue SMS for alert:

```typescript
async function queueAlertSms(
  organizationId: string,
  alertId: string,
  message: string,
  alertType: string,
): Promise<void> {
  const queueService = getQueueService();
  if (!queueService || !queueService.isRedisEnabled()) {
    console.log('[Alert SMS] Queue service not available - SMS not sent');
    return;
  }

  const recipients = await getAlertRecipients(organizationId);
  console.log(`[Alert SMS] Found ${recipients.length} recipients for org ${organizationId}`);

  for (const recipient of recipients) {
    // Check rate limit
    if (await isRateLimited(recipient.userId, alertType)) {
      console.log(`[Alert SMS] Rate limited for user ${recipient.userId} - skipping`);
      continue;
    }

    // Create notification delivery record
    const [delivery] = await db
      .insert(notificationDeliveries)
      .values({
        alertId,
        profileId: recipient.userId,
        channel: 'sms',
        recipient: recipient.phoneNumber,
        status: 'pending',
      })
      .returning();

    // Queue SMS job
    await queueService.addSmsJob({
      organizationId,
      phoneNumber: recipient.phoneNumber,
      message,
      alertId,
      deliveryId: delivery.id,
      userId: recipient.userId,
      alertType,
    });

    console.log(
      `[Alert SMS] Queued SMS for user ${recipient.userId} to ${recipient.phoneNumber.slice(0, 5)}***`,
    );
  }
}
```

6. In `evaluateUnitAfterReading`, after alert escalation (STATE TRANSITION 2), add SMS queueing:

```typescript
// After the escalatedAlert update, add:
if (escalatedAlert) {
  // Queue SMS notifications for critical alert
  const alertMessage = `CRITICAL: Temperature alert for unit. ${result.stateChange?.reason || 'Temperature excursion confirmed.'}`;

  // Queue asynchronously - don't await to avoid blocking the reading pipeline
  queueAlertSms(organizationId, escalatedAlert.id, alertMessage, 'alarm_active').catch((err) => {
    console.error('[Alert SMS] Failed to queue SMS:', err);
  });
}
```

IMPORTANT: Don't await queueAlertSms - run it asynchronously to avoid blocking the reading ingestion pipeline. SMS delivery is not time-critical for the reading response.
</action>
<verify>

1. `npx tsc --noEmit` passes
2. alert-evaluator imports getQueueService and uses addSmsJob
3. Rate limiting logic implemented with 15-minute window
4. SMS queued after alert escalation to critical
   </verify>
   <done>
   Alert escalation to critical queues SMS jobs for all org users with phone numbers, rate limiting prevents duplicate SMS within 15 minutes
   </done>
   </task>

<task type="auto">
  <name>Task 3: Create integration tests for SMS processor</name>
  <files>
    backend/tests/workers/sms-notification.test.ts
  </files>
  <action>
Create integration tests in `backend/tests/workers/sms-notification.test.ts`:

```typescript
/**
 * SMS Notification Processor Integration Tests
 *
 * These tests verify the SMS processor behavior including:
 * - Successful SMS sending
 * - E.164 validation
 * - Error categorization (unrecoverable vs retryable)
 * - UnrecoverableError handling
 *
 * NOTE: Tests mock TelnyxService to avoid real API calls.
 * Run with: npm test -- tests/workers/sms-notification.test.ts
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { Job, UnrecoverableError } from 'bullmq';
import { processSmsNotification } from '../../src/workers/processors/sms-notification.processor.js';
import { setTelnyxService, TelnyxService } from '../../src/services/telnyx.service.js';
import { categorizeError, validateE164 } from '../../src/config/telnyx.config.js';
import type { SmsNotificationJobData } from '../../src/jobs/index.js';

// Mock TelnyxService
const mockSendSms = vi.fn();
const mockTelnyxService = {
  sendSms: mockSendSms,
  isEnabled: () => true,
} as unknown as TelnyxService;

// Mock database operations
vi.mock('../../src/db/client.js', () => ({
  db: {
    update: vi.fn().mockReturnValue({
      set: vi.fn().mockReturnValue({
        where: vi.fn().mockResolvedValue([]),
      }),
    }),
  },
}));

describe('SMS Notification Processor', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    setTelnyxService(mockTelnyxService);
  });

  afterEach(() => {
    setTelnyxService(null as unknown as TelnyxService);
  });

  describe('E.164 Validation', () => {
    it('should validate correct E.164 numbers', () => {
      expect(validateE164('+15551234567')).toBe(true);
      expect(validateE164('+442071234567')).toBe(true);
      expect(validateE164('+61412345678')).toBe(true);
    });

    it('should reject invalid phone numbers', () => {
      expect(validateE164('5551234567')).toBe(false);
      expect(validateE164('+1555')).toBe(false);
      expect(validateE164('not-a-number')).toBe(false);
      expect(validateE164('')).toBe(false);
    });
  });

  describe('Error Categorization', () => {
    it('should categorize opted-out as unrecoverable', () => {
      expect(categorizeError('40300')).toBe('unrecoverable');
    });

    it('should categorize invalid number as unrecoverable', () => {
      expect(categorizeError('40012')).toBe('unrecoverable');
    });

    it('should categorize rate limit as retryable', () => {
      expect(categorizeError('10011')).toBe('retryable');
    });

    it('should categorize internal error as retryable', () => {
      expect(categorizeError('50000')).toBe('retryable');
    });

    it('should categorize unknown codes as unknown', () => {
      expect(categorizeError('99999')).toBe('unknown');
    });
  });

  describe('processSmsNotification', () => {
    const createMockJob = (
      data: Partial<SmsNotificationJobData> = {},
    ): Job<SmsNotificationJobData> => {
      const defaultData: SmsNotificationJobData = {
        organizationId: 'org-123',
        phoneNumber: '+15551234567',
        message: 'Test alert message',
        alertId: 'alert-456',
        ...data,
      };

      return {
        id: 'job-789',
        data: defaultData,
        attemptsMade: 0,
        opts: { attempts: 5 },
      } as unknown as Job<SmsNotificationJobData>;
    };

    it('should send SMS successfully', async () => {
      mockSendSms.mockResolvedValueOnce({
        messageId: 'msg-123',
        status: 'queued',
      });

      const job = createMockJob();
      const result = await processSmsNotification(job);

      expect(result.success).toBe(true);
      expect(result.messageId).toBe('msg-123');
      expect(mockSendSms).toHaveBeenCalledWith({
        to: '+15551234567',
        message: 'Test alert message',
      });
    });

    it('should throw UnrecoverableError for invalid phone number', async () => {
      const job = createMockJob({ phoneNumber: 'invalid' });

      await expect(processSmsNotification(job)).rejects.toThrow(UnrecoverableError);
    });

    it('should throw UnrecoverableError for opted-out number', async () => {
      mockSendSms.mockRejectedValueOnce({
        code: '40300',
        message: 'Number opted out',
      });

      const job = createMockJob();

      await expect(processSmsNotification(job)).rejects.toThrow(UnrecoverableError);
    });

    it('should throw regular Error for retryable failures', async () => {
      mockSendSms.mockRejectedValueOnce({
        code: '50000',
        message: 'Internal error',
      });

      const job = createMockJob();

      await expect(processSmsNotification(job)).rejects.toThrow(Error);
      await expect(processSmsNotification(job)).rejects.not.toThrow(UnrecoverableError);
    });

    it('should throw Error when TelnyxService not configured', async () => {
      setTelnyxService(null as unknown as TelnyxService);
      const job = createMockJob();

      await expect(processSmsNotification(job)).rejects.toThrow('TelnyxService not initialized');
    });
  });
});
```

Create the tests directory if it doesn't exist:

```bash
mkdir -p backend/tests/workers
```

  </action>
  <verify>
1. Test file exists at backend/tests/workers/sms-notification.test.ts
2. `cd backend && npm test -- tests/workers/sms-notification.test.ts` runs without import errors
3. Tests cover: E.164 validation, error categorization, success case, unrecoverable error, retryable error
  </verify>
  <done>
Integration tests created covering SMS processor success, E.164 validation, unrecoverable/retryable error handling, TelnyxService unavailable
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cd backend && npx tsc --noEmit` compiles without errors
2. `cd backend && npm test -- tests/workers/sms-notification.test.ts` passes
3. Alert evaluator:
   - Imports getQueueService
   - Calls addSmsJob after alert escalation
   - Implements rate limiting (15-minute window)
4. Queue plugin initializes TelnyxService on startup
5. TelnyxService handles missing env vars gracefully
</verification>

<success_criteria>

- TelnyxService initialized during API startup via queue plugin
- TelnyxService handles missing TELNYX_API_KEY gracefully (logs warning, no crash)
- Alert escalation to critical queues SMS for all org users with phone numbers
- Rate limiting prevents duplicate SMS within 15-minute window
- notification_deliveries record created before queueing SMS
- Integration tests pass for SMS processor
- All TypeScript compiles cleanly
  </success_criteria>

<output>
After completion, create `.planning/phases/16-sms-notifications/16-03-SUMMARY.md`
</output>
