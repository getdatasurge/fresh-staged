---
phase: 07-production-deployment-cutover
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/Dockerfile
  - compose.production.yaml
  - secrets/.gitignore
  - .env.production.example
autonomous: true

must_haves:
  truths:
    - 'Backend builds successfully with multi-stage Docker build'
    - 'Production compose file defines resource limits for all services'
    - 'Secrets are file-based, not environment variables'
    - 'Health checks defined for all services'
  artifacts:
    - path: 'backend/Dockerfile'
      provides: 'Multi-stage build for dev and production'
      contains: 'FROM node:20-alpine AS production'
    - path: 'compose.production.yaml'
      provides: 'Production overrides with resource limits and secrets'
      contains: 'deploy:'
    - path: 'secrets/.gitignore'
      provides: 'Secrets directory structure'
      contains: '*.txt'
  key_links:
    - from: 'compose.production.yaml'
      to: 'backend/Dockerfile'
      via: 'build target'
      pattern: 'target: production'
    - from: 'compose.production.yaml'
      to: 'secrets/'
      via: 'secret mounts'
      pattern: 'secrets:'
---

<objective>
Create production infrastructure foundation with Docker multi-stage builds, compose production overrides, and file-based secrets management.

Purpose: Enable production deployment with proper resource constraints, security, and restart policies.
Output: Dockerfile for backend, compose.production.yaml with production overrides, secrets directory structure.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-production-deployment-cutover/07-RESEARCH.md

Reference existing compose file:
@docker-compose.yml

Reference backend structure:
@backend/package.json
@backend/tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backend Dockerfile with multi-stage build</name>
  <files>backend/Dockerfile</files>
  <action>
Create a multi-stage Dockerfile for the backend with:

**Stage 1 - deps:** Install dependencies only (for caching)

- FROM node:20-alpine AS deps
- Enable corepack for pnpm
- Copy package.json and pnpm-lock.yaml
- Run pnpm install --frozen-lockfile

**Stage 2 - builder:** Build TypeScript

- FROM node:20-alpine AS builder
- Copy from deps stage
- Copy source files
- Run pnpm build (add build script to package.json if missing: "build": "tsc")

**Stage 3 - development:** Dev target with hot reload

- FROM node:20-alpine AS development
- Set NODE_ENV=development
- Install dev dependencies
- Mount source for hot reload
- CMD ["pnpm", "dev"]

**Stage 4 - production:** Minimal production image

- FROM node:20-alpine AS production
- Set NODE_ENV=production
- Create non-root user (node:node)
- Copy only built artifacts from builder
- Copy only production dependencies
- Expose port 3000
- Add healthcheck using curl (install curl in alpine)
- CMD ["node", "dist/index.js"]

Add curl to production stage: RUN apk add --no-cache curl

Ensure proper .dockerignore exists (node_modules, dist, .env, etc.)
</action>
<verify>docker build -t freshtrack-backend:test --target production ./backend (should succeed)</verify>
<done>Backend Dockerfile builds successfully with both development and production targets</done>
</task>

<task type="auto">
  <name>Task 2: Create compose.production.yaml with production overrides</name>
  <files>compose.production.yaml</files>
  <action>
Create compose.production.yaml that layers over docker-compose.yml with production-specific settings:

**Backend service overrides:**

```yaml
services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
      target: production
    volumes: [] # Remove dev hot-reload volumes
    environment:
      NODE_ENV: production
      LOG_LEVEL: info
      # Non-secret env vars only
      PORT: 3000
      HOST: 0.0.0.0
    ports:
      - '127.0.0.1:3000:3000' # Bind localhost only (Caddy proxies)
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 256M
      restart_policy:
        condition: any
        delay: 5s
        max_attempts: 3
        window: 120s
    secrets:
      - postgres_password
      - jwt_secret
      - stack_auth_secret
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://localhost:3000/health']
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    depends_on:
      redis:
        condition: service_healthy
```

**Redis service overrides:**

```yaml
redis:
  deploy:
    resources:
      limits:
        memory: 256M
      reservations:
        memory: 128M
```

**MinIO service overrides:**

```yaml
minio:
  environment:
    MINIO_ROOT_USER_FILE: /run/secrets/minio_user
    MINIO_ROOT_PASSWORD_FILE: /run/secrets/minio_password
  secrets:
    - minio_user
    - minio_password
  deploy:
    resources:
      limits:
        memory: 512M
      reservations:
        memory: 256M
```

**Secrets section:**

```yaml
secrets:
  postgres_password:
    file: ./secrets/postgres_password.txt
  jwt_secret:
    file: ./secrets/jwt_secret.txt
  stack_auth_secret:
    file: ./secrets/stack_auth_secret.txt
  minio_user:
    file: ./secrets/minio_user.txt
  minio_password:
    file: ./secrets/minio_password.txt
```

Remove admin profile services (pgadmin, redis-commander) - not for production.
</action>
<verify>docker compose -f docker-compose.yml -f compose.production.yaml config (validates merged config)</verify>
<done>Production compose file validates and shows resource limits, secrets, health checks</done>
</task>

<task type="auto">
  <name>Task 3: Create secrets directory and environment template</name>
  <files>secrets/.gitignore, .env.production.example</files>
  <action>
**Create secrets/.gitignore:**
```
# Ignore all secret files
*.txt
*.key
*.pem

# Keep this .gitignore

!.gitignore

````

**Create .env.production.example** (non-secret production vars):
```bash
# FreshTrack Pro Production Environment
# Copy to .env.production and fill in values

# ===========================================
# Application
# ===========================================
NODE_ENV=production
LOG_LEVEL=info
PORT=3000
HOST=0.0.0.0

# ===========================================
# Domain Configuration
# ===========================================
FRONTEND_URL=https://app.freshtrackpro.com
API_URL=https://api.freshtrackpro.com
MONITORING_URL=https://monitoring.freshtrackpro.com
STATUS_URL=https://status.freshtrackpro.com

# ===========================================
# Database (Managed PostgreSQL)
# ===========================================
# Connection string for managed PostgreSQL
# Example: postgresql://user:password@host:port/database?sslmode=require
DATABASE_URL=postgresql://user:password@db-host:25060/frostguard?sslmode=require

# ===========================================
# Stack Auth
# ===========================================
STACK_AUTH_PROJECT_ID=your-project-id
STACK_AUTH_API_URL=https://api.stack-auth.com

# ===========================================
# External Services
# ===========================================
# TTN (The Things Network)
TTN_APP_ID=your-ttn-app-id

# Telnyx (SMS Notifications)
TELNYX_API_KEY=your-telnyx-api-key
TELNYX_MESSAGING_PROFILE_ID=your-messaging-profile

# ===========================================
# Secrets (file-based - see secrets/ directory)
# ===========================================
# Do NOT put secrets here. Use file-based secrets:
# - secrets/postgres_password.txt
# - secrets/jwt_secret.txt
# - secrets/stack_auth_secret.txt
# - secrets/minio_user.txt
# - secrets/minio_password.txt
````

**Create placeholder secret files for documentation:**
Create secrets/README.md explaining what secrets are needed:

```markdown
# Production Secrets

Create the following files in this directory (never commit actual values):

1. `postgres_password.txt` - PostgreSQL password (managed DB or local)
2. `jwt_secret.txt` - JWT signing secret (generate: openssl rand -base64 32)
3. `stack_auth_secret.txt` - Stack Auth API secret
4. `minio_user.txt` - MinIO root user
5. `minio_password.txt` - MinIO root password (generate: openssl rand -base64 32)

## Generating Secure Secrets

\`\`\`bash

# Generate random secrets

openssl rand -base64 32 > jwt_secret.txt
openssl rand -base64 32 > minio_password.txt

# Or use pwgen

pwgen -s 32 1 > jwt_secret.txt
\`\`\`

## File Permissions

Ensure restricted permissions:
\`\`\`bash
chmod 600 secrets/\*.txt
\`\`\`
```

  </action>
  <verify>ls -la secrets/ shows .gitignore and README.md; cat .env.production.example shows template</verify>
  <done>Secrets directory created with documentation, .env.production.example provides template</done>
</task>

</tasks>

<verification>
Run all verification commands:
1. `docker build -t freshtrack-backend:test --target production ./backend` - Backend builds
2. `docker compose -f docker-compose.yml -f compose.production.yaml config` - Config validates
3. `ls secrets/` - Directory exists with .gitignore
4. `grep -q "deploy:" compose.production.yaml` - Resource limits present
5. `grep -q "secrets:" compose.production.yaml` - Secrets section present
</verification>

<success_criteria>

- Backend Dockerfile builds both dev and prod targets
- compose.production.yaml layers correctly over base
- All services have resource limits defined
- Secrets use file-based approach (not env vars)
- Health checks defined for all services
- Non-root user in production container
  </success_criteria>

<output>
After completion, create `.planning/phases/07-production-deployment-cutover/07-01-SUMMARY.md`
</output>
