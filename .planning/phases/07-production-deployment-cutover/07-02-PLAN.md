---
phase: 07-production-deployment-cutover
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docker/caddy/Caddyfile
  - backend/src/routes/health.ts
  - backend/src/app.ts
autonomous: true

must_haves:
  truths:
    - "Caddy serves HTTPS with automatic Let's Encrypt certificates"
    - 'Backend health endpoint returns status, uptime, and dependency checks'
    - 'Reverse proxy passes correct headers (X-Real-IP, X-Forwarded-For)'
  artifacts:
    - path: 'docker/caddy/Caddyfile'
      provides: 'Reverse proxy configuration with auto-HTTPS'
      contains: 'reverse_proxy'
    - path: 'backend/src/routes/health.ts'
      provides: 'Health check endpoint with dependency checks'
      exports: ['healthRoutes']
  key_links:
    - from: 'Caddyfile'
      to: 'backend:3000'
      via: 'reverse_proxy directive'
      pattern: 'reverse_proxy backend:3000'
    - from: 'health.ts'
      to: 'app.ts'
      via: 'route registration'
      pattern: 'healthRoutes'
---

<objective>
Set up Caddy reverse proxy with automatic HTTPS and create comprehensive health check endpoint for the backend.

Purpose: Secure traffic with TLS, provide health monitoring for Docker and external uptime checks.
Output: Caddyfile configuration, health route implementation, backend integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-production-deployment-cutover/07-RESEARCH.md

Reference backend app structure:
@backend/src/app.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Caddy reverse proxy configuration</name>
  <files>docker/caddy/Caddyfile</files>
  <action>
Create docker/caddy/ directory and Caddyfile:

**docker/caddy/Caddyfile:**

```
# FreshTrack Pro Caddy Configuration
# Automatic HTTPS via Let's Encrypt

{
    # Admin email for Let's Encrypt notifications
    email admin@freshtrackpro.com

    # Access logging
    log {
        output file /var/log/caddy/access.log
        format json
    }
}

# Main application
{$DOMAIN:localhost} {
    # Reverse proxy to backend API
    reverse_proxy /api/* backend:3000 {
        # Health check for load balancing
        health_uri /health
        health_interval 30s
        health_timeout 10s

        # Pass client info headers
        header_up Host {host}
        header_up X-Real-IP {remote_host}
        header_up X-Forwarded-For {remote_host}
        header_up X-Forwarded-Proto {scheme}
    }

    # Health endpoint for external monitoring
    reverse_proxy /health backend:3000

    # Static frontend files (when frontend is containerized)
    # For now, proxy to frontend dev server or serve static
    reverse_proxy /* frontend:5173 {
        # Fallback if frontend not running
        @frontend_down {
            not host backend
        }
    }

    # Response compression
    encode gzip zstd

    # Security headers
    header {
        # HSTS (1 year, include subdomains)
        Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
        # Prevent content type sniffing
        X-Content-Type-Options "nosniff"
        # Clickjacking protection
        X-Frame-Options "DENY"
        # Referrer policy
        Referrer-Policy "strict-origin-when-cross-origin"
        # Remove server identification
        -Server
    }
}

# Monitoring subdomain (Grafana)
monitoring.{$DOMAIN:localhost} {
    reverse_proxy grafana:3000 {
        header_up Host {host}
        header_up X-Real-IP {remote_host}
    }
}

# Status page subdomain (Uptime Kuma)
status.{$DOMAIN:localhost} {
    reverse_proxy uptime-kuma:3001 {
        header_up Host {host}
        header_up X-Real-IP {remote_host}
    }
}
```

This configuration:

- Uses environment variable DOMAIN for flexibility (localhost for dev, domain for prod)
- Auto-provisions Let's Encrypt certificates
- Proxies /api/\* to backend
- Adds security headers
- Enables compression
- Supports monitoring and status subdomains
  </action>
  <verify>cat docker/caddy/Caddyfile shows reverse_proxy and security headers</verify>
  <done>Caddyfile created with auto-HTTPS, security headers, and reverse proxy config</done>
  </task>

<task type="auto">
  <name>Task 2: Create comprehensive health check endpoint</name>
  <files>backend/src/routes/health.ts</files>
  <action>
Create backend/src/routes/health.ts with comprehensive health checks:

```typescript
import type { FastifyPluginAsync } from 'fastify';
import { db } from '../db/index.js';
import { sql } from 'drizzle-orm';

interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  uptime: number;
  timestamp: string;
  version: string;
  checks: {
    database: HealthCheck;
    redis?: HealthCheck;
  };
}

interface HealthCheck {
  status: 'pass' | 'fail';
  latency_ms?: number;
  message?: string;
}

const checkDatabase = async (): Promise<HealthCheck> => {
  const start = Date.now();
  try {
    // Simple query to verify database connectivity
    await db.execute(sql`SELECT 1`);
    return {
      status: 'pass',
      latency_ms: Date.now() - start,
    };
  } catch (error) {
    return {
      status: 'fail',
      message: error instanceof Error ? error.message : 'Database unreachable',
    };
  }
};

// Redis check placeholder - uncomment when Redis client is added
// const checkRedis = async (): Promise<HealthCheck> => {
//   const start = Date.now();
//   try {
//     await redis.ping();
//     return {
//       status: 'pass',
//       latency_ms: Date.now() - start,
//     };
//   } catch (error) {
//     return {
//       status: 'fail',
//       message: error instanceof Error ? error.message : 'Redis unreachable',
//     };
//   }
// };

export const healthRoutes: FastifyPluginAsync = async (fastify) => {
  // Basic liveness probe (for Docker/k8s)
  fastify.get('/health', async (request, reply) => {
    const dbCheck = await checkDatabase();
    // const redisCheck = await checkRedis();

    const checks = {
      database: dbCheck,
      // redis: redisCheck,
    };

    // Determine overall status
    const allPassing = Object.values(checks).every((c) => c.status === 'pass');
    const status: HealthStatus['status'] = allPassing ? 'healthy' : 'unhealthy';

    const response: HealthStatus = {
      status,
      uptime: process.uptime(),
      timestamp: new Date().toISOString(),
      version: process.env.npm_package_version || '1.0.0',
      checks,
    };

    // Return 503 if unhealthy (for load balancer/Docker health checks)
    if (status === 'unhealthy') {
      return reply.code(503).send(response);
    }

    return response;
  });

  // Kubernetes-style readiness probe (can serve traffic?)
  fastify.get('/health/ready', async (request, reply) => {
    const dbCheck = await checkDatabase();

    if (dbCheck.status === 'fail') {
      return reply.code(503).send({
        ready: false,
        reason: 'Database not available',
      });
    }

    return { ready: true };
  });

  // Kubernetes-style liveness probe (is process alive?)
  fastify.get('/health/live', async () => {
    return { alive: true };
  });
};
```

This provides:

- `/health` - Full health status with dependency checks (503 if unhealthy)
- `/health/ready` - Readiness probe for traffic routing
- `/health/live` - Liveness probe for container orchestration
- Latency measurements for database
- Version reporting
- Proper HTTP status codes for health check consumers
  </action>
  <verify>grep -q "healthRoutes" backend/src/routes/health.ts</verify>
  <done>Health routes created with database checks, readiness probe, and liveness probe</done>
  </task>

<task type="auto">
  <name>Task 3: Register health routes in app.ts</name>
  <files>backend/src/app.ts</files>
  <action>
Update backend/src/app.ts to register the health routes:

1. Add import at the top with other route imports:

```typescript
import { healthRoutes } from './routes/health.js';
```

2. Register health routes BEFORE auth middleware (health checks should be public):

```typescript
// Health check routes (no auth required)
app.register(healthRoutes);
```

Make sure health routes are registered early in the middleware chain, before any authentication plugins.

The health endpoint should be accessible at:

- GET /health - Full status with DB check
- GET /health/ready - Readiness probe
- GET /health/live - Liveness probe

These must be unauthenticated endpoints for Docker health checks and load balancer probes.
</action>
<verify>grep -q "healthRoutes" backend/src/app.ts</verify>
<done>Health routes registered in app.ts, accessible without authentication</done>
</task>

</tasks>

<verification>
Run all verification commands:
1. `cat docker/caddy/Caddyfile | grep reverse_proxy` - Caddy config has reverse proxy
2. `cat backend/src/routes/health.ts | grep healthRoutes` - Health routes exported
3. `grep healthRoutes backend/src/app.ts` - Health routes registered
4. Start backend and test: `curl http://localhost:3000/health` returns JSON health status
</verification>

<success_criteria>

- Caddy configuration supports auto-HTTPS via Let's Encrypt
- Caddyfile includes security headers (HSTS, X-Frame-Options, etc.)
- Health endpoint checks database connectivity
- Health endpoint returns 503 when dependencies fail
- Readiness and liveness probes implemented
- Health routes registered before auth middleware
  </success_criteria>

<output>
After completion, create `.planning/phases/07-production-deployment-cutover/07-02-SUMMARY.md`
</output>
