---
phase: 07-production-deployment-cutover
plan: 04
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - scripts/deploy.sh
  - scripts/rollback.sh
  - scripts/health-check.sh
  - compose.production.yaml
autonomous: true

must_haves:
  truths:
    - "deploy.sh automates production deployment with pre-flight checks"
    - "rollback.sh reverses cutover with human confirmation prompts"
    - "health-check.sh validates system readiness before deployment"
    - "Scripts handle errors gracefully and provide clear output"
  artifacts:
    - path: "scripts/deploy.sh"
      provides: "Automated deployment script"
      contains: "docker compose"
    - path: "scripts/rollback.sh"
      provides: "Rollback procedure with confirmations"
      contains: "read -p"
    - path: "scripts/health-check.sh"
      provides: "Pre-flight validation"
      contains: "exit 1"
  key_links:
    - from: "scripts/deploy.sh"
      to: "scripts/health-check.sh"
      via: "pre-flight invocation"
      pattern: "health-check.sh"
    - from: "scripts/deploy.sh"
      to: "compose.production.yaml"
      via: "docker compose invocation"
      pattern: "compose.production.yaml"
---

<objective>
Create deployment, rollback, and health-check automation scripts for production operations.

Purpose: Automate deployment procedures, ensure consistent rollback capability, validate system health before changes.
Output: Executable bash scripts for deploy, rollback, and pre-flight checks.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-production-deployment-cutover/07-RESEARCH.md
@.planning/phases/07-production-deployment-cutover/07-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pre-flight health check script</name>
  <files>scripts/health-check.sh</files>
  <action>
Create scripts/health-check.sh:

```bash
#!/bin/bash
# ===========================================
# FreshTrack Pro Pre-Deployment Health Checks
# ===========================================
# Usage: ./scripts/health-check.sh
# Exit codes: 0 = all checks pass, 1 = check failed

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

echo "=== FreshTrack Pro Pre-Flight Checks ==="
echo "Project root: $PROJECT_ROOT"
echo ""

ERRORS=0

# Helper function for check results
check_pass() {
    echo "âœ“ $1"
}

check_fail() {
    echo "âœ— $1"
    ERRORS=$((ERRORS + 1))
}

# ===========================================
# System Checks
# ===========================================
echo "--- System Checks ---"

# Check disk space (need at least 5GB free)
DISK_FREE_KB=$(df "$PROJECT_ROOT" | tail -1 | awk '{print $4}')
DISK_FREE_GB=$((DISK_FREE_KB / 1024 / 1024))
if [ "$DISK_FREE_KB" -lt 5242880 ]; then
    check_fail "Disk space: ${DISK_FREE_GB}GB free (need 5GB minimum)"
else
    check_pass "Disk space: ${DISK_FREE_GB}GB free"
fi

# Check Docker running
if docker info > /dev/null 2>&1; then
    DOCKER_VERSION=$(docker version --format '{{.Server.Version}}')
    check_pass "Docker running: v${DOCKER_VERSION}"
else
    check_fail "Docker not running or not accessible"
fi

# Check Docker Compose
if docker compose version > /dev/null 2>&1; then
    COMPOSE_VERSION=$(docker compose version --short)
    check_pass "Docker Compose: v${COMPOSE_VERSION}"
else
    check_fail "Docker Compose not available"
fi

# ===========================================
# Configuration Checks
# ===========================================
echo ""
echo "--- Configuration Checks ---"

# Check compose files exist
if [ -f "$PROJECT_ROOT/docker-compose.yml" ]; then
    check_pass "docker-compose.yml exists"
else
    check_fail "docker-compose.yml missing"
fi

if [ -f "$PROJECT_ROOT/compose.production.yaml" ]; then
    check_pass "compose.production.yaml exists"
else
    check_fail "compose.production.yaml missing"
fi

# Check secrets exist
SECRETS_DIR="$PROJECT_ROOT/secrets"
REQUIRED_SECRETS=("postgres_password.txt" "jwt_secret.txt" "stack_auth_secret.txt" "grafana_password.txt")

if [ -d "$SECRETS_DIR" ]; then
    check_pass "Secrets directory exists"

    for secret in "${REQUIRED_SECRETS[@]}"; do
        if [ -f "$SECRETS_DIR/$secret" ]; then
            # Check file is not empty
            if [ -s "$SECRETS_DIR/$secret" ]; then
                check_pass "Secret: $secret"
            else
                check_fail "Secret empty: $secret"
            fi
        else
            check_fail "Secret missing: $secret"
        fi
    done
else
    check_fail "Secrets directory missing"
fi

# Check environment file
if [ -f "$PROJECT_ROOT/.env.production" ]; then
    check_pass ".env.production exists"
else
    echo "  âš  .env.production not found (optional if using compose defaults)"
fi

# ===========================================
# Compose Validation
# ===========================================
echo ""
echo "--- Compose Validation ---"

# Validate compose config
if docker compose -f "$PROJECT_ROOT/docker-compose.yml" -f "$PROJECT_ROOT/compose.production.yaml" config > /dev/null 2>&1; then
    check_pass "Compose configuration valid"
else
    check_fail "Compose configuration invalid"
    docker compose -f "$PROJECT_ROOT/docker-compose.yml" -f "$PROJECT_ROOT/compose.production.yaml" config 2>&1 | head -5
fi

# ===========================================
# Network Checks
# ===========================================
echo ""
echo "--- Network Checks ---"

# Check if ports are available (only if services not already running)
PORTS_TO_CHECK=(80 443 3000 9090 3100 3001)
for port in "${PORTS_TO_CHECK[@]}"; do
    if ! ss -tuln | grep -q ":${port} " 2>/dev/null; then
        check_pass "Port $port available"
    else
        # Port in use - check if it's our container
        CONTAINER=$(docker ps --filter "publish=$port" --format "{{.Names}}" 2>/dev/null)
        if [ -n "$CONTAINER" ]; then
            echo "  âš  Port $port in use by container: $CONTAINER"
        else
            check_fail "Port $port in use by external process"
        fi
    fi
done

# ===========================================
# Summary
# ===========================================
echo ""
echo "=== Summary ==="

if [ $ERRORS -eq 0 ]; then
    echo "All pre-flight checks passed!"
    exit 0
else
    echo "Failed checks: $ERRORS"
    echo "Please fix the issues above before deploying."
    exit 1
fi
```

Make the script executable: `chmod +x scripts/health-check.sh`
  </action>
  <verify>bash -n scripts/health-check.sh (syntax check) && test -x scripts/health-check.sh (executable)</verify>
  <done>Health check script created with disk, Docker, secrets, config, and port validation</done>
</task>

<task type="auto">
  <name>Task 2: Create deployment automation script</name>
  <files>scripts/deploy.sh</files>
  <action>
Create scripts/deploy.sh:

```bash
#!/bin/bash
# ===========================================
# FreshTrack Pro Production Deployment
# ===========================================
# Usage: ./scripts/deploy.sh [--skip-checks] [--no-build]

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Parse arguments
SKIP_CHECKS=false
NO_BUILD=false
for arg in "$@"; do
    case $arg in
        --skip-checks) SKIP_CHECKS=true ;;
        --no-build) NO_BUILD=true ;;
    esac
done

echo "=== FreshTrack Pro Production Deployment ==="
echo "Time: $(date -Iseconds)"
echo ""

# ===========================================
# Step 1: Pre-flight Checks
# ===========================================
if [ "$SKIP_CHECKS" = false ]; then
    echo "Step 1: Running pre-flight checks..."
    if ! "$SCRIPT_DIR/health-check.sh"; then
        echo ""
        echo "Pre-flight checks failed. Use --skip-checks to override (not recommended)."
        exit 1
    fi
    echo ""
else
    echo "Step 1: Skipping pre-flight checks (--skip-checks)"
    echo ""
fi

# ===========================================
# Step 2: Pull Latest Images
# ===========================================
echo "Step 2: Pulling latest images..."
docker compose -f "$PROJECT_ROOT/docker-compose.yml" \
               -f "$PROJECT_ROOT/compose.production.yaml" \
               pull --quiet
echo "âœ“ Images pulled"
echo ""

# ===========================================
# Step 3: Build Backend (if needed)
# ===========================================
if [ "$NO_BUILD" = false ]; then
    echo "Step 3: Building backend..."
    docker compose -f "$PROJECT_ROOT/docker-compose.yml" \
                   -f "$PROJECT_ROOT/compose.production.yaml" \
                   build backend
    echo "âœ“ Backend built"
else
    echo "Step 3: Skipping build (--no-build)"
fi
echo ""

# ===========================================
# Step 4: Run Database Migrations
# ===========================================
echo "Step 4: Running database migrations..."
# Run migrations in a one-off container
docker compose -f "$PROJECT_ROOT/docker-compose.yml" \
               -f "$PROJECT_ROOT/compose.production.yaml" \
               run --rm backend pnpm db:migrate || {
    echo "âœ— Migrations failed"
    exit 1
}
echo "âœ“ Migrations complete"
echo ""

# ===========================================
# Step 5: Deploy Services
# ===========================================
echo "Step 5: Deploying services..."
docker compose -f "$PROJECT_ROOT/docker-compose.yml" \
               -f "$PROJECT_ROOT/compose.production.yaml" \
               up -d
echo "âœ“ Services started"
echo ""

# ===========================================
# Step 6: Wait for Health Checks
# ===========================================
echo "Step 6: Waiting for services to become healthy..."

MAX_WAIT=120
WAITED=0
INTERVAL=5

while [ $WAITED -lt $MAX_WAIT ]; do
    # Check if backend is healthy
    BACKEND_HEALTH=$(docker inspect --format='{{.State.Health.Status}}' frostguard-backend 2>/dev/null || echo "not_found")

    if [ "$BACKEND_HEALTH" = "healthy" ]; then
        echo "âœ“ Backend healthy after ${WAITED}s"
        break
    fi

    if [ "$BACKEND_HEALTH" = "unhealthy" ]; then
        echo "âœ— Backend unhealthy"
        echo "Logs:"
        docker logs frostguard-backend --tail 20
        exit 1
    fi

    echo "  Waiting... (${WAITED}s / ${MAX_WAIT}s) - backend: $BACKEND_HEALTH"
    sleep $INTERVAL
    WAITED=$((WAITED + INTERVAL))
done

if [ $WAITED -ge $MAX_WAIT ]; then
    echo "âœ— Health check timeout after ${MAX_WAIT}s"
    echo "Backend logs:"
    docker logs frostguard-backend --tail 30
    exit 1
fi

echo ""

# ===========================================
# Step 7: Verify Deployment
# ===========================================
echo "Step 7: Verifying deployment..."

# Test health endpoint
HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/health 2>/dev/null || echo "000")
if [ "$HEALTH_RESPONSE" = "200" ]; then
    echo "âœ“ Health endpoint responding (HTTP $HEALTH_RESPONSE)"
else
    echo "âœ— Health endpoint returned HTTP $HEALTH_RESPONSE"
fi

# Show running containers
echo ""
echo "Running containers:"
docker compose -f "$PROJECT_ROOT/docker-compose.yml" \
               -f "$PROJECT_ROOT/compose.production.yaml" \
               ps

# ===========================================
# Step 8: Cleanup
# ===========================================
echo ""
echo "Step 8: Cleaning up old images..."
docker image prune -f --filter "until=24h" > /dev/null
echo "âœ“ Cleanup complete"

# ===========================================
# Done
# ===========================================
echo ""
echo "=== Deployment Complete ==="
echo "Time: $(date -Iseconds)"
echo ""
echo "Next steps:"
echo "  - Monitor: ${MONITORING_URL:-http://localhost:3001}"
echo "  - Logs: docker compose -f docker-compose.yml -f compose.production.yaml logs -f"
echo "  - Status: docker compose -f docker-compose.yml -f compose.production.yaml ps"
```

Make the script executable: `chmod +x scripts/deploy.sh`
  </action>
  <verify>bash -n scripts/deploy.sh (syntax check) && test -x scripts/deploy.sh (executable)</verify>
  <done>Deployment script created with pre-flight, build, migrate, deploy, and health check steps</done>
</task>

<task type="auto">
  <name>Task 3: Create rollback script with confirmation prompts</name>
  <files>scripts/rollback.sh</files>
  <action>
Create scripts/rollback.sh:

```bash
#!/bin/bash
# ===========================================
# FreshTrack Pro Rollback Procedure
# ===========================================
# Usage: ./scripts/rollback.sh [--yes]
#
# This script reverses a failed cutover by:
# 1. Stopping the new system
# 2. Exporting any data created after cutover
# 3. Providing DNS change instructions
# 4. Documenting the rollback for post-mortem

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
EXPORT_DIR="$PROJECT_ROOT/rollback-exports/$(date +%Y%m%d-%H%M%S)"

# Parse arguments
AUTO_CONFIRM=false
for arg in "$@"; do
    case $arg in
        --yes|-y) AUTO_CONFIRM=true ;;
    esac
done

# Color output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

echo -e "${RED}=== FreshTrack Pro ROLLBACK PROCEDURE ===${NC}"
echo "Time: $(date -Iseconds)"
echo ""

echo -e "${YELLOW}WARNING: This will roll back to Supabase.${NC}"
echo ""
echo "This procedure will:"
echo "  1. Stop the new FreshTrack Pro system"
echo "  2. Export data created since cutover"
echo "  3. Guide DNS changes to point back to Supabase"
echo "  4. Create rollback documentation"
echo ""

# ===========================================
# Confirmation
# ===========================================
if [ "$AUTO_CONFIRM" = false ]; then
    read -p "Are you sure you want to proceed with rollback? (yes/no): " CONFIRM
    if [ "$CONFIRM" != "yes" ]; then
        echo "Rollback cancelled."
        exit 0
    fi
fi

echo ""
echo "Starting rollback procedure..."
echo ""

# ===========================================
# Step 1: Stop New System
# ===========================================
echo -e "${YELLOW}Step 1: Stopping new system...${NC}"
read -p "Press Enter to stop services (or Ctrl+C to abort)..."

docker compose -f "$PROJECT_ROOT/docker-compose.yml" \
               -f "$PROJECT_ROOT/compose.production.yaml" \
               stop backend caddy || true

echo "âœ“ Backend and Caddy stopped"
echo ""

# ===========================================
# Step 2: Export Post-Cutover Data
# ===========================================
echo -e "${YELLOW}Step 2: Exporting post-cutover data...${NC}"

mkdir -p "$EXPORT_DIR"

# Export using migration scripts if database accessible
if docker compose -f "$PROJECT_ROOT/docker-compose.yml" \
                  -f "$PROJECT_ROOT/compose.production.yaml" \
                  exec -T postgres pg_isready -U frostguard > /dev/null 2>&1; then

    echo "Database accessible. Exporting critical tables..."

    # Export recent sensor readings
    docker compose -f "$PROJECT_ROOT/docker-compose.yml" \
                   -f "$PROJECT_ROOT/compose.production.yaml" \
                   exec -T postgres psql -U frostguard -d frostguard \
                   -c "\\COPY (SELECT * FROM sensor_readings WHERE created_at > NOW() - INTERVAL '7 days') TO STDOUT WITH CSV HEADER" \
                   > "$EXPORT_DIR/sensor_readings.csv" 2>/dev/null || echo "  (no recent readings)"

    # Export recent alerts
    docker compose -f "$PROJECT_ROOT/docker-compose.yml" \
                   -f "$PROJECT_ROOT/compose.production.yaml" \
                   exec -T postgres psql -U frostguard -d frostguard \
                   -c "\\COPY (SELECT * FROM alerts WHERE created_at > NOW() - INTERVAL '7 days') TO STDOUT WITH CSV HEADER" \
                   > "$EXPORT_DIR/alerts.csv" 2>/dev/null || echo "  (no recent alerts)"

    # Export user changes
    docker compose -f "$PROJECT_ROOT/docker-compose.yml" \
                   -f "$PROJECT_ROOT/compose.production.yaml" \
                   exec -T postgres psql -U frostguard -d frostguard \
                   -c "\\COPY (SELECT * FROM profiles WHERE updated_at > NOW() - INTERVAL '7 days') TO STDOUT WITH CSV HEADER" \
                   > "$EXPORT_DIR/profiles.csv" 2>/dev/null || echo "  (no recent profile changes)"

    echo "âœ“ Data exported to: $EXPORT_DIR"
else
    echo "âš  Database not accessible. Manual export may be needed later."
    echo "  Note: Data may still be in Docker volumes."
fi

# Create rollback manifest
cat > "$EXPORT_DIR/ROLLBACK_MANIFEST.md" << EOF
# Rollback Manifest

**Rollback Time:** $(date -Iseconds)
**Reason:** [FILL IN REASON]

## Exported Data

- sensor_readings.csv - Readings from last 7 days
- alerts.csv - Alerts from last 7 days
- profiles.csv - Profile changes from last 7 days

## Post-Rollback Actions

1. [ ] Verify DNS pointing to Supabase
2. [ ] Verify users can log in to Supabase system
3. [ ] Verify sensor data flowing to Supabase
4. [ ] Review exported data for manual import
5. [ ] Complete post-mortem analysis

## Root Cause Analysis

[TO BE COMPLETED]

## Prevention Measures

[TO BE COMPLETED]
EOF

echo ""

# ===========================================
# Step 3: DNS Instructions
# ===========================================
echo -e "${YELLOW}Step 3: DNS Configuration${NC}"
echo ""
echo "MANUAL ACTION REQUIRED:"
echo "Update DNS records to point back to Supabase:"
echo ""
echo "  1. Log in to your DNS provider"
echo "  2. Update A/AAAA records for freshtrackpro.com"
echo "  3. Point to Supabase IP: [YOUR_SUPABASE_IP]"
echo "  4. Wait for propagation (should be quick if TTL was lowered)"
echo ""

read -p "Press Enter after DNS has been updated..."

# Verify DNS change (optional)
echo "Checking DNS resolution..."
DIG_RESULT=$(dig +short freshtrackpro.com 2>/dev/null || echo "Could not resolve")
echo "  Current A record: $DIG_RESULT"
echo ""

# ===========================================
# Step 4: Notification
# ===========================================
echo -e "${YELLOW}Step 4: Sending notifications...${NC}"

# If Slack webhook configured
if [ -n "$SLACK_WEBHOOK_URL" ]; then
    curl -s -X POST "$SLACK_WEBHOOK_URL" \
         -H 'Content-Type: application/json' \
         -d '{"text":"ðŸ”´ FreshTrack Pro ROLLBACK COMPLETE - System reverted to Supabase"}' \
         > /dev/null
    echo "âœ“ Slack notification sent"
else
    echo "âš  SLACK_WEBHOOK_URL not set - manual notification needed"
fi

echo ""

# ===========================================
# Step 5: Keep Database Running (for data recovery)
# ===========================================
echo -e "${YELLOW}Step 5: Database preservation${NC}"
echo ""
echo "The PostgreSQL database container is still running for data recovery."
echo "To access it:"
echo "  docker compose -f docker-compose.yml -f compose.production.yaml exec postgres psql -U frostguard"
echo ""
echo "To fully stop all services later:"
echo "  docker compose -f docker-compose.yml -f compose.production.yaml down"
echo ""

# ===========================================
# Done
# ===========================================
echo -e "${GREEN}=== Rollback Complete ===${NC}"
echo "Time: $(date -Iseconds)"
echo ""
echo "Exported data: $EXPORT_DIR"
echo ""
echo "NEXT STEPS:"
echo "  1. Verify Supabase system is accessible"
echo "  2. Verify sensor data is flowing"
echo "  3. Review $EXPORT_DIR/ROLLBACK_MANIFEST.md"
echo "  4. Complete post-mortem within 24 hours"
echo "  5. Notify users if needed"
```

Make the script executable: `chmod +x scripts/rollback.sh`
  </action>
  <verify>bash -n scripts/rollback.sh (syntax check) && test -x scripts/rollback.sh (executable)</verify>
  <done>Rollback script created with confirmation prompts, data export, DNS guidance, and notification</done>
</task>

</tasks>

<verification>
Run all verification commands:
1. `bash -n scripts/health-check.sh && bash -n scripts/deploy.sh && bash -n scripts/rollback.sh` - All scripts have valid syntax
2. `test -x scripts/health-check.sh && test -x scripts/deploy.sh && test -x scripts/rollback.sh` - All scripts are executable
3. `grep "health-check.sh" scripts/deploy.sh` - Deploy calls health-check
4. `grep "compose.production.yaml" scripts/deploy.sh` - Deploy uses production compose
5. `grep "read -p" scripts/rollback.sh` - Rollback has confirmation prompts
</verification>

<success_criteria>
- health-check.sh validates disk, Docker, secrets, config, and ports
- deploy.sh runs pre-flight, pulls images, builds, migrates, deploys, waits for health
- rollback.sh has confirmation prompts at critical steps
- rollback.sh exports post-cutover data before stopping services
- rollback.sh provides clear DNS change instructions
- All scripts are executable and pass bash syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-deployment-cutover/07-04-SUMMARY.md`
</output>
