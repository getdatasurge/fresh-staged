---
phase: 11-self-hosted-deployment
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - scripts/deploy-selfhosted.sh
autonomous: true

must_haves:
  truths:
    - "DNS resolution verified before SSL certificate request"
    - "Deployment aborts with clear message if DNS not configured"
    - "Health check validates deployment with configurable timeout"
    - "Automatic rollback triggered on health check failure"
    - "Version tagging enables rollback to previous deployments"
  artifacts:
    - path: "scripts/deploy-selfhosted.sh"
      provides: "Complete deployment script with DNS check and auto-rollback"
      contains: "check_dns_resolution"
      contains: "rollback_deployment"
  key_links:
    - from: "scripts/deploy-selfhosted.sh"
      to: "docker compose"
      via: "deployment command"
      pattern: "docker compose.*up -d"
    - from: "scripts/deploy-selfhosted.sh"
      to: "health endpoint"
      via: "curl health check"
      pattern: "curl.*health"
---

<objective>
Add DNS pre-check, health check validation, version tagging, and automatic rollback to deploy-selfhosted.sh

Purpose: Prevent Let's Encrypt rate limit exhaustion by verifying DNS before deployment. Enable reliable rollback when deployments fail health checks. Track deployment versions for rollback capability.

Output:
- Enhanced scripts/deploy-selfhosted.sh with:
  - DNS resolution check before Caddy starts
  - Version tagging for each deployment
  - Health check validation with configurable timeout
  - Automatic rollback on health check failure
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-self-hosted-deployment/11-CONTEXT.md
@.planning/phases/11-self-hosted-deployment/11-RESEARCH.md
@.planning/phases/11-self-hosted-deployment/11-01-SUMMARY.md

# Script to enhance
@scripts/deploy-selfhosted.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DNS pre-check function</name>
  <files>scripts/deploy-selfhosted.sh</files>
  <action>
Add DNS resolution check function to deploy-selfhosted.sh.

**Function implementation:**

```bash
# Check DNS resolution before requesting SSL certificates
# Prevents Let's Encrypt rate limit exhaustion (5 failures/hour limit)
check_dns_resolution() {
    local domain=$1
    local max_retries=5
    local retry_delay=10

    step "Checking DNS resolution for ${domain}..."

    # Get server's public IP
    local server_ip
    server_ip=$(curl -s --max-time 10 ifconfig.me || curl -s --max-time 10 icanhazip.com)

    if [ -z "$server_ip" ]; then
        error "Could not determine server public IP"
        return 1
    fi

    echo "Server public IP: ${server_ip}"

    # Check DNS resolution with retries
    local attempt=1
    while [ $attempt -le $max_retries ]; do
        local resolved_ip
        resolved_ip=$(dig +short "$domain" | tail -1)

        if [ "$resolved_ip" = "$server_ip" ]; then
            success "DNS resolved correctly: ${domain} -> ${server_ip}"
            return 0
        fi

        if [ $attempt -lt $max_retries ]; then
            warning "DNS not ready (attempt ${attempt}/${max_retries}): ${domain} -> ${resolved_ip:-<no result>}"
            echo "Expected: ${server_ip}"
            echo "Retrying in ${retry_delay} seconds..."
            sleep $retry_delay
        fi

        attempt=$((attempt + 1))
    done

    error "DNS resolution failed for ${domain}"
    echo ""
    echo "Please update your DNS records:"
    echo "  Record Type: A"
    echo "  Name: ${domain}"
    echo "  Value: ${server_ip}"
    echo ""
    echo "Wait for DNS propagation (typically 5-60 minutes) before retrying."
    echo "Check propagation: dig ${domain}"
    echo ""
    echo "This check prevents Let's Encrypt rate limit exhaustion."
    echo "Let's Encrypt limits: 5 failed authorizations per account per hour."
    return 1
}
```

**Integration point:**
Add to deployment flow BEFORE starting Caddy:

```bash
deploy_services() {
    step "Checking DNS resolution..."
    if ! check_dns_resolution "$DOMAIN"; then
        error "ABORT: DNS not configured correctly"
        echo "Fix DNS and rerun deployment script."
        exit 1
    fi

    # Now safe to start services including Caddy
    step "Starting services..."
    # ... rest of deployment
}
```

Ensure `dig` is available:
```bash
ensure_dig() {
    if ! command -v dig &> /dev/null; then
        apt-get install -y dnsutils
    fi
}
```
  </action>
  <verify>
Function exists: grep -q "check_dns_resolution" scripts/deploy-selfhosted.sh
Uses dig command: grep -q "dig +short" scripts/deploy-selfhosted.sh
Has retry logic: grep -q "max_retries" scripts/deploy-selfhosted.sh
Includes rate limit warning: grep -q "rate limit" scripts/deploy-selfhosted.sh
  </verify>
  <done>DNS pre-check function verifies domain resolution before SSL certificate request</done>
</task>

<task type="auto">
  <name>Task 2: Add version tagging and deployment tracking</name>
  <files>scripts/deploy-selfhosted.sh</files>
  <action>
Add version tagging to track deployments and enable rollback.

**Version tracking functions:**

```bash
# Tag deployment for version tracking
tag_deployment() {
    local version
    version=$(git describe --tags --always 2>/dev/null || echo "unknown")
    local timestamp
    timestamp=$(date +%Y%m%d-%H%M%S)
    local tag="${version}-${timestamp}"

    echo "Tagging deployment: ${tag}"

    # Save current version
    echo "$tag" > /opt/freshtrack-pro/.deployment-version

    # Save version history (most recent first)
    local history_file="/opt/freshtrack-pro/.deployment-history"
    if [ -f "$history_file" ]; then
        # Prepend new version
        echo "$tag" | cat - "$history_file" > temp && mv temp "$history_file"
    else
        echo "$tag" > "$history_file"
    fi

    # Prune old versions beyond retention limit
    local retention="${VERSION_RETENTION:-3}"
    if [ -f "$history_file" ]; then
        head -n "$retention" "$history_file" > temp && mv temp "$history_file"
    fi

    # Tag Docker images for rollback
    local images=("freshtrack-backend" "freshtrack-frontend")
    for image in "${images[@]}"; do
        if docker images "$image:latest" --format "{{.ID}}" | grep -q .; then
            docker tag "$image:latest" "$image:$tag" 2>/dev/null || true
        fi
    done

    success "Deployment tagged: ${tag}"
}

# Get previous deployment version for rollback
get_previous_version() {
    local history_file="/opt/freshtrack-pro/.deployment-history"
    if [ -f "$history_file" ] && [ "$(wc -l < "$history_file")" -gt 1 ]; then
        # Return second line (previous version)
        sed -n '2p' "$history_file"
    else
        echo ""
    fi
}

# Prune old Docker images beyond retention
prune_old_images() {
    local retention="${VERSION_RETENTION:-3}"

    for image in freshtrack-backend freshtrack-frontend; do
        # Get all tags except latest, sorted by creation time
        docker images "$image" --format "{{.Tag}}" | \
            grep -v "^latest$" | \
            tail -n +$((retention + 1)) | \
            xargs -r -I {} docker rmi "$image:{}" 2>/dev/null || true
    done

    success "Pruned old images (keeping last ${retention} versions)"
}
```

**Integration:**
Call `tag_deployment` after successful deployment, before health checks.
  </action>
  <verify>
Function exists: grep -q "tag_deployment" scripts/deploy-selfhosted.sh
Tracks version history: grep -q "deployment-history" scripts/deploy-selfhosted.sh
Uses VERSION_RETENTION: grep -q "VERSION_RETENTION" scripts/deploy-selfhosted.sh
Tags Docker images: grep -q "docker tag" scripts/deploy-selfhosted.sh
  </verify>
  <done>Version tagging tracks each deployment with configurable retention for rollback</done>
</task>

<task type="auto">
  <name>Task 3: Add health check and automatic rollback</name>
  <files>scripts/deploy-selfhosted.sh</files>
  <action>
Add health check validation with automatic rollback on failure.

**Health check function:**

```bash
# Validate deployment health with timeout
validate_deployment_health() {
    local timeout="${HEALTH_CHECK_TIMEOUT:-30}"
    local max_retries="${HEALTH_CHECK_RETRIES:-30}"
    local health_url="http://localhost:3000/health"

    step "Validating deployment health..."
    echo "Timeout: ${timeout}s per attempt, ${max_retries} attempts max"
    echo "Total timeout: $((timeout * max_retries / 60)) minutes"

    local attempt=1
    while [ $attempt -le $max_retries ]; do
        if curl -sf --max-time 10 "$health_url" > /dev/null 2>&1; then
            success "Health check passed on attempt ${attempt}"

            # Verify response content
            local response
            response=$(curl -s --max-time 10 "$health_url")
            if echo "$response" | grep -q '"status":"healthy"'; then
                success "Backend reports healthy status"
                return 0
            else
                warning "Unexpected health response: ${response}"
            fi
        fi

        if [ $attempt -lt $max_retries ]; then
            echo "Health check attempt ${attempt}/${max_retries} failed, retrying in ${timeout}s..."
            sleep "$timeout"
        fi

        attempt=$((attempt + 1))
    done

    error "Health check failed after ${max_retries} attempts"
    return 1
}

# Automatic rollback on deployment failure
rollback_deployment() {
    local previous_version
    previous_version=$(get_previous_version)

    if [ -z "$previous_version" ]; then
        error "No previous version available for rollback"
        echo "This appears to be the first deployment."
        echo "Manual intervention required."
        return 1
    fi

    warning "Initiating automatic rollback to: ${previous_version}"

    # Stop current deployment
    step "Stopping failed deployment..."
    docker compose -f /opt/freshtrack-pro/docker-compose.yml \
                   -f /opt/freshtrack-pro/docker/compose.prod.yaml \
                   -f /opt/freshtrack-pro/docker/compose.selfhosted.yaml \
                   down --timeout 30

    # Restore previous version's images
    step "Restoring previous images..."
    for image in freshtrack-backend freshtrack-frontend; do
        if docker images "$image:$previous_version" --format "{{.ID}}" | grep -q .; then
            docker tag "$image:$previous_version" "$image:latest"
            success "Restored ${image}:${previous_version}"
        else
            warning "Previous image not found: ${image}:${previous_version}"
        fi
    done

    # Start services with restored images
    step "Starting restored services..."
    docker compose -f /opt/freshtrack-pro/docker-compose.yml \
                   -f /opt/freshtrack-pro/docker/compose.prod.yaml \
                   -f /opt/freshtrack-pro/docker/compose.selfhosted.yaml \
                   up -d

    # Verify rollback
    step "Verifying rollback..."
    sleep 10
    if curl -sf --max-time 10 "http://localhost:3000/health" > /dev/null 2>&1; then
        success "Rollback successful - previous version is healthy"

        # Update version tracking
        echo "$previous_version" > /opt/freshtrack-pro/.deployment-version
        return 0
    else
        error "Rollback also failed - manual intervention required"
        echo "Check logs: docker compose logs"
        return 1
    fi
}
```

**Main deployment flow with auto-rollback:**

```bash
deploy_services() {
    # DNS check first
    if ! check_dns_resolution "$DOMAIN"; then
        error "ABORT: DNS not configured correctly"
        exit 1
    fi

    # Tag this deployment attempt
    tag_deployment

    # Start services
    step "Starting services..."
    docker compose -f /opt/freshtrack-pro/docker-compose.yml \
                   -f /opt/freshtrack-pro/docker/compose.prod.yaml \
                   -f /opt/freshtrack-pro/docker/compose.selfhosted.yaml \
                   up -d

    # Validate health
    if ! validate_deployment_health; then
        warning "Deployment failed health checks"

        if ! rollback_deployment; then
            error "CRITICAL: Both deployment and rollback failed"
            echo "Manual intervention required."
            exit 1
        fi

        echo ""
        echo "Deployment rolled back to previous version."
        echo "Review logs and fix issues before retrying."
        exit 1
    fi

    # Cleanup old images
    prune_old_images

    success "Deployment complete and healthy!"
}
```
  </action>
  <verify>
Health check function exists: grep -q "validate_deployment_health" scripts/deploy-selfhosted.sh
Rollback function exists: grep -q "rollback_deployment" scripts/deploy-selfhosted.sh
Uses HEALTH_CHECK_TIMEOUT: grep -q "HEALTH_CHECK_TIMEOUT" scripts/deploy-selfhosted.sh
Automatic rollback integrated: grep -q "if ! validate_deployment_health" scripts/deploy-selfhosted.sh
Compose command correct: grep -q "compose.selfhosted.yaml" scripts/deploy-selfhosted.sh
  </verify>
  <done>Health check validates deployment with 30s timeout and automatic rollback on failure</done>
</task>

</tasks>

<verification>
- [ ] DNS pre-check runs before Caddy starts
- [ ] Deployment aborts with clear message if DNS not configured
- [ ] Version tagging creates deployment history
- [ ] Health check uses configurable timeout (default 30s)
- [ ] Automatic rollback triggers on health check failure
- [ ] Rollback restores previous Docker images
- [ ] Old images pruned based on VERSION_RETENTION setting
</verification>

<success_criteria>
- DNS check prevents Let's Encrypt rate limit exhaustion
- 30-second health check timeout with 30 retries (15 minute total window)
- Automatic rollback restores previous working version
- Version retention keeps last 3 deployments (configurable)
- Code-only rollback (database untouched per CONTEXT.md decision)
</success_criteria>

<output>
After completion, create `.planning/phases/11-self-hosted-deployment/11-03-SUMMARY.md`
</output>
