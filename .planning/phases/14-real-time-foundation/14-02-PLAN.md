---
phase: 14-real-time-foundation
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - backend/package.json
  - backend/src/plugins/socket.plugin.ts
  - backend/src/middleware/socket-auth.ts
  - backend/src/services/socket.service.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket connections require valid JWT to connect"
    - "Invalid tokens are rejected with clear error message"
    - "Connected clients are assigned to organization rooms"
    - "Redis adapter enables cross-instance message broadcast"
  artifacts:
    - path: "backend/src/middleware/socket-auth.ts"
      provides: "JWT authentication middleware for Socket.io"
      exports: ["setupSocketAuth"]
      min_lines: 30
    - path: "backend/src/services/socket.service.ts"
      provides: "Room management and broadcasting"
      exports: ["SocketService"]
      min_lines: 50
  key_links:
    - from: "backend/src/plugins/socket.plugin.ts"
      to: "socket-auth.ts"
      via: "io.use middleware"
      pattern: "io\\.use.*setupSocketAuth"
    - from: "backend/src/plugins/socket.plugin.ts"
      to: "@socket.io/redis-adapter"
      via: "io.adapter"
      pattern: "io\\.adapter.*createAdapter"
---

<objective>
Add JWT authentication for WebSocket connections and configure Redis adapter for horizontal scaling.

Purpose: Secure WebSocket connections using existing JWT infrastructure and enable multi-instance deployments.
Output: Authenticated WebSocket connections, organization-based room isolation, Redis pub/sub for scaling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/REALTIME.md

@.planning/phases/14-real-time-foundation/14-01-SUMMARY.md

@backend/src/plugins/socket.plugin.ts
@backend/src/utils/jwt.ts
@backend/src/middleware/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Redis adapter and create JWT auth middleware</name>
  <files>
    backend/package.json
    backend/src/middleware/socket-auth.ts
  </files>
  <action>
Install Redis adapter in backend:
```bash
cd backend && npm install @socket.io/redis-adapter redis
```

Create `backend/src/middleware/socket-auth.ts`:
- Import verifyJWT from '../utils/jwt.js'
- Export `setupSocketAuth(io: Server)` function
- Register io.use() middleware that:
  1. Extracts token from `socket.handshake.auth?.token`
  2. Returns error if no token: `next(new Error('Authentication token required'))`
  3. Verifies JWT using existing verifyJWT utility
  4. Attaches decoded data to socket.data: userId, organizationId, role, email
  5. Catches JWT errors and returns: `next(new Error('Invalid or expired token'))`

Example from research:
```typescript
io.use(async (socket, next) => {
  const token = socket.handshake.auth?.token;
  if (!token) {
    return next(new Error('Authentication token required'));
  }
  try {
    const decoded = await verifyJWT(token);
    socket.data.userId = decoded.userId;
    socket.data.organizationId = decoded.organizationId;
    socket.data.role = decoded.role;
    socket.data.email = decoded.email;
    next();
  } catch (error) {
    next(new Error('Invalid or expired token'));
  }
});
```

Update middleware/index.ts to export socket-auth if it has a barrel export pattern.
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors for new middleware</verify>
  <done>@socket.io/redis-adapter and redis packages installed, socket-auth.ts exports setupSocketAuth function</done>
</task>

<task type="auto">
  <name>Task 2: Create SocketService with room management and Redis adapter</name>
  <files>backend/src/services/socket.service.ts</files>
  <action>
Create `backend/src/services/socket.service.ts`:

Class `SocketService`:
- Private `io: Server` property
- Private `pubClient` and `subClient` Redis clients
- Constructor takes Server instance
- `async initialize()` method:
  1. Create Redis clients from env (REDIS_URL or REDIS_HOST/REDIS_PORT)
  2. Connect both clients with error handling
  3. Configure Redis adapter: `io.adapter(createAdapter(pubClient, subClient))`
  4. Log "Redis adapter configured for Socket.io"
  5. Handle Redis connection errors with logging

Room management methods:
- `joinOrganization(socket: Socket)`: socket.join(`org:${socket.data.organizationId}`)
- `joinSite(socket: Socket, siteId: string)`: socket.join(`org:${orgId}:site:${siteId}`)
- `joinUnit(socket: Socket, unitId: string)`: socket.join(`org:${orgId}:unit:${unitId}`)
- `leaveRoom(socket: Socket, room: string)`: socket.leave(room)

Broadcast methods:
- `emitToOrg(orgId: string, event: string, data: any)`: io.to(`org:${orgId}`).emit(event, data)
- `emitToSite(orgId: string, siteId: string, event: string, data: any)`
- `emitToUnit(orgId: string, unitId: string, event: string, data: any)`

Export singleton pattern or factory function.

ENV vars to support:
- REDIS_URL (full connection string)
- REDIS_HOST (default: localhost)
- REDIS_PORT (default: 6379)

If Redis is not configured (no REDIS_URL/REDIS_HOST), log warning and skip adapter setup (allows local dev without Redis).
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>SocketService class with room management and Redis adapter support, singleton export</done>
</task>

<task type="auto">
  <name>Task 3: Integrate auth middleware and SocketService into plugin</name>
  <files>backend/src/plugins/socket.plugin.ts</files>
  <action>
Update `backend/src/plugins/socket.plugin.ts`:

1. Import setupSocketAuth from '../middleware/socket-auth.js'
2. Import SocketService from '../services/socket.service.js'

In app.ready() callback:
1. Call `setupSocketAuth(app.io)` to register auth middleware
2. Create SocketService instance with app.io
3. Call `await socketService.initialize()` (Redis adapter setup)
4. Store socketService on app (app.decorate or global for access)

Update connection handler:
1. Auto-join organization room on connect: `socketService.joinOrganization(socket)`
2. Add event handlers for client subscriptions:
   - `socket.on('subscribe:site', (siteId) => socketService.joinSite(socket, siteId))`
   - `socket.on('subscribe:unit', (unitId) => socketService.joinUnit(socket, unitId))`
   - `socket.on('unsubscribe:site', (siteId) => socket.leave(...))`
   - `socket.on('unsubscribe:unit', (unitId) => socket.leave(...))`
3. Log connection with userId and organizationId from socket.data

Update disconnect handler:
- socket.removeAllListeners() to prevent memory leaks
- Log with userId

Decorate Fastify with socketService for access from routes:
```typescript
fastify.decorate('socketService', socketService);
```

Add TypeScript declaration for the decorator in socket.d.ts.
  </action>
  <verify>
1. Start backend with REDIS_HOST not set: should start with warning about Redis
2. Start backend with REDIS_HOST=localhost (if Redis available): should connect
3. TypeScript compiles without errors
  </verify>
  <done>Socket.io plugin integrates JWT auth, Redis adapter, room management. Auth middleware rejects connections without valid JWT.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compiles: `npx tsc --noEmit`
2. Backend starts with warning about Redis (if not configured)
3. If Redis available, adapter connects without errors
4. Connection attempts without token are rejected (test in next plan with client)
</verification>

<success_criteria>
- JWT authentication required for WebSocket connections
- Invalid tokens rejected with clear error message
- Redis adapter configured for horizontal scaling
- Room-based multi-tenancy implemented
- Socket service accessible from Fastify routes for broadcasting
</success_criteria>

<output>
After completion, create `.planning/phases/14-real-time-foundation/14-02-SUMMARY.md`
</output>
