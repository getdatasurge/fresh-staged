---
phase: 14-real-time-foundation
plan: 04
type: execute
wave: 3
depends_on: ['14-02']
files_modified:
  - package.json
  - src/lib/socket.ts
  - src/hooks/useRealtimeConnection.ts
  - src/hooks/useRealtimeSensorData.ts
  - src/providers/RealtimeProvider.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - 'Socket.io client connects with JWT token from auth context'
    - 'Connection status displayed in UI (connected/disconnected)'
    - 'Sensor readings update TanStack Query cache without refetch'
    - 'Automatic reconnection on network interruption'
  artifacts:
    - path: 'src/lib/socket.ts'
      provides: 'Socket.io client singleton'
      exports: ['socket', 'connectSocket', 'disconnectSocket']
      min_lines: 40
    - path: 'src/hooks/useRealtimeSensorData.ts'
      provides: 'Hook for real-time sensor updates'
      exports: ['useRealtimeSensorData']
      min_lines: 50
    - path: 'src/providers/RealtimeProvider.tsx'
      provides: 'Context for real-time connection state'
      exports: ['RealtimeProvider', 'useRealtimeStatus']
      min_lines: 60
  key_links:
    - from: 'src/providers/RealtimeProvider.tsx'
      to: 'src/lib/socket.ts'
      via: 'connectSocket with token'
      pattern: "connectSocket\\(.*token"
    - from: 'src/hooks/useRealtimeSensorData.ts'
      to: 'queryClient.setQueryData'
      via: 'TanStack Query cache update'
      pattern: 'setQueryData.*sensor'
---

<objective>
Create React Socket.io client with TanStack Query integration for real-time sensor data updates.

Purpose: Enable dashboard to receive live sensor readings without polling.
Output: Socket.io client library, real-time hooks, connection status provider, TanStack Query cache updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/REALTIME.md

@.planning/phases/14-real-time-foundation/14-02-SUMMARY.md

@src/App.tsx
@src/lib/queryKeys.ts
@src/hooks/useUnitStatus.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install socket.io-client and create client library</name>
  <files>
    package.json
    src/lib/socket.ts
  </files>
  <action>
Install socket.io-client in frontend (root package.json):
```bash
npm install socket.io-client
```

Create `src/lib/socket.ts`:

```typescript
import { io, Socket } from 'socket.io-client';

// Type-safe socket with event interfaces
interface ServerToClientEvents {
  'sensor:reading': (data: SensorReading) => void;
  'sensor:readings:batch': (data: {
    unitId: string;
    readings: SensorReading[];
    count: number;
  }) => void;
  'alert:triggered': (data: AlertNotification) => void;
  'alert:resolved': (data: { alertId: string; unitId: string }) => void;
}

interface ClientToServerEvents {
  'subscribe:site': (siteId: string) => void;
  'unsubscribe:site': (siteId: string) => void;
  'subscribe:unit': (unitId: string) => void;
  'unsubscribe:unit': (unitId: string) => void;
  'get:latest': (unitId: string, callback: (reading: SensorReading | null) => void) => void;
}

// Export typed socket
export const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io(
  import.meta.env.VITE_API_URL || 'http://localhost:3000',
  {
    autoConnect: false, // Connect manually after auth
    reconnection: true,
    reconnectionAttempts: Infinity,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    timeout: 20000,
  },
);

export function connectSocket(token: string) {
  socket.auth = { token };
  socket.connect();
}

export function disconnectSocket() {
  socket.disconnect();
}

// Sensor reading type (match backend)
export interface SensorReading {
  id: string;
  unitId: string;
  deviceId: string | null;
  temperature: number;
  humidity: number | null;
  battery: number | null;
  signalStrength: number | null;
  recordedAt: string;
  source: string;
}

export interface AlertNotification {
  alertId: string;
  unitId: string;
  alertType: string;
  severity: string;
  message: string;
  triggeredAt: string;
}
```

Do NOT use query string for token (security risk per research).
</action>
<verify>Run `npm run build` - no type errors, socket.io-client bundled</verify>
<done>socket.io-client installed, typed socket instance exported with connect/disconnect helpers</done>
</task>

<task type="auto">
  <name>Task 2: Create RealtimeProvider and connection status hook</name>
  <files>
    src/providers/RealtimeProvider.tsx
    src/App.tsx
  </files>
  <action>
Create `src/providers/RealtimeProvider.tsx`:

```typescript
import { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import { socket, connectSocket, disconnectSocket } from '@/lib/socket';
import { useUser } from '@stackframe/react'; // Or wherever auth hook is

interface RealtimeContextValue {
  isConnected: boolean;
  isConnecting: boolean;
  connectionError: string | null;
}

const RealtimeContext = createContext<RealtimeContextValue>({
  isConnected: false,
  isConnecting: false,
  connectionError: null,
});

export function useRealtimeStatus() {
  return useContext(RealtimeContext);
}

export function RealtimeProvider({ children }: { children: ReactNode }) {
  const user = useUser(); // Get auth context
  const [isConnected, setIsConnected] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [connectionError, setConnectionError] = useState<string | null>(null);

  useEffect(() => {
    // Only connect if user is authenticated
    if (!user) {
      disconnectSocket();
      return;
    }

    // Get access token from auth
    const token = /* get JWT from Stack or auth context */;
    if (!token) return;

    setIsConnecting(true);
    setConnectionError(null);
    connectSocket(token);

    // Connection handlers - register OUTSIDE of connect event to avoid duplicates
    function onConnect() {
      setIsConnected(true);
      setIsConnecting(false);
      console.log('Socket.io connected');
    }

    function onDisconnect(reason: string) {
      setIsConnected(false);
      console.log('Socket.io disconnected:', reason);
    }

    function onConnectError(error: Error) {
      setIsConnecting(false);
      setConnectionError(error.message);
      console.error('Socket.io connection error:', error.message);
    }

    socket.on('connect', onConnect);
    socket.on('disconnect', onDisconnect);
    socket.on('connect_error', onConnectError);

    // Check if already connected (reconnect scenario)
    if (socket.connected) {
      setIsConnected(true);
      setIsConnecting(false);
    }

    return () => {
      socket.off('connect', onConnect);
      socket.off('disconnect', onDisconnect);
      socket.off('connect_error', onConnectError);
      disconnectSocket();
    };
  }, [user]);

  return (
    <RealtimeContext.Provider value={{ isConnected, isConnecting, connectionError }}>
      {children}
    </RealtimeContext.Provider>
  );
}
```

Update `src/App.tsx`:

- Import RealtimeProvider
- Wrap the app (inside QueryClientProvider, outside Router)
- Place after auth provider so user context is available

Note: Adjust token retrieval based on actual Stack Auth implementation. May need to use `useStackApp().getToken()` or similar.
</action>
<verify>Run `npm run dev` - no errors, app renders, check console for Socket.io logs when authenticated</verify>
<done>RealtimeProvider manages socket lifecycle, useRealtimeStatus hook exposes connection state</done>
</task>

<task type="auto">
  <name>Task 3: Create useRealtimeSensorData hook with TanStack Query integration</name>
  <files>
    src/hooks/useRealtimeSensorData.ts
    src/hooks/useRealtimeConnection.ts
  </files>
  <action>
Create `src/hooks/useRealtimeConnection.ts`:
Simple hook to manage room subscriptions:

```typescript
import { useEffect } from 'react';
import { socket } from '@/lib/socket';
import { useRealtimeStatus } from '@/providers/RealtimeProvider';

export function useRealtimeSubscription(type: 'site' | 'unit', id: string | undefined) {
  const { isConnected } = useRealtimeStatus();

  useEffect(() => {
    if (!isConnected || !id) return;

    // Subscribe to room
    socket.emit(type === 'site' ? 'subscribe:site' : 'subscribe:unit', id);

    return () => {
      // Unsubscribe on cleanup
      socket.emit(type === 'site' ? 'unsubscribe:site' : 'unsubscribe:unit', id);
    };
  }, [isConnected, type, id]);
}
```

Create `src/hooks/useRealtimeSensorData.ts`:

```typescript
import { useEffect } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { socket, SensorReading } from '@/lib/socket';
import { useRealtimeStatus } from '@/providers/RealtimeProvider';
import { queryKeys } from '@/lib/queryKeys';

interface BatchData {
  unitId: string;
  readings: SensorReading[];
  count: number;
}

export function useRealtimeSensorData(organizationId: string | undefined) {
  const { isConnected } = useRealtimeStatus();
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!isConnected || !organizationId) return;

    function handleReadingsBatch(data: BatchData) {
      // Update latest reading for unit in cache
      queryClient.setQueryData(
        ['unit-latest-reading', data.unitId],
        data.readings[data.readings.length - 1],
      );

      // Update unit status cache if exists
      queryClient.setQueryData(queryKeys.unitStatus(data.unitId), (old: any) => {
        if (!old) return old;
        const latest = data.readings[data.readings.length - 1];
        return {
          ...old,
          lastTemperature: latest.temperature,
          lastReadingAt: latest.recordedAt,
        };
      });

      // Append to readings history if that query exists
      queryClient.setQueryData(
        ['sensor-readings', data.unitId],
        (old: SensorReading[] | undefined) => {
          if (!old) return data.readings;
          // Append new readings, keep last 100
          return [...old, ...data.readings].slice(-100);
        },
      );
    }

    socket.on('sensor:readings:batch', handleReadingsBatch);

    return () => {
      socket.off('sensor:readings:batch', handleReadingsBatch);
    };
  }, [isConnected, organizationId, queryClient]);
}
```

This hook should be called once at a high level (dashboard layout) to receive all sensor updates for the organization. The server broadcasts to org room, so all units within that org update automatically.

Adjust queryKeys to match existing patterns in src/lib/queryKeys.ts.
</action>
<verify>Run `npm run build` - no type errors, hooks compile</verify>
<done>useRealtimeSensorData updates TanStack Query cache when sensor batches arrive, useRealtimeSubscription manages room subscriptions</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Frontend builds without errors: `npm run build`
2. Socket.io client connects when user is authenticated
3. Connection status available via useRealtimeStatus
4. Room subscription works via useRealtimeSubscription
5. TanStack Query cache updates on sensor:readings:batch events
</verification>

<success_criteria>

- Socket.io client connects with JWT from auth context
- Automatic reconnection configured
- Connection status exposed via React context
- Sensor readings update TanStack Query cache in real-time
- No duplicate event handlers on reconnection
- Clean disconnect on logout
  </success_criteria>

<output>
After completion, create `.planning/phases/14-real-time-foundation/14-04-SUMMARY.md`
</output>
