---
phase: 14-real-time-foundation
plan: 05
type: execute
wave: 4
depends_on: ['14-03', '14-04']
files_modified:
  - backend/src/services/alert-evaluator.service.ts
  - backend/src/types/socket.d.ts
  - src/hooks/useRealtimeAlerts.ts
  - src/components/common/AlertToast.tsx
  - src/providers/RealtimeProvider.tsx
autonomous: true

must_haves:
  truths:
    - 'Alert notifications delivered to connected clients in real-time'
    - 'Toast notification appears when alert is triggered'
    - 'Alert resolution events update UI immediately'
    - 'Only organization members receive alert notifications'
  artifacts:
    - path: 'src/hooks/useRealtimeAlerts.ts'
      provides: 'Hook for real-time alert notifications'
      exports: ['useRealtimeAlerts']
      min_lines: 40
    - path: 'src/components/common/AlertToast.tsx'
      provides: 'Toast component for alert notifications'
      exports: ['AlertToast']
      min_lines: 20
  key_links:
    - from: 'backend/src/services/alert-evaluator.service.ts'
      to: 'socket.service.ts'
      via: 'emitToOrg on alert creation'
      pattern: 'emitToOrg.*alert:triggered'
    - from: 'src/hooks/useRealtimeAlerts.ts'
      to: 'sonner toast'
      via: 'toast.error on alert event'
      pattern: "toast\\..*alert"
---

<objective>
Implement real-time alert notification delivery from backend to connected clients.

Purpose: Enable instant alert awareness without page refresh or polling.
Output: Backend alert emission on state change, frontend toast notifications, TanStack Query cache updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/REALTIME.md

@.planning/phases/14-real-time-foundation/14-03-SUMMARY.md
@.planning/phases/14-real-time-foundation/14-04-SUMMARY.md

@backend/src/services/alert-evaluator.service.ts
@backend/src/plugins/socket.plugin.ts
@src/hooks/useRealtimeSensorData.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update backend to emit alerts via Socket.io</name>
  <files>
    backend/src/services/alert-evaluator.service.ts
    backend/src/types/socket.d.ts
  </files>
  <action>
Update `backend/src/types/socket.d.ts` with alert event types:

```typescript
interface ServerToClientEvents {
  // ... existing sensor events
  'alert:triggered': (data: AlertNotification) => void;
  'alert:resolved': (data: { alertId: string; unitId: string; resolvedAt: string }) => void;
  'alert:escalated': (data: { alertId: string; unitId: string; escalationLevel: number }) => void;
}

interface AlertNotification {
  alertId: string;
  unitId: string;
  alertType: string;
  severity: 'warning' | 'critical';
  message: string;
  triggerTemperature: number;
  thresholdViolated: 'min' | 'max';
  triggeredAt: string;
}
```

Update `backend/src/services/alert-evaluator.service.ts`:

1. Add import for socketService (will need to access via fastify instance or inject)
2. After `createAlertIfNotExists` creates an alert, emit to org room:
   ```typescript
   if (result.alertCreated) {
     socketService.emitToOrg(organizationId, 'alert:triggered', {
       alertId: result.alertCreated.id,
       unitId: result.alertCreated.unitId,
       alertType: result.alertCreated.alertType,
       severity: result.alertCreated.severity,
       message: result.alertCreated.message,
       triggerTemperature: result.alertCreated.triggerTemperature,
       thresholdViolated: result.alertCreated.thresholdViolated,
       triggeredAt: result.alertCreated.triggeredAt.toISOString(),
     });
   }
   ```
3. After alert resolution, emit:
   ```typescript
   if (result.alertResolved) {
     socketService.emitToOrg(organizationId, 'alert:resolved', {
       alertId: result.alertResolved.id,
       unitId: result.alertResolved.unitId,
       resolvedAt: result.alertResolved.resolvedAt?.toISOString(),
     });
   }
   ```
4. On escalation (STATE TRANSITION 2), emit:
   ```typescript
   socketService.emitToOrg(organizationId, 'alert:escalated', {...});
   ```

Challenge: alert-evaluator.service.ts is called from readings route. Need to pass socketService through or access via global. Options:

- A) Pass socketService to evaluateUnitAfterReading function
- B) Create a global reference set during app startup
- C) Use Fastify's dependency injection pattern

Recommend option A: Update function signature to accept optional socketService parameter. When called from route, pass it in.
</action>
<verify>Run `npx tsc --noEmit` - no type errors</verify>
<done>Alert evaluator emits Socket.io events when alerts are created, resolved, or escalated</done>
</task>

<task type="auto">
  <name>Task 2: Create frontend alert notification hook and toast</name>
  <files>
    src/hooks/useRealtimeAlerts.ts
    src/components/common/AlertToast.tsx
  </files>
  <action>
Create `src/components/common/AlertToast.tsx`:

```typescript
import { AlertTriangle, CheckCircle } from 'lucide-react';

interface AlertToastProps {
  type: 'triggered' | 'resolved';
  message: string;
  severity?: 'warning' | 'critical';
  unitId?: string;
}

export function AlertToast({ type, message, severity, unitId }: AlertToastProps) {
  const isTriggered = type === 'triggered';
  const Icon = isTriggered ? AlertTriangle : CheckCircle;
  const iconColor = isTriggered
    ? severity === 'critical' ? 'text-red-500' : 'text-yellow-500'
    : 'text-green-500';

  return (
    <div className="flex items-start gap-3">
      <Icon className={`w-5 h-5 ${iconColor} flex-shrink-0 mt-0.5`} />
      <div>
        <p className="font-medium">
          {isTriggered ? 'Alert Triggered' : 'Alert Resolved'}
        </p>
        <p className="text-sm text-muted-foreground">{message}</p>
      </div>
    </div>
  );
}
```

Create `src/hooks/useRealtimeAlerts.ts`:

```typescript
import { useEffect } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { toast } from 'sonner';
import { socket, AlertNotification } from '@/lib/socket';
import { useRealtimeStatus } from '@/providers/RealtimeProvider';
import { AlertToast } from '@/components/common/AlertToast';
import { queryKeys } from '@/lib/queryKeys';

export function useRealtimeAlerts(organizationId: string | undefined) {
  const { isConnected } = useRealtimeStatus();
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!isConnected || !organizationId) return;

    function handleAlertTriggered(data: AlertNotification) {
      // Show toast notification
      toast.custom(
        () => (
          <AlertToast
            type="triggered"
            message={data.message}
            severity={data.severity}
          />
        ),
        {
          duration: data.severity === 'critical' ? 10000 : 5000,
          id: `alert-${data.alertId}`,
        }
      );

      // Invalidate alerts query to refetch
      queryClient.invalidateQueries({ queryKey: queryKeys.alerts(organizationId) });

      // Update unit status
      queryClient.setQueryData(
        queryKeys.unitStatus(data.unitId),
        (old: any) => old ? { ...old, status: 'excursion' } : old
      );
    }

    function handleAlertResolved(data: { alertId: string; unitId: string; resolvedAt: string }) {
      toast.custom(
        () => (
          <AlertToast
            type="resolved"
            message="Temperature returned to acceptable range"
          />
        ),
        { duration: 5000 }
      );

      // Invalidate alerts query
      queryClient.invalidateQueries({ queryKey: queryKeys.alerts(organizationId) });

      // Update unit status
      queryClient.setQueryData(
        queryKeys.unitStatus(data.unitId),
        (old: any) => old ? { ...old, status: 'restoring' } : old
      );
    }

    function handleAlertEscalated(data: { alertId: string; unitId: string; escalationLevel: number }) {
      toast.error(`Alert escalated to level ${data.escalationLevel}`, {
        duration: 10000,
      });

      // Update unit status to alarm_active
      queryClient.setQueryData(
        queryKeys.unitStatus(data.unitId),
        (old: any) => old ? { ...old, status: 'alarm_active' } : old
      );
    }

    socket.on('alert:triggered', handleAlertTriggered);
    socket.on('alert:resolved', handleAlertResolved);
    socket.on('alert:escalated', handleAlertEscalated);

    return () => {
      socket.off('alert:triggered', handleAlertTriggered);
      socket.off('alert:resolved', handleAlertResolved);
      socket.off('alert:escalated', handleAlertEscalated);
    };
  }, [isConnected, organizationId, queryClient]);
}
```

Adjust queryKeys.alerts() and queryKeys.unitStatus() to match existing patterns.
</action>
<verify>Run `npm run build` - no type errors</verify>
<done>useRealtimeAlerts hook shows toast on alert events and updates TanStack Query cache</done>
</task>

<task type="auto">
  <name>Task 3: Wire up alert hook in RealtimeProvider or dashboard layout</name>
  <files>
    src/providers/RealtimeProvider.tsx
  </files>
  <action>
Update `src/providers/RealtimeProvider.tsx` to include alert handling:

Option A: Add to RealtimeProvider directly (simplest)

```typescript
// Inside RealtimeProvider component
const organizationId = user?.organizationId; // Get from auth context
useRealtimeSensorData(organizationId);
useRealtimeAlerts(organizationId);
```

Option B: Create a separate component that uses the hooks (cleaner separation)

```typescript
function RealtimeHandlers() {
  const { organizationId } = useOrgScope(); // Use existing hook
  useRealtimeSensorData(organizationId);
  useRealtimeAlerts(organizationId);
  return null;
}

// In RealtimeProvider's children, conditionally render:
{isConnected && <RealtimeHandlers />}
```

Choose option based on how organizationId is accessed. If it's available in RealtimeProvider context, use Option A. If it requires hooks that need to be inside the org-scoped routing, use Option B and place RealtimeHandlers in the appropriate layout component.

The key is: these hooks should run once when connected, and listen for all events for the user's organization.
</action>
<verify>

1. Run frontend with backend
2. Trigger an alert (POST reading that exceeds threshold)
3. Toast notification should appear
4. Alert list should update
   </verify>
   <done>Alert notifications wired to show toasts and update UI when alerts are triggered/resolved</done>
   </task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compiles on both frontend and backend
2. Backend emits alert events when alert state changes
3. Frontend shows toast notification on alert:triggered
4. Frontend shows resolution toast on alert:resolved
5. TanStack Query cache updates for alerts and unit status
6. Only organization members receive notifications (room isolation)
</verification>

<success_criteria>

- Alert creation triggers real-time notification to connected clients
- Toast notifications appear with appropriate severity styling
- Alert resolution events show confirmation toast
- Unit status updates in cache without full refetch
- No cross-organization data leakage
  </success_criteria>

<output>
After completion, create `.planning/phases/14-real-time-foundation/14-05-SUMMARY.md`
</output>
