---
phase: 14-real-time-foundation
plan: 03
type: execute
wave: 3
depends_on: ["14-02"]
files_modified:
  - backend/src/services/sensor-stream.service.ts
  - backend/src/services/readings.service.ts
  - backend/src/routes/readings.ts
  - backend/src/types/socket.d.ts
autonomous: true

must_haves:
  truths:
    - "Sensor readings are buffered server-side before broadcast"
    - "Batched readings emitted every 1 second to prevent UI thrashing"
    - "Readings broadcast to correct organization room only"
    - "Latest reading cached per unit for new client connections"
  artifacts:
    - path: "backend/src/services/sensor-stream.service.ts"
      provides: "Sensor data buffering and streaming"
      exports: ["SensorStreamService"]
      min_lines: 80
  key_links:
    - from: "backend/src/routes/readings.ts"
      to: "sensor-stream.service.ts"
      via: "sensorStreamService.addReading"
      pattern: "addReading"
    - from: "backend/src/services/sensor-stream.service.ts"
      to: "socket.service.ts"
      via: "emitToOrg"
      pattern: "emitToOrg.*sensor:reading"
---

<objective>
Implement server-side sensor data buffering and real-time streaming to connected clients.

Purpose: Push live sensor readings to dashboard clients with throttling to prevent UI performance issues.
Output: Buffered sensor streaming service that batches readings and broadcasts to organization rooms.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/REALTIME.md

@.planning/phases/14-real-time-foundation/14-02-SUMMARY.md

@backend/src/services/readings.service.ts
@backend/src/routes/readings.ts
@backend/src/services/socket.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SensorStreamService with buffering</name>
  <files>backend/src/services/sensor-stream.service.ts</files>
  <action>
Create `backend/src/services/sensor-stream.service.ts`:

Class `SensorStreamService`:
- Private buffer: `Map<string, SensorReading[]>` keyed by `${organizationId}:${unitId}`
- Private latestByUnit: `Map<string, SensorReading>` for caching latest reading per unit
- Private flushInterval: number (default 1000ms)
- Private socketService: SocketService reference
- Private intervalId: NodeJS.Timer

Constructor:
- Takes SocketService instance
- Starts flush interval: `setInterval(() => this.flush(), this.flushInterval)`

Methods:
- `addReading(organizationId: string, reading: SensorReading)`:
  1. Add to buffer under `${organizationId}:${reading.unitId}` key
  2. Update latestByUnit cache
  3. If first reading for this key, initialize array

- `flush()`:
  1. For each key in buffer:
     - If readings array empty, skip
     - Parse organizationId and unitId from key
     - Emit batched readings: `socketService.emitToOrg(orgId, 'sensor:readings:batch', { unitId, readings, count })`
     - Also emit to unit-specific room for subscribers
     - Clear buffer for this key
  2. Log flush stats (total readings flushed, unique units)

- `getLatestReading(unitId: string): SensorReading | undefined`:
  Return cached latest reading for a unit (for new client connections)

- `stop()`:
  Clear interval, useful for graceful shutdown

Define SensorReading interface in socket.d.ts if not already defined:
```typescript
interface SensorReading {
  id: string;
  unitId: string;
  deviceId: string | null;
  temperature: number;
  humidity: number | null;
  battery: number | null;
  signalStrength: number | null;
  recordedAt: Date;
  source: string;
}
```

Export singleton or factory that gets initialized with SocketService.
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>SensorStreamService buffers readings and flushes every 1 second to organization rooms</done>
</task>

<task type="auto">
  <name>Task 2: Update socket types for sensor events</name>
  <files>backend/src/types/socket.d.ts</files>
  <action>
Update `backend/src/types/socket.d.ts` with sensor-related event types:

```typescript
interface ServerToClientEvents {
  'sensor:reading': (data: SensorReading) => void;
  'sensor:readings:batch': (data: {
    unitId: string;
    readings: SensorReading[];
    count: number;
  }) => void;
}

interface ClientToServerEvents {
  'subscribe:site': (siteId: string) => void;
  'unsubscribe:site': (siteId: string) => void;
  'subscribe:unit': (unitId: string) => void;
  'unsubscribe:unit': (unitId: string) => void;
  'get:latest': (unitId: string, callback: (reading: SensorReading | null) => void) => void;
}
```

Ensure Socket.io Server type is properly typed with these interfaces.

Add `get:latest` event handler to socket.plugin.ts that returns latest cached reading from SensorStreamService.
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Socket event types include sensor reading events and batch events</done>
</task>

<task type="auto">
  <name>Task 3: Integrate streaming into readings ingestion route</name>
  <files>
    backend/src/routes/readings.ts
    backend/src/plugins/socket.plugin.ts
  </files>
  <action>
Update `backend/src/routes/readings.ts`:

After successful bulk ingestion (ingestBulkReadings returns):
1. Get sensorStreamService from fastify.sensorStreamService
2. For each reading in the request:
   - Call `sensorStreamService.addReading(organizationId, reading)`
3. Return response as before (no change to API response)

The buffering service handles throttling - we just add readings immediately.

Update `backend/src/plugins/socket.plugin.ts`:
1. Create SensorStreamService instance after SocketService is initialized
2. Decorate Fastify with it: `fastify.decorate('sensorStreamService', sensorStreamService)`
3. Add TypeScript declaration for the decorator

Add handler for 'get:latest' event:
```typescript
socket.on('get:latest', (unitId, callback) => {
  const latest = sensorStreamService.getLatestReading(unitId);
  callback(latest || null);
});
```

Handle graceful shutdown:
- In preClose hook, call `sensorStreamService.stop()` to clear interval
  </action>
  <verify>
1. Start backend with `npm run dev`
2. TypeScript compiles without errors
3. Console shows flush logs (empty flushes initially)
4. POST readings to /api/readings/ingest - should add to buffer
  </verify>
  <done>Readings ingestion triggers real-time broadcast via SensorStreamService, batched at 1-second intervals</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compiles: `npx tsc --noEmit`
2. Backend starts without errors
3. Simulated readings POST triggers buffer additions
4. Flush logs show readings being batched
5. SocketService.emitToOrg is called with sensor:readings:batch events
</verification>

<success_criteria>
- Sensor readings buffered server-side (not immediately emitted)
- Batched emissions every 1 second to organization rooms
- Latest reading per unit cached for new client queries
- No memory leaks from buffer growth (cleared after flush)
- Graceful shutdown stops flush interval
</success_criteria>

<output>
After completion, create `.planning/phases/14-real-time-foundation/14-03-SUMMARY.md`
</output>
