---
phase: 02-authentication-rbac
plan: 05
type: execute
wave: 3
depends_on: ["02-02", "02-03", "02-04"]
files_modified:
  - backend/package.json
  - backend/vitest.config.ts
  - backend/src/app.ts
  - backend/tests/auth.test.ts
  - backend/tests/rbac.test.ts
  - backend/tests/helpers/jwt.ts
autonomous: true

user_setup:
  - service: stack-auth
    why: "JWT verification requires Stack Auth project ID"
    env_vars:
      - name: STACK_AUTH_PROJECT_ID
        source: "Stack Auth Dashboard -> Project Settings -> Project ID"
    dashboard_config:
      - task: "Create Stack Auth project (if not exists)"
        location: "https://app.stack-auth.com -> Create Project"
      - task: "Note the Project ID from settings"
        location: "Stack Auth Dashboard -> Project Settings"

must_haves:
  truths:
    - "Invalid JWT returns 401 Unauthorized"
    - "Valid JWT with insufficient role returns 403"
    - "Valid JWT with wrong org returns 403"
    - "Role hierarchy is enforced (admin can do staff actions)"
    - "Fastify app can start with all plugins registered"
  artifacts:
    - path: "backend/vitest.config.ts"
      provides: "Test runner configuration"
      contains: "vitest"
    - path: "backend/src/app.ts"
      provides: "Fastify app factory for testing"
      exports: ["buildApp"]
    - path: "backend/tests/auth.test.ts"
      provides: "Authentication middleware tests"
      contains: "401"
    - path: "backend/tests/rbac.test.ts"
      provides: "RBAC middleware tests"
      contains: "403"
    - path: "backend/tests/helpers/jwt.ts"
      provides: "Test JWT generation helper"
      exports: ["createTestToken", "TEST_USER"]
  key_links:
    - from: "backend/tests/auth.test.ts"
      to: "backend/src/app.ts"
      via: "buildApp import for inject testing"
      pattern: "buildApp|inject"
    - from: "backend/src/app.ts"
      to: "backend/src/plugins/auth.plugin.ts"
      via: "plugin registration"
      pattern: "register.*auth"
---

<objective>
Create test infrastructure and integration tests for authentication and RBAC flows.

Purpose: Verify the auth system works correctly with tests for token validation, role hierarchy, and tenant isolation. Also create the Fastify app factory needed for testing.

Output: Vitest configuration, Fastify app factory, test JWT helpers, and comprehensive auth/RBAC tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-rbac/02-RESEARCH.md

# Implementation context
@backend/src/middleware/auth.ts
@backend/src/middleware/rbac.ts
@backend/src/middleware/org-context.ts
@backend/src/plugins/auth.plugin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up Vitest and create Fastify app factory</name>
  <files>backend/package.json, backend/vitest.config.ts, backend/src/app.ts</files>
  <action>
1. Install test dependencies:
   ```bash
   cd backend && pnpm add -D vitest
   ```

2. Create `backend/vitest.config.ts`:
   ```typescript
   import { defineConfig } from 'vitest/config';

   export default defineConfig({
     test: {
       globals: true,
       environment: 'node',
       include: ['tests/**/*.test.ts'],
       setupFiles: [],
       testTimeout: 10000,
     },
   });
   ```

3. Add test script to package.json:
   - Add to scripts: `"test": "vitest run"`
   - Add to scripts: `"test:watch": "vitest"`

4. Create `backend/src/app.ts` - Fastify app factory:
   ```typescript
   import Fastify, { FastifyInstance } from 'fastify';
   import authPlugin from './plugins/auth.plugin.js';
   import { requireAuth, requireOrgContext, requireRole } from './middleware/index.js';
   import type { AppRole } from './types/auth.js';

   export interface AppOptions {
     logger?: boolean;
   }

   export function buildApp(opts: AppOptions = {}): FastifyInstance {
     const app = Fastify({
       logger: opts.logger ?? false,
     });

     // Register auth plugin (decorates request.user)
     app.register(authPlugin);

     // Example protected route for testing
     app.get('/api/protected', {
       preHandler: [requireAuth],
     }, async (request) => {
       return { userId: request.user!.id, email: request.user!.email };
     });

     // Example org-scoped route for testing
     app.get<{ Params: { organizationId: string } }>(
       '/api/orgs/:organizationId/test',
       {
         preHandler: [requireAuth, requireOrgContext],
       },
       async (request) => {
         return {
           userId: request.user!.id,
           organizationId: request.user!.organizationId,
           role: request.user!.role,
         };
       }
     );

     // Example admin-only route for testing
     app.delete<{ Params: { organizationId: string; userId: string } }>(
       '/api/orgs/:organizationId/users/:userId',
       {
         preHandler: [requireAuth, requireOrgContext, requireRole('admin')],
       },
       async (request) => {
         return { deleted: true };
       }
     );

     return app;
   }

   export default buildApp;
   ```

Note: These routes are for testing only. Real routes will be added in Phase 3.
  </action>
  <verify>
Run `pnpm tsc --noEmit` - no TypeScript errors.
vitest.config.ts exists with correct configuration.
package.json has test scripts.
app.ts exports buildApp function.
  </verify>
  <done>
Vitest configured for testing.
Fastify app factory created with test routes.
Test scripts added to package.json.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create JWT test helpers</name>
  <files>backend/tests/helpers/jwt.ts</files>
  <action>
Create `backend/tests/` and `backend/tests/helpers/` directories.

Create `backend/tests/helpers/jwt.ts`:

1. Import jose for signing test tokens:
   ```typescript
   import * as jose from 'jose';
   ```

2. Create a test signing key (for testing only - NOT production):
   ```typescript
   // Test key pair - DO NOT use in production
   const testPrivateKey = await jose.generateKeyPair('RS256');
   export const testPublicKey = testPrivateKey.publicKey;
   ```

   Note: Since we can't easily mock Stack Auth's JWKS, tests will need to either:
   a. Mock the verifyAccessToken function
   b. Use a test Stack Auth project with real tokens

   For unit tests, we'll mock verifyAccessToken.

3. Create test user constants:
   ```typescript
   export const TEST_USER = {
     id: 'user_test123456',
     email: 'test@example.com',
     name: 'Test User',
   };

   export const TEST_ORG = {
     id: '00000000-0000-0000-0000-000000000001',
     name: 'Test Organization',
   };
   ```

4. Create helper to generate mock tokens (for documentation):
   ```typescript
   export interface MockTokenOptions {
     userId?: string;
     email?: string;
     name?: string;
     expired?: boolean;
   }

   // This would be used if we could sign tokens for testing
   // In practice, we'll mock verifyAccessToken instead
   export async function createMockToken(opts: MockTokenOptions = {}) {
     // Implementation depends on testing strategy
     throw new Error('Use vitest mocking for verifyAccessToken instead');
   }
   ```

5. Create mock user setup for tests:
   ```typescript
   import { vi } from 'vitest';
   import type { AuthUser } from '../../src/types/auth.js';

   export function mockAuthenticatedUser(user: Partial<AuthUser> = {}) {
     return {
       id: user.id ?? TEST_USER.id,
       email: user.email ?? TEST_USER.email,
       name: user.name ?? TEST_USER.name,
       profileId: user.profileId,
       organizationId: user.organizationId,
       role: user.role,
     };
   }
   ```

Note: Testing approach will use Vitest's mocking to stub verifyAccessToken.
This avoids needing a real Stack Auth project for unit tests.
  </action>
  <verify>
File exists with test constants.
TEST_USER and TEST_ORG exported.
mockAuthenticatedUser helper exported.
  </verify>
  <done>
JWT test helpers created.
Test user constants defined.
Mock user factory available for tests.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create auth and RBAC integration tests</name>
  <files>backend/tests/auth.test.ts, backend/tests/rbac.test.ts</files>
  <action>
Create `backend/tests/auth.test.ts`:

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { buildApp } from '../src/app.js';
import type { FastifyInstance } from 'fastify';

// Mock the JWT verification module
vi.mock('../src/utils/jwt.js', () => ({
  verifyAccessToken: vi.fn(),
}));

import { verifyAccessToken } from '../src/utils/jwt.js';
const mockVerify = vi.mocked(verifyAccessToken);

describe('Authentication Middleware', () => {
  let app: FastifyInstance;

  beforeEach(async () => {
    app = buildApp();
    await app.ready();
    vi.clearAllMocks();
  });

  afterEach(async () => {
    await app.close();
  });

  describe('requireAuth', () => {
    it('returns 401 when no Authorization header', async () => {
      const response = await app.inject({
        method: 'GET',
        url: '/api/protected',
      });

      expect(response.statusCode).toBe(401);
      expect(response.json()).toMatchObject({
        error: 'Unauthorized',
        message: expect.stringContaining('Authorization'),
      });
    });

    it('returns 401 when Authorization header is not Bearer', async () => {
      const response = await app.inject({
        method: 'GET',
        url: '/api/protected',
        headers: {
          authorization: 'Basic dXNlcjpwYXNz',
        },
      });

      expect(response.statusCode).toBe(401);
    });

    it('returns 401 for invalid token', async () => {
      mockVerify.mockRejectedValue(new Error('Invalid token'));

      const response = await app.inject({
        method: 'GET',
        url: '/api/protected',
        headers: {
          authorization: 'Bearer invalid.token.here',
        },
      });

      expect(response.statusCode).toBe(401);
      expect(response.json()).toMatchObject({
        error: 'Unauthorized',
        message: expect.stringContaining('Invalid'),
      });
    });

    it('returns 200 for valid token', async () => {
      mockVerify.mockResolvedValue({
        payload: {
          sub: 'user_123',
          email: 'test@example.com',
          name: 'Test',
          iss: 'stack-auth',
          aud: 'project_id',
          exp: Math.floor(Date.now() / 1000) + 3600,
          iat: Math.floor(Date.now() / 1000),
        },
        userId: 'user_123',
      });

      const response = await app.inject({
        method: 'GET',
        url: '/api/protected',
        headers: {
          authorization: 'Bearer valid.token.here',
        },
      });

      expect(response.statusCode).toBe(200);
      expect(response.json()).toMatchObject({
        userId: 'user_123',
        email: 'test@example.com',
      });
    });
  });
});
```

Create `backend/tests/rbac.test.ts`:

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { buildApp } from '../src/app.js';
import type { FastifyInstance } from 'fastify';

// Mock JWT verification
vi.mock('../src/utils/jwt.js', () => ({
  verifyAccessToken: vi.fn(),
}));

// Mock user service for org context
vi.mock('../src/services/user.service.js', () => ({
  getUserRoleInOrg: vi.fn(),
}));

import { verifyAccessToken } from '../src/utils/jwt.js';
import { getUserRoleInOrg } from '../src/services/user.service.js';

const mockVerify = vi.mocked(verifyAccessToken);
const mockGetRole = vi.mocked(getUserRoleInOrg);

const TEST_ORG_ID = '00000000-0000-0000-0000-000000000001';
const TEST_USER_ID = 'user_123';

describe('RBAC Middleware', () => {
  let app: FastifyInstance;

  beforeEach(async () => {
    app = buildApp();
    await app.ready();
    vi.clearAllMocks();

    // Default: valid token
    mockVerify.mockResolvedValue({
      payload: {
        sub: TEST_USER_ID,
        email: 'test@example.com',
        iss: 'stack-auth',
        aud: 'project_id',
        exp: Math.floor(Date.now() / 1000) + 3600,
        iat: Math.floor(Date.now() / 1000),
      },
      userId: TEST_USER_ID,
    });
  });

  afterEach(async () => {
    await app.close();
  });

  describe('requireOrgContext', () => {
    it('returns 403 when user has no access to organization', async () => {
      mockGetRole.mockResolvedValue(null);

      const response = await app.inject({
        method: 'GET',
        url: `/api/orgs/${TEST_ORG_ID}/test`,
        headers: {
          authorization: 'Bearer valid.token',
        },
      });

      expect(response.statusCode).toBe(403);
      expect(response.json()).toMatchObject({
        error: 'Forbidden',
        message: expect.stringContaining('No access'),
      });
    });

    it('returns 200 and sets org context when user has access', async () => {
      mockGetRole.mockResolvedValue('manager');

      const response = await app.inject({
        method: 'GET',
        url: `/api/orgs/${TEST_ORG_ID}/test`,
        headers: {
          authorization: 'Bearer valid.token',
        },
      });

      expect(response.statusCode).toBe(200);
      expect(response.json()).toMatchObject({
        userId: TEST_USER_ID,
        organizationId: TEST_ORG_ID,
        role: 'manager',
      });
    });
  });

  describe('requireRole', () => {
    it('returns 403 when user role is below required', async () => {
      mockGetRole.mockResolvedValue('viewer'); // viewer < admin

      const response = await app.inject({
        method: 'DELETE',
        url: `/api/orgs/${TEST_ORG_ID}/users/user_456`,
        headers: {
          authorization: 'Bearer valid.token',
        },
      });

      expect(response.statusCode).toBe(403);
      expect(response.json()).toMatchObject({
        error: 'Forbidden',
        message: expect.stringContaining('admin'),
      });
    });

    it('allows user with exact required role', async () => {
      mockGetRole.mockResolvedValue('admin');

      const response = await app.inject({
        method: 'DELETE',
        url: `/api/orgs/${TEST_ORG_ID}/users/user_456`,
        headers: {
          authorization: 'Bearer valid.token',
        },
      });

      expect(response.statusCode).toBe(200);
    });

    it('allows user with higher role than required', async () => {
      mockGetRole.mockResolvedValue('owner'); // owner > admin

      const response = await app.inject({
        method: 'DELETE',
        url: `/api/orgs/${TEST_ORG_ID}/users/user_456`,
        headers: {
          authorization: 'Bearer valid.token',
        },
      });

      expect(response.statusCode).toBe(200);
    });

    it('enforces role hierarchy correctly', async () => {
      // Test that manager (3) cannot access admin (4) routes
      mockGetRole.mockResolvedValue('manager');

      const response = await app.inject({
        method: 'DELETE',
        url: `/api/orgs/${TEST_ORG_ID}/users/user_456`,
        headers: {
          authorization: 'Bearer valid.token',
        },
      });

      expect(response.statusCode).toBe(403);
    });
  });
});
```

Note: Tests use Vitest's vi.mock for isolation. They don't need a real database or Stack Auth.
  </action>
  <verify>
Run `pnpm test` in backend directory - all tests pass.
Tests cover: no token, invalid token, valid token, insufficient role, cross-org access.
Error status codes: 401 for auth failures, 403 for authorization failures.
  </verify>
  <done>
Authentication tests verify 401 responses for invalid/missing tokens.
RBAC tests verify 403 responses for insufficient roles.
Role hierarchy tests confirm owner > admin > manager > staff > viewer.
Tenant isolation tests confirm cross-org access is blocked.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
1. `cd backend && pnpm test` - all tests pass
2. Tests cover requirements:
   - AUTH-02: JWT validation middleware (tested)
   - AUTH-03: 401 for invalid tokens (tested)
   - AUTH-04: request.user populated (tested)
   - RBAC-01: Role hierarchy (tested)
   - RBAC-02: requireRole middleware (tested)
   - RBAC-03: 403 for insufficient role (tested)
   - RBAC-04: Organization context middleware (tested)
   - RBAC-05: Cross-org access blocked (tested)
3. Vitest configuration works with TypeScript
</verification>

<success_criteria>
- Vitest runs tests successfully
- All auth tests pass (401 for invalid tokens)
- All RBAC tests pass (403 for insufficient role)
- Role hierarchy enforced in tests
- Tenant isolation verified in tests
- Fastify app factory works with inject() pattern
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-rbac/02-05-SUMMARY.md`
</output>
