---
phase: 19-backend-api-migration-foundation
plan: 04
type: execute
wave: 3
depends_on: ['19-02', '19-03']
files_modified:
  - src/lib/api/organizations.ts
  - src/hooks/useOrganization.ts
  - backend/tests/trpc/e2e.test.ts
autonomous: true

must_haves:
  truths:
    - 'Organizations API calls use tRPC instead of Ky'
    - 'useOrganization hook works with tRPC'
    - 'Frontend can fetch organization data via tRPC'
    - 'Frontend can update organization via tRPC'
    - 'E2E test verifies full request path'
  artifacts:
    - path: 'src/lib/api/organizations.ts'
      provides: 'tRPC-based organizations API'
      exports: ['organizationsApi']
    - path: 'backend/tests/trpc/e2e.test.ts'
      provides: 'End-to-end verification tests'
      min_lines: 30
  key_links:
    - from: 'src/lib/api/organizations.ts'
      to: 'src/lib/trpc.ts'
      via: 'useTRPC import'
      pattern: 'useTRPC'
    - from: 'src/hooks/useOrganization.ts'
      to: 'src/lib/api/organizations.ts'
      via: 'organizationsApi import'
      pattern: 'organizationsApi'
---

<objective>
Migrate organizations API to tRPC and verify end-to-end integration.

Purpose: Complete the pilot migration by replacing Ky-based API calls with tRPC procedures and verifying the full stack works correctly.

Output: Organizations domain fully migrated to tRPC with E2E verification passing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-backend-api-migration-foundation/19-CONTEXT.md
@.planning/phases/19-backend-api-migration-foundation/19-RESEARCH.md
@.planning/phases/19-backend-api-migration-foundation/19-01-SUMMARY.md
@.planning/phases/19-backend-api-migration-foundation/19-02-SUMMARY.md
@.planning/phases/19-backend-api-migration-foundation/19-03-SUMMARY.md
@src/lib/api/organizations.ts
@src/lib/trpc.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update organizations API to use tRPC</name>
  <files>
    src/lib/api/organizations.ts
  </files>
  <action>
Update src/lib/api/organizations.ts to use tRPC while maintaining the same API surface for backward compatibility:

````typescript
/**
 * Organizations API
 *
 * Migrated from Ky-based REST calls to tRPC procedures.
 * Maintains same function signatures for backward compatibility with existing hooks.
 *
 * Note: These functions are for use outside of React components.
 * Inside components, use useTRPC() directly for better caching and reactivity.
 */

import type { RouterOutput } from '../trpc';

// Re-export types for backward compatibility
export type OrganizationResponse = RouterOutput['organizations']['get'];
export type MemberResponse = RouterOutput['organizations']['listMembers'][number];
export type OrganizationStatsResponse = RouterOutput['organizations']['stats'];

// Type for update request
export interface UpdateOrganizationRequest {
  name?: string;
  timezone?: string;
  complianceMode?: 'standard' | 'haccp';
  logoUrl?: string | null;
}

/**
 * Organizations API client for use outside React components.
 *
 * For React components, prefer using useTRPC() hook directly:
 * ```typescript
 * const trpc = useTRPC();
 * const { data } = trpc.organizations.get.useQuery({ organizationId });
 * ```
 *
 * This API is maintained for:
 * - Non-React code paths
 * - Gradual migration of existing hooks
 * - Server-side rendering scenarios
 */
export const organizationsApi = {
  /**
   * Get organization by ID
   *
   * @deprecated Use trpc.organizations.get.useQuery() in components
   */
  getOrganization: async (
    orgId: string,
    trpcClient: ReturnType<typeof import('../trpc').useTRPCClient>,
  ): Promise<OrganizationResponse> => {
    return trpcClient.organizations.get.query({ organizationId: orgId });
  },

  /**
   * Update organization
   *
   * @deprecated Use trpc.organizations.update.useMutation() in components
   */
  updateOrganization: async (
    orgId: string,
    updates: UpdateOrganizationRequest,
    trpcClient: ReturnType<typeof import('../trpc').useTRPCClient>,
  ): Promise<OrganizationResponse> => {
    return trpcClient.organizations.update.mutate({
      organizationId: orgId,
      data: updates,
    });
  },

  /**
   * List organization members
   *
   * @deprecated Use trpc.organizations.listMembers.useQuery() in components
   */
  listMembers: async (
    orgId: string,
    trpcClient: ReturnType<typeof import('../trpc').useTRPCClient>,
  ): Promise<MemberResponse[]> => {
    return trpcClient.organizations.listMembers.query({ organizationId: orgId });
  },

  /**
   * Get organization stats
   *
   * @deprecated Use trpc.organizations.stats.useQuery() in components
   */
  getStats: async (
    orgId: string,
    trpcClient: ReturnType<typeof import('../trpc').useTRPCClient>,
  ): Promise<OrganizationStatsResponse> => {
    return trpcClient.organizations.stats.query({ organizationId: orgId });
  },
};
````

Note: The API signature changed - now requires trpcClient instead of accessToken.
This is a breaking change for existing callers, but the functions are marked deprecated
and components should migrate to using useTRPC() directly.
</action>
<verify> - File exists: src/lib/api/organizations.ts - `npm run typecheck` passes
</verify>
<done>
Organizations API updated to use tRPC. Types exported for backward compatibility.
</done>
</task>

<task type="auto">
  <name>Task 2: Update useOrganization hook (if exists) or document migration pattern</name>
  <files>
    src/hooks/useOrganization.ts (if exists, otherwise document pattern)
  </files>
  <action>
First, check if useOrganization hook exists:
```bash
ls src/hooks/useOrganization.ts 2>/dev/null || echo "Hook does not exist"
grep -r "useOrganization" src/hooks/ --include="*.ts" --include="*.tsx" | head -5
```

If hook exists, update it to use tRPC directly:

```typescript
/**
 * useOrganization Hook
 *
 * Fetches organization data using tRPC with TanStack Query.
 */
import { useTRPC } from '@/lib/trpc';

export function useOrganization(organizationId: string | undefined) {
  const trpc = useTRPC();

  const query = trpc.organizations.get.useQuery(
    { organizationId: organizationId! },
    {
      enabled: !!organizationId,
      staleTime: 60 * 1000, // 1 minute
    },
  );

  return {
    organization: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,
  };
}

export function useOrganizationStats(organizationId: string | undefined) {
  const trpc = useTRPC();

  const query = trpc.organizations.stats.useQuery(
    { organizationId: organizationId! },
    {
      enabled: !!organizationId,
      staleTime: 30 * 1000, // 30 seconds
    },
  );

  return {
    stats: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,
  };
}

export function useOrganizationMembers(organizationId: string | undefined) {
  const trpc = useTRPC();

  const query = trpc.organizations.listMembers.useQuery(
    { organizationId: organizationId! },
    {
      enabled: !!organizationId,
      staleTime: 60 * 1000, // 1 minute
    },
  );

  return {
    members: query.data,
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,
  };
}

export function useUpdateOrganization() {
  const trpc = useTRPC();

  const mutation = trpc.organizations.update.useMutation();

  return {
    updateOrganization: (
      organizationId: string,
      data: Parameters<typeof mutation.mutate>[0]['data'],
    ) => mutation.mutateAsync({ organizationId, data }),
    isLoading: mutation.isPending,
    isError: mutation.isError,
    error: mutation.error,
  };
}
```

If hook doesn't exist, create a new file documenting the tRPC usage pattern for organizations:

````typescript
/**
 * Organization Hooks (tRPC)
 *
 * Example usage patterns for organizations domain with tRPC.
 * Components can use useTRPC() directly or use these convenience hooks.
 *
 * @example Direct tRPC usage:
 * ```typescript
 * function OrganizationPage() {
 *   const { organizationId } = useCurrentOrg();
 *   const trpc = useTRPC();
 *
 *   const { data: org, isLoading } = trpc.organizations.get.useQuery(
 *     { organizationId },
 *     { enabled: !!organizationId }
 *   );
 *
 *   const updateMutation = trpc.organizations.update.useMutation({
 *     onSuccess: () => {
 *       // Invalidate and refetch
 *       trpc.organizations.get.invalidate({ organizationId });
 *     },
 *   });
 *
 *   return ...;
 * }
 * ```
 */

export * from './useOrganization';
````

  </action>
  <verify>
    - Hook file created/updated: src/hooks/useOrganization.ts
    - `npm run typecheck` passes
    - No TypeScript errors in hook file
  </verify>
  <done>
    Organization hooks created/updated to use tRPC. Pattern documented for component usage.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create E2E verification test</name>
  <files>
    backend/tests/trpc/e2e.test.ts
  </files>
  <action>
Create backend/tests/trpc/e2e.test.ts for end-to-end tRPC verification:

```typescript
/**
 * tRPC E2E Tests
 *
 * Verifies the full tRPC stack works correctly:
 * - Client -> Server communication
 * - Authentication middleware
 * - Organization context
 * - Response serialization
 *
 * These tests require a running database but use the test app instance.
 */

import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { buildApp } from '../../src/app.js';
import type { FastifyInstance } from 'fastify';

describe('tRPC E2E', () => {
  let app: FastifyInstance;

  beforeAll(async () => {
    app = buildApp({ logger: false });
    await app.ready();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('Health endpoint', () => {
    it('should respond to health check', async () => {
      const response = await app.inject({
        method: 'GET',
        url: '/trpc/health',
      });

      expect(response.statusCode).toBe(200);

      const body = JSON.parse(response.body);
      expect(body.result.data.status).toBe('ok');
      expect(body.result.data.timestamp).toBeDefined();
    });
  });

  describe('Authentication', () => {
    it('should reject unauthenticated requests to protected procedures', async () => {
      const response = await app.inject({
        method: 'GET',
        url: '/trpc/organizations.get',
        query: {
          input: JSON.stringify({ organizationId: '00000000-0000-0000-0000-000000000000' }),
        },
      });

      expect(response.statusCode).toBe(401);

      const body = JSON.parse(response.body);
      expect(body.error.message).toContain('UNAUTHORIZED');
    });
  });

  describe('Batched requests', () => {
    it('should handle batched procedure calls', async () => {
      // Batch two health checks in one request
      const response = await app.inject({
        method: 'GET',
        url: '/trpc/health,health',
        query: {
          input: JSON.stringify({}),
        },
      });

      expect(response.statusCode).toBe(200);

      const body = JSON.parse(response.body);
      // Batched response is an array
      expect(Array.isArray(body)).toBe(true);
      expect(body.length).toBe(2);
      expect(body[0].result.data.status).toBe('ok');
      expect(body[1].result.data.status).toBe('ok');
    });
  });

  describe('Error handling', () => {
    it('should return proper error format for invalid input', async () => {
      const response = await app.inject({
        method: 'GET',
        url: '/trpc/organizations.get',
        query: {
          input: JSON.stringify({ organizationId: 'not-a-uuid' }),
        },
        headers: {
          // Provide a fake token to pass auth check and test input validation
          'x-stack-access-token': 'fake-token-for-testing',
        },
      });

      // Should fail on auth or input validation
      expect(response.statusCode).toBeGreaterThanOrEqual(400);

      const body = JSON.parse(response.body);
      expect(body.error).toBeDefined();
    });
  });

  describe('Type safety verification', () => {
    it('should export AppRouter type correctly', async () => {
      // This is a compile-time check - if it compiles, types are working
      const { appRouter, type AppRouter } = await import('../../src/trpc/router.js');

      // Runtime check that router exists with expected shape
      expect(appRouter).toBeDefined();
      expect(appRouter._def.procedures).toBeDefined();
      expect(appRouter._def.procedures.health).toBeDefined();
      expect(appRouter._def.procedures.organizations).toBeDefined();
    });
  });
});
```

Run the E2E tests:

```bash
cd backend && npm test -- --grep "tRPC E2E"
```

  </action>
  <verify>
    - File exists: backend/tests/trpc/e2e.test.ts
    - `cd backend && npm test` passes (all tests including E2E)
    - E2E tests verify: health endpoint, auth rejection, batched requests, error handling
  </verify>
  <done>
    E2E verification tests passing. Full tRPC stack verified working.
  </done>
</task>

</tasks>

<verification>
1. Organizations API migrated: grep "useTRPC\|trpcClient" src/lib/api/organizations.ts
2. Hook updated/created: src/hooks/useOrganization.ts exists with tRPC usage
3. E2E tests exist: backend/tests/trpc/e2e.test.ts
4. All tests pass: cd backend && npm test
5. TypeScript compiles: npm run typecheck (root) && cd backend && npm run build
6. Manual verification (with both servers running):
   - Backend: cd backend && npm run dev
   - Frontend: npm run dev
   - Open browser, navigate to organization page
   - Verify organization data loads via tRPC (check Network tab for /trpc/* requests)
</verification>

<success_criteria>

- src/lib/api/organizations.ts uses tRPC instead of Ky
- Organization hooks use tRPC procedures
- E2E tests verify:
  - Health endpoint responds correctly
  - Unauthenticated requests rejected
  - Batched requests work
  - Error format correct
  - AppRouter type exports correctly
- All backend tests pass
- Frontend TypeScript compiles
- Organizations domain fully migrated to tRPC
  </success_criteria>

<output>
After completion, create `.planning/phases/19-backend-api-migration-foundation/19-04-SUMMARY.md`
</output>
