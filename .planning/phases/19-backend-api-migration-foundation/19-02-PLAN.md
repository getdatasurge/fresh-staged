---
phase: 19-backend-api-migration-foundation
plan: 02
type: execute
wave: 2
depends_on: ['19-01']
files_modified:
  - backend/src/routers/organizations.router.ts
  - backend/src/trpc/router.ts
  - backend/tests/trpc/organizations.router.test.ts
autonomous: true

must_haves:
  truths:
    - 'organizations.get returns organization data for members'
    - 'organizations.update requires owner role'
    - 'organizations.listMembers returns member list'
    - 'organizations.stats returns dashboard statistics'
    - 'Unauthorized requests are rejected with UNAUTHORIZED'
    - 'Non-member requests are rejected with FORBIDDEN'
  artifacts:
    - path: 'backend/src/routers/organizations.router.ts'
      provides: 'tRPC organizations domain router'
      exports: ['organizationsRouter']
    - path: 'backend/tests/trpc/organizations.router.test.ts'
      provides: 'Router unit tests'
      min_lines: 50
  key_links:
    - from: 'backend/src/trpc/router.ts'
      to: 'backend/src/routers/organizations.router.ts'
      via: 'router composition'
      pattern: 'organizations: organizationsRouter'
    - from: 'backend/src/routers/organizations.router.ts'
      to: 'backend/src/services/organization.service.ts'
      via: 'service layer calls'
      pattern: "orgService\\."
---

<objective>
Create tRPC router for organizations domain with all CRUD procedures.

Purpose: Pilot migration of the organizations domain to tRPC, establishing patterns for subsequent domain migrations in Phase 20-21.

Output: Fully functional organizations router with get, update, listMembers, and stats procedures matching existing REST API functionality.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-backend-api-migration-foundation/19-CONTEXT.md
@.planning/phases/19-backend-api-migration-foundation/19-RESEARCH.md
@.planning/phases/19-backend-api-migration-foundation/19-01-SUMMARY.md
@backend/src/routes/organizations.ts
@backend/src/schemas/organizations.ts
@backend/src/services/organization.service.ts
@backend/src/services/organization-stats.service.ts
@backend/src/trpc/index.ts
@backend/src/trpc/procedures.ts
@backend/src/trpc/router.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create organizations router with all procedures</name>
  <files>
    backend/src/routers/organizations.router.ts
  </files>
  <action>
Create backend/src/routers/organizations.router.ts:

```typescript
import { z } from 'zod';
import { TRPCError } from '@trpc/server';
import { router, publicProcedure } from '../trpc/index.js';
import { protectedProcedure, orgProcedure } from '../trpc/procedures.js';
import * as orgService from '../services/organization.service.js';
import { getOrganizationStatsService } from '../services/organization-stats.service.js';
import {
  OrganizationSchema,
  UpdateOrganizationSchema,
  MembersListSchema,
  OrganizationStatsSchema,
} from '../schemas/organizations.js';

// Input schema for org-scoped procedures
const OrgInput = z.object({
  organizationId: z.string().uuid(),
});

// Input schema for update with data
const UpdateOrgInput = z.object({
  organizationId: z.string().uuid(),
  data: UpdateOrganizationSchema,
});

export const organizationsRouter = router({
  /**
   * Get organization details
   * Equivalent to: GET /api/orgs/:organizationId
   */
  get: orgProcedure
    .input(OrgInput)
    .output(OrganizationSchema)
    .query(async ({ ctx, input }) => {
      const org = await orgService.getOrganization(ctx.organizationId);

      if (!org) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Organization not found',
        });
      }

      return org;
    }),

  /**
   * Update organization settings
   * Equivalent to: PUT /api/orgs/:organizationId
   * Requires owner role
   */
  update: orgProcedure
    .input(UpdateOrgInput)
    .output(OrganizationSchema)
    .mutation(async ({ ctx, input }) => {
      // Role check - owner only
      if (ctx.role !== 'owner') {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'Only organization owners can update settings',
        });
      }

      const org = await orgService.updateOrganization(ctx.organizationId, input.data);

      if (!org) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Organization not found',
        });
      }

      return org;
    }),

  /**
   * List organization members
   * Equivalent to: GET /api/orgs/:organizationId/members
   */
  listMembers: orgProcedure
    .input(OrgInput)
    .output(MembersListSchema)
    .query(async ({ ctx }) => {
      const members = await orgService.listMembers(ctx.organizationId);
      return members;
    }),

  /**
   * Get organization stats for dashboard
   * Equivalent to: GET /api/orgs/:organizationId/stats
   */
  stats: orgProcedure
    .input(OrgInput)
    .output(OrganizationStatsSchema)
    .query(async ({ ctx }) => {
      const statsService = getOrganizationStatsService();

      if (!statsService) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Organization stats service not initialized',
        });
      }

      const stats = await statsService.getOrganizationStats(ctx.organizationId);
      return stats;
    }),
});
```

Key implementation notes:

- orgProcedure handles auth + org membership check, provides ctx.organizationId, ctx.role, ctx.profileId
- Reuse existing Zod schemas from backend/src/schemas/organizations.ts
- Match existing REST API behavior exactly
- Use TRPCError with appropriate codes (NOT_FOUND, FORBIDDEN, INTERNAL_SERVER_ERROR)
  </action>
  <verify> - File exists: backend/src/routers/organizations.router.ts - `cd backend && npm run build` compiles without errors
  </verify>
  <done>
  Organizations router created with get, update, listMembers, and stats procedures.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Register organizations router in app router</name>
  <files>
    backend/src/trpc/router.ts
  </files>
  <action>
Update backend/src/trpc/router.ts to include organizations router:

```typescript
import { z } from 'zod';
import { router, publicProcedure } from './index.js';
import { organizationsRouter } from '../routers/organizations.router.js';

export const appRouter = router({
  // Health check for verification
  health: publicProcedure
    .output(z.object({ status: z.string(), timestamp: z.string() }))
    .query(() => ({
      status: 'ok',
      timestamp: new Date().toISOString(),
    })),

  // Domain routers
  organizations: organizationsRouter,
});

export type AppRouter = typeof appRouter;
```

This enables calls like:

- trpc.organizations.get({ organizationId: '...' })
- trpc.organizations.update({ organizationId: '...', data: { name: '...' } })
- trpc.organizations.listMembers({ organizationId: '...' })
- trpc.organizations.stats({ organizationId: '...' })
  </action>
  <verify> - `cd backend && npm run build` compiles without errors - grep "organizations: organizationsRouter" backend/src/trpc/router.ts
  </verify>
  <done>
  Organizations router registered in app router. Type AppRouter now includes organizations namespace.
  </done>
  </task>

<task type="auto">
  <name>Task 3: Add router unit tests</name>
  <files>
    backend/tests/trpc/organizations.router.test.ts
  </files>
  <action>
Create backend/tests/trpc/organizations.router.test.ts:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { createCallerFactory } from '../../src/trpc/index.js';
import { appRouter } from '../../src/trpc/router.js';
import type { Context } from '../../src/trpc/context.js';
import type { FastifyRequest, FastifyReply } from 'fastify';
import type { AppRole } from '../../src/types/auth.js';

// Mock services
vi.mock('../../src/services/organization.service.js', () => ({
  getOrganization: vi.fn(),
  updateOrganization: vi.fn(),
  listMembers: vi.fn(),
}));

vi.mock('../../src/services/organization-stats.service.js', () => ({
  getOrganizationStatsService: vi.fn(),
}));

const createCaller = createCallerFactory(appRouter);

// Helper to create test context
function createTestContext(
  overrides: {
    user?: Context['user'];
    organizationId?: string;
    role?: AppRole;
    profileId?: string;
  } = {},
): Context {
  return {
    req: {} as FastifyRequest,
    res: {} as FastifyReply,
    user: overrides.user ?? {
      id: 'user-123',
      email: 'test@example.com',
      name: 'Test User',
    },
    // These are populated by orgProcedure middleware
    organizationId: overrides.organizationId,
    role: overrides.role,
    profileId: overrides.profileId,
  } as Context;
}

describe('Organizations Router', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('organizations.get', () => {
    it('should return organization for authenticated member', async () => {
      const { getOrganization } = await import('../../src/services/organization.service.js');
      (getOrganization as any).mockResolvedValue({
        id: 'org-456',
        name: 'Test Org',
        slug: 'test-org',
        timezone: 'America/New_York',
        complianceMode: 'standard',
        sensorLimit: 100,
        logoUrl: null,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      });

      // Note: orgProcedure validates membership and populates ctx
      // For unit tests, we simulate the post-middleware context
      const ctx = createTestContext({
        organizationId: 'org-456',
        role: 'admin',
        profileId: 'profile-789',
      });

      const caller = createCaller(ctx);
      const result = await caller.organizations.get({ organizationId: 'org-456' });

      expect(result.id).toBe('org-456');
      expect(result.name).toBe('Test Org');
    });

    it('should throw NOT_FOUND when organization does not exist', async () => {
      const { getOrganization } = await import('../../src/services/organization.service.js');
      (getOrganization as any).mockResolvedValue(null);

      const ctx = createTestContext({
        organizationId: 'org-404',
        role: 'admin',
        profileId: 'profile-789',
      });

      const caller = createCaller(ctx);

      await expect(caller.organizations.get({ organizationId: 'org-404' })).rejects.toThrow(
        'NOT_FOUND',
      );
    });
  });

  describe('organizations.update', () => {
    it('should update organization when user is owner', async () => {
      const { updateOrganization } = await import('../../src/services/organization.service.js');
      (updateOrganization as any).mockResolvedValue({
        id: 'org-456',
        name: 'Updated Org',
        slug: 'test-org',
        timezone: 'America/New_York',
        complianceMode: 'standard',
        sensorLimit: 100,
        logoUrl: null,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      });

      const ctx = createTestContext({
        organizationId: 'org-456',
        role: 'owner',
        profileId: 'profile-789',
      });

      const caller = createCaller(ctx);
      const result = await caller.organizations.update({
        organizationId: 'org-456',
        data: { name: 'Updated Org' },
      });

      expect(result.name).toBe('Updated Org');
      expect(updateOrganization).toHaveBeenCalledWith('org-456', { name: 'Updated Org' });
    });

    it('should throw FORBIDDEN when user is not owner', async () => {
      const ctx = createTestContext({
        organizationId: 'org-456',
        role: 'admin', // Not owner
        profileId: 'profile-789',
      });

      const caller = createCaller(ctx);

      await expect(
        caller.organizations.update({
          organizationId: 'org-456',
          data: { name: 'Attempted Update' },
        }),
      ).rejects.toThrow('FORBIDDEN');
    });
  });

  describe('organizations.listMembers', () => {
    it('should return member list', async () => {
      const { listMembers } = await import('../../src/services/organization.service.js');
      (listMembers as any).mockResolvedValue([
        {
          userId: 'user-1',
          email: 'owner@example.com',
          fullName: 'Owner User',
          role: 'owner',
          joinedAt: new Date().toISOString(),
        },
        {
          userId: 'user-2',
          email: 'admin@example.com',
          fullName: 'Admin User',
          role: 'admin',
          joinedAt: new Date().toISOString(),
        },
      ]);

      const ctx = createTestContext({
        organizationId: 'org-456',
        role: 'admin',
        profileId: 'profile-789',
      });

      const caller = createCaller(ctx);
      const result = await caller.organizations.listMembers({ organizationId: 'org-456' });

      expect(result).toHaveLength(2);
      expect(result[0].role).toBe('owner');
    });
  });

  describe('organizations.stats', () => {
    it('should return organization stats', async () => {
      const { getOrganizationStatsService } =
        await import('../../src/services/organization-stats.service.js');
      const mockStatsService = {
        getOrganizationStats: vi.fn().mockResolvedValue({
          organizationId: 'org-456',
          unitCounts: { total: 10, normal: 8, warning: 1, critical: 1, offline: 0 },
          alertCounts: { pending: 2, acknowledged: 1, resolved: 5, total: 8 },
          compliancePercentage: 95,
          worstState: 'critical',
          lastUpdated: new Date().toISOString(),
        }),
      };
      (getOrganizationStatsService as any).mockReturnValue(mockStatsService);

      const ctx = createTestContext({
        organizationId: 'org-456',
        role: 'admin',
        profileId: 'profile-789',
      });

      const caller = createCaller(ctx);
      const result = await caller.organizations.stats({ organizationId: 'org-456' });

      expect(result.organizationId).toBe('org-456');
      expect(result.unitCounts.total).toBe(10);
      expect(result.compliancePercentage).toBe(95);
    });

    it('should throw INTERNAL_SERVER_ERROR when stats service unavailable', async () => {
      const { getOrganizationStatsService } =
        await import('../../src/services/organization-stats.service.js');
      (getOrganizationStatsService as any).mockReturnValue(null);

      const ctx = createTestContext({
        organizationId: 'org-456',
        role: 'admin',
        profileId: 'profile-789',
      });

      const caller = createCaller(ctx);

      await expect(caller.organizations.stats({ organizationId: 'org-456' })).rejects.toThrow(
        'INTERNAL_SERVER_ERROR',
      );
    });
  });
});
```

Note: These tests use createCallerFactory which is the recommended way to test tRPC routers. The tests mock the context to simulate post-orgProcedure state.
</action>
<verify> - File exists: backend/tests/trpc/organizations.router.test.ts - `cd backend && npm test` passes (all tests including new router tests)
</verify>
<done>
Organizations router tests passing. All procedures (get, update, listMembers, stats) covered with success and error cases.
</done>
</task>

</tasks>

<verification>
1. Router file exists: backend/src/routers/organizations.router.ts
2. Router registered: grep "organizations: organizationsRouter" backend/src/trpc/router.ts
3. Tests pass: cd backend && npm test
4. Build succeeds: cd backend && npm run build
5. Manual verification (with server running):
   - curl http://localhost:3000/trpc/organizations.get?input=%7B%22organizationId%22%3A%22test-uuid%22%7D
   - Should return UNAUTHORIZED (no token) or actual data with valid token
</verification>

<success_criteria>

- Organizations router with get, update, listMembers, stats procedures
- Router registered in appRouter
- All 6+ unit tests passing
- TypeScript compiles successfully
- Procedures match existing REST API behavior:
  - get: returns org details for members
  - update: requires owner role
  - listMembers: returns member list
  - stats: returns dashboard statistics
    </success_criteria>

<output>
After completion, create `.planning/phases/19-backend-api-migration-foundation/19-02-SUMMARY.md`
</output>
