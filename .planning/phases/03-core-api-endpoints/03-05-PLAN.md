---
phase: 03-core-api-endpoints
plan: 05
type: execute
wave: 2
depends_on: ['03-01', '03-04']
files_modified:
  - backend/src/services/unit.service.ts
  - backend/src/services/index.ts
  - backend/src/schemas/units.ts
  - backend/src/schemas/index.ts
  - backend/src/routes/units.ts
  - backend/src/app.ts
autonomous: true

must_haves:
  truths:
    - 'User can list units within an area'
    - 'Manager can create a new unit in an area'
    - 'User can view a specific unit'
    - 'Manager can update unit settings'
    - 'Manager can delete (soft) a unit'
    - 'Unit creation validates full hierarchy (org -> site -> area)'
  artifacts:
    - path: 'backend/src/services/unit.service.ts'
      provides: 'Unit CRUD with full hierarchy validation'
      exports: ['listUnits', 'getUnit', 'createUnit', 'updateUnit', 'deleteUnit']
    - path: 'backend/src/routes/units.ts'
      provides: 'Unit REST endpoints'
      exports: ['default (Fastify plugin)']
    - path: 'backend/src/schemas/units.ts'
      provides: 'Zod schemas for unit endpoints'
      exports: ['UnitSchema', 'CreateUnitSchema', 'UpdateUnitSchema']
  key_links:
    - from: 'backend/src/routes/units.ts'
      to: 'backend/src/services/unit.service.ts'
      via: 'service function imports'
      pattern: "unitService\\."
    - from: 'backend/src/services/unit.service.ts'
      to: 'backend/src/db/schema/hierarchy.ts'
      via: 'areas and sites table joins'
      pattern: 'innerJoin.*areas.*sites'
---

<objective>
Implement Unit CRUD endpoints with full hierarchy validation.

Purpose: Allow organization managers to manage refrigeration equipment (the core monitoring entity).
Output: Unit service with full hierarchy validation (org -> site -> area), Zod schemas, route handlers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-api-endpoints/03-RESEARCH.md (hierarchy validation patterns)
@.planning/phases/03-core-api-endpoints/03-CONTEXT.md
@backend/src/db/schema/hierarchy.ts (units, areas, sites tables)
@backend/src/db/schema/enums.ts (unitTypeEnum, unitStatusEnum)
@backend/src/services/area.service.ts (pattern for hierarchy validation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unit service with full hierarchy validation</name>
  <files>backend/src/services/unit.service.ts, backend/src/services/index.ts</files>
  <action>
Create `backend/src/services/unit.service.ts`:

```typescript
import { eq, and } from 'drizzle-orm';
import { db } from '../db/client.js';
import { units, areas, sites, type Unit, type InsertUnit } from '../db/schema/hierarchy.js';

/**
 * Verify full hierarchy: org -> site -> area
 * CRITICAL: Prevents BOLA by ensuring complete hierarchy integrity
 */
async function verifyAreaAccess(
  areaId: string,
  siteId: string,
  organizationId: string,
): Promise<boolean> {
  const [result] = await db
    .select({ areaId: areas.id })
    .from(areas)
    .innerJoin(sites, eq(sites.id, areas.siteId))
    .where(
      and(
        eq(areas.id, areaId),
        eq(areas.siteId, siteId),
        eq(sites.organizationId, organizationId),
        eq(areas.isActive, true),
        eq(sites.isActive, true),
      ),
    )
    .limit(1);

  return !!result;
}

/**
 * List all active units in an area
 */
export async function listUnits(
  areaId: string,
  siteId: string,
  organizationId: string,
): Promise<Unit[] | null> {
  // Verify full hierarchy first
  if (!(await verifyAreaAccess(areaId, siteId, organizationId))) {
    return null; // Area/site not found or not in org
  }

  return db
    .select()
    .from(units)
    .where(and(eq(units.areaId, areaId), eq(units.isActive, true)))
    .orderBy(units.sortOrder, units.name);
}

/**
 * Get a specific unit by ID
 */
export async function getUnit(
  unitId: string,
  areaId: string,
  siteId: string,
  organizationId: string,
): Promise<Unit | null> {
  // Verify full hierarchy
  if (!(await verifyAreaAccess(areaId, siteId, organizationId))) {
    return null;
  }

  const [unit] = await db
    .select()
    .from(units)
    .where(and(eq(units.id, unitId), eq(units.areaId, areaId), eq(units.isActive, true)))
    .limit(1);

  return unit ?? null;
}

/**
 * Create a new unit in an area
 */
export async function createUnit(
  areaId: string,
  siteId: string,
  organizationId: string,
  data: Omit<
    InsertUnit,
    | 'id'
    | 'areaId'
    | 'createdAt'
    | 'updatedAt'
    | 'isActive'
    | 'status'
    | 'lastReadingAt'
    | 'lastTemperature'
  >,
): Promise<Unit | null> {
  // Verify full hierarchy first
  if (!(await verifyAreaAccess(areaId, siteId, organizationId))) {
    return null;
  }

  const [unit] = await db
    .insert(units)
    .values({
      ...data,
      areaId,
      status: 'ok', // New units start with ok status
    })
    .returning();

  return unit;
}

/**
 * Update an existing unit
 */
export async function updateUnit(
  unitId: string,
  areaId: string,
  siteId: string,
  organizationId: string,
  data: Partial<
    Omit<
      InsertUnit,
      'id' | 'areaId' | 'createdAt' | 'updatedAt' | 'lastReadingAt' | 'lastTemperature'
    >
  >,
): Promise<Unit | null> {
  // Verify hierarchy first
  if (!(await verifyAreaAccess(areaId, siteId, organizationId))) {
    return null;
  }

  const [unit] = await db
    .update(units)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(and(eq(units.id, unitId), eq(units.areaId, areaId), eq(units.isActive, true)))
    .returning();

  return unit ?? null;
}

/**
 * Soft delete a unit
 */
export async function deleteUnit(
  unitId: string,
  areaId: string,
  siteId: string,
  organizationId: string,
): Promise<Unit | null> {
  // Verify hierarchy first
  if (!(await verifyAreaAccess(areaId, siteId, organizationId))) {
    return null;
  }

  const [unit] = await db
    .update(units)
    .set({
      isActive: false,
      updatedAt: new Date(),
    })
    .where(and(eq(units.id, unitId), eq(units.areaId, areaId), eq(units.isActive, true)))
    .returning();

  return unit ?? null;
}
```

Update `backend/src/services/index.ts`:

```typescript
// Services barrel export
export * as userService from './user.service.js';
export * as orgService from './organization.service.js';
export * as siteService from './site.service.js';
export * as areaService from './area.service.js';
export * as unitService from './unit.service.js';
```

  </action>
  <verify>Run `cd backend && npx tsc --noEmit` to verify no TypeScript errors.</verify>
  <done>Unit service provides CRUD with full hierarchy validation (org -> site -> area -> unit).</done>
</task>

<task type="auto">
  <name>Task 2: Create unit Zod schemas</name>
  <files>backend/src/schemas/units.ts, backend/src/schemas/index.ts</files>
  <action>
Create `backend/src/schemas/units.ts`:

```typescript
import { z } from 'zod';
import { UuidSchema, TimestampSchema, AreaParamsSchema } from './common.js';

// Unit type enum matching database
const UnitTypeSchema = z.enum([
  'fridge',
  'freezer',
  'display_case',
  'walk_in_cooler',
  'walk_in_freezer',
  'blast_chiller',
]);

// Unit status enum matching database
const UnitStatusSchema = z.enum([
  'ok',
  'excursion',
  'alarm_active',
  'monitoring_interrupted',
  'manual_required',
  'restoring',
  'offline',
]);

// Temperature unit (F or C)
const TempUnitSchema = z.enum(['F', 'C']);

// Unit params with required unitId
export const UnitRequiredParamsSchema = AreaParamsSchema.extend({
  unitId: UuidSchema,
});

// Full unit response schema
export const UnitSchema = z.object({
  id: UuidSchema,
  areaId: UuidSchema,
  name: z.string(),
  unitType: UnitTypeSchema,
  status: UnitStatusSchema,
  tempMin: z.number().int(),
  tempMax: z.number().int(),
  tempUnit: TempUnitSchema,
  manualMonitoringRequired: z.boolean(),
  manualMonitoringInterval: z.number().int().nullable(),
  lastReadingAt: TimestampSchema.nullable(),
  lastTemperature: z.number().int().nullable(),
  isActive: z.boolean(),
  sortOrder: z.number().int(),
  createdAt: TimestampSchema,
  updatedAt: TimestampSchema,
});

// Create unit request body
export const CreateUnitSchema = z
  .object({
    name: z.string().min(1).max(256),
    unitType: UnitTypeSchema,
    tempMin: z.number().int().describe('Minimum temperature (x10 for precision, e.g., 320 = 32.0)'),
    tempMax: z.number().int().describe('Maximum temperature (x10 for precision, e.g., 400 = 40.0)'),
    tempUnit: TempUnitSchema.default('F'),
    manualMonitoringRequired: z.boolean().default(false),
    manualMonitoringInterval: z.number().int().min(1).nullable().optional(),
    sortOrder: z.number().int().min(0).default(0),
  })
  .refine((data) => data.tempMin < data.tempMax, {
    message: 'tempMin must be less than tempMax',
    path: ['tempMin'],
  });

// Update unit request body (all fields optional except validation)
export const UpdateUnitSchema = z
  .object({
    name: z.string().min(1).max(256).optional(),
    unitType: UnitTypeSchema.optional(),
    tempMin: z.number().int().optional(),
    tempMax: z.number().int().optional(),
    tempUnit: TempUnitSchema.optional(),
    manualMonitoringRequired: z.boolean().optional(),
    manualMonitoringInterval: z.number().int().min(1).nullable().optional(),
    sortOrder: z.number().int().min(0).optional(),
    isActive: z.boolean().optional(),
  })
  .refine(
    (data) => {
      // If both are provided, validate relationship
      if (data.tempMin !== undefined && data.tempMax !== undefined) {
        return data.tempMin < data.tempMax;
      }
      return true;
    },
    { message: 'tempMin must be less than tempMax', path: ['tempMin'] },
  );

// Units list response
export const UnitsListSchema = z.array(UnitSchema);

// Type exports
export type UnitResponse = z.infer<typeof UnitSchema>;
export type CreateUnitRequest = z.infer<typeof CreateUnitSchema>;
export type UpdateUnitRequest = z.infer<typeof UpdateUnitSchema>;
```

Update `backend/src/schemas/index.ts`:

```typescript
// Schemas barrel export
export * from './common.js';
export * from './organizations.js';
export * from './sites.js';
export * from './areas.js';
export * from './units.js';
```

  </action>
  <verify>Run `cd backend && npx tsc --noEmit` to verify no TypeScript errors.</verify>
  <done>Unit Zod schemas with tempMin < tempMax validation refinement.</done>
</task>

<task type="auto">
  <name>Task 3: Create unit routes and register in app</name>
  <files>backend/src/routes/units.ts, backend/src/app.ts</files>
  <action>
Create `backend/src/routes/units.ts`:

```typescript
import type { FastifyInstance } from 'fastify';
import type { ZodTypeProvider } from 'fastify-type-provider-zod';
import { requireAuth, requireOrgContext, requireRole } from '../middleware/index.js';
import * as unitService from '../services/unit.service.js';
import { notFound } from '../utils/errors.js';
import {
  UnitSchema,
  UnitsListSchema,
  CreateUnitSchema,
  UpdateUnitSchema,
  UnitRequiredParamsSchema,
} from '../schemas/units.js';
import { AreaParamsSchema, ErrorResponseSchema } from '../schemas/common.js';

export default async function unitRoutes(fastify: FastifyInstance) {
  const app = fastify.withTypeProvider<ZodTypeProvider>();

  // GET /api/orgs/:organizationId/sites/:siteId/areas/:areaId/units - List units
  app.get(
    '/',
    {
      preHandler: [requireAuth, requireOrgContext],
      schema: {
        params: AreaParamsSchema,
        response: {
          200: UnitsListSchema,
          404: ErrorResponseSchema,
        },
      },
    },
    async (request, reply) => {
      const units = await unitService.listUnits(
        request.params.areaId,
        request.params.siteId,
        request.user!.organizationId!,
      );

      if (units === null) {
        return notFound(reply, 'Area not found');
      }

      return units;
    },
  );

  // POST /api/orgs/:organizationId/sites/:siteId/areas/:areaId/units - Create unit
  // Manager+ can create units (they manage equipment)
  app.post(
    '/',
    {
      preHandler: [requireAuth, requireOrgContext, requireRole('manager')],
      schema: {
        params: AreaParamsSchema,
        body: CreateUnitSchema,
        response: {
          201: UnitSchema,
          404: ErrorResponseSchema,
        },
      },
    },
    async (request, reply) => {
      const unit = await unitService.createUnit(
        request.params.areaId,
        request.params.siteId,
        request.user!.organizationId!,
        request.body,
      );

      if (!unit) {
        return notFound(reply, 'Area not found');
      }

      reply.code(201);
      return unit;
    },
  );

  // GET /api/orgs/:organizationId/sites/:siteId/areas/:areaId/units/:unitId - Get unit
  app.get(
    '/:unitId',
    {
      preHandler: [requireAuth, requireOrgContext],
      schema: {
        params: UnitRequiredParamsSchema,
        response: {
          200: UnitSchema,
          404: ErrorResponseSchema,
        },
      },
    },
    async (request, reply) => {
      const unit = await unitService.getUnit(
        request.params.unitId,
        request.params.areaId,
        request.params.siteId,
        request.user!.organizationId!,
      );

      if (!unit) {
        return notFound(reply, 'Unit not found');
      }

      return unit;
    },
  );

  // PUT /api/orgs/:organizationId/sites/:siteId/areas/:areaId/units/:unitId - Update unit
  app.put(
    '/:unitId',
    {
      preHandler: [requireAuth, requireOrgContext, requireRole('manager')],
      schema: {
        params: UnitRequiredParamsSchema,
        body: UpdateUnitSchema,
        response: {
          200: UnitSchema,
          404: ErrorResponseSchema,
        },
      },
    },
    async (request, reply) => {
      const unit = await unitService.updateUnit(
        request.params.unitId,
        request.params.areaId,
        request.params.siteId,
        request.user!.organizationId!,
        request.body,
      );

      if (!unit) {
        return notFound(reply, 'Unit not found');
      }

      return unit;
    },
  );

  // DELETE /api/orgs/:organizationId/sites/:siteId/areas/:areaId/units/:unitId - Delete unit
  app.delete(
    '/:unitId',
    {
      preHandler: [requireAuth, requireOrgContext, requireRole('manager')],
      schema: {
        params: UnitRequiredParamsSchema,
        response: {
          204: { type: 'null' as const, description: 'No content' },
          404: ErrorResponseSchema,
        },
      },
    },
    async (request, reply) => {
      const unit = await unitService.deleteUnit(
        request.params.unitId,
        request.params.areaId,
        request.params.siteId,
        request.user!.organizationId!,
      );

      if (!unit) {
        return notFound(reply, 'Unit not found');
      }

      reply.code(204);
      return;
    },
  );
}
```

Update `backend/src/app.ts` to register unit routes:

1. Add import at top:

```typescript
import unitRoutes from './routes/units.js';
```

2. Register units routes with full hierarchy prefix:

```typescript
// Register API routes
app.register(organizationRoutes, { prefix: '/api/orgs' });
app.register(siteRoutes, { prefix: '/api/orgs/:organizationId/sites' });
app.register(areaRoutes, { prefix: '/api/orgs/:organizationId/sites/:siteId/areas' });
app.register(unitRoutes, { prefix: '/api/orgs/:organizationId/sites/:siteId/areas/:areaId/units' });
```

  </action>
  <verify>Run `cd backend && npx tsc --noEmit` to verify no TypeScript errors. Run `pnpm test` to verify existing tests still pass.</verify>
  <done>Unit routes registered at full hierarchy path with manager+ authorization for write operations.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `pnpm test` passes (existing auth tests still work)
3. Unit service validates full hierarchy (org -> site -> area) before any operation
4. Unit routes use full path /api/orgs/:orgId/sites/:siteId/areas/:areaId/units
5. Create/Update/Delete routes require manager role (not admin - managers handle equipment)
6. tempMin/tempMax validation enforced via Zod refinement
</verification>

<success_criteria>

- GET /api/orgs/:orgId/sites/:siteId/areas/:areaId/units lists area's active units
- POST /api/orgs/:orgId/sites/:siteId/areas/:areaId/units creates unit (manager+ only)
- GET /api/orgs/:orgId/sites/:siteId/areas/:areaId/units/:unitId returns unit details
- PUT /api/orgs/:orgId/sites/:siteId/areas/:areaId/units/:unitId updates unit (manager+ only)
- DELETE /api/orgs/:orgId/sites/:siteId/areas/:areaId/units/:unitId soft-deletes unit (manager+ only)
- Invalid hierarchy returns 404 (area/site/org validation)
- tempMin >= tempMax returns 400 validation error
- TypeScript compiles without errors
  </success_criteria>

<output>
After completion, create `.planning/phases/03-core-api-endpoints/03-05-SUMMARY.md`
</output>
