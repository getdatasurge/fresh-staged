---
phase: 03-core-api-endpoints
plan: 06
type: execute
wave: 3
depends_on: ['03-02', '03-03', '03-04', '03-05']
files_modified:
  - backend/tests/api/organizations.test.ts
  - backend/tests/api/sites.test.ts
  - backend/tests/api/areas.test.ts
  - backend/tests/api/units.test.ts
  - backend/tests/helpers/fixtures.ts
autonomous: true

must_haves:
  truths:
    - 'Organization endpoints return correct data and enforce authorization'
    - 'Site CRUD operations work end-to-end with proper tenant isolation'
    - 'Area CRUD validates site hierarchy correctly'
    - 'Unit CRUD validates full hierarchy (org->site->area) correctly'
    - 'Validation errors return structured 400 responses'
    - 'Cross-org access returns 403'
  artifacts:
    - path: 'backend/tests/api/organizations.test.ts'
      provides: 'Organization endpoint tests'
      contains: "describe('Organizations API'"
    - path: 'backend/tests/api/sites.test.ts'
      provides: 'Site endpoint tests'
      contains: "describe('Sites API'"
    - path: 'backend/tests/api/areas.test.ts'
      provides: 'Area endpoint tests'
      contains: "describe('Areas API'"
    - path: 'backend/tests/api/units.test.ts'
      provides: 'Unit endpoint tests'
      contains: "describe('Units API'"
    - path: 'backend/tests/helpers/fixtures.ts'
      provides: 'Test data fixtures for API tests'
      exports: ['createTestOrg', 'createTestSite', 'createTestArea', 'createTestUnit']
  key_links:
    - from: 'backend/tests/api/*.test.ts'
      to: 'backend/src/app.ts'
      via: 'buildApp import'
      pattern: 'buildApp'
---

<objective>
Create integration tests for all Core API endpoints.

Purpose: Verify that CRUD operations work correctly with proper authorization and tenant isolation.
Output: Comprehensive test suite for organizations, sites, areas, and units APIs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-api-endpoints/03-RESEARCH.md (test patterns)
@backend/tests/helpers/auth.ts (existing test helpers from Phase 2)
@backend/src/app.ts (app factory)
@backend/src/db/client.ts (database client)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test fixtures for database seeding</name>
  <files>backend/tests/helpers/fixtures.ts</files>
  <action>
Create `backend/tests/helpers/fixtures.ts` for creating test data:

```typescript
import { db } from '../../src/db/client.js';
import { organizations, subscriptions } from '../../src/db/schema/tenancy.js';
import { profiles, userRoles } from '../../src/db/schema/users.js';
import { sites, areas, units } from '../../src/db/schema/hierarchy.js';
import type { AppRole } from '../../src/types/auth.js';

// Test organization data
export interface TestOrgData {
  id: string;
  name: string;
  slug: string;
}

// Test user data
export interface TestUserData {
  userId: string; // Stack Auth user ID
  profileId: string;
  role: AppRole;
}

// Create a test organization with subscription
export async function createTestOrg(data: Partial<TestOrgData> = {}): Promise<TestOrgData> {
  const orgId = data.id || crypto.randomUUID();
  const name = data.name || `Test Org ${Date.now()}`;
  const slug = data.slug || `test-org-${Date.now()}`;

  await db.insert(organizations).values({
    id: orgId,
    name,
    slug,
    timezone: 'UTC',
    complianceMode: 'standard',
    sensorLimit: 10,
  });

  // Create subscription for org
  await db.insert(subscriptions).values({
    organizationId: orgId,
    plan: 'starter',
    status: 'active',
  });

  return { id: orgId, name, slug };
}

// Create a test user with role in org
export async function createTestUser(
  organizationId: string,
  role: AppRole = 'viewer',
  userId?: string,
): Promise<TestUserData> {
  const stackAuthUserId = userId || crypto.randomUUID();
  const profileId = crypto.randomUUID();

  // Create profile
  await db.insert(profiles).values({
    id: profileId,
    userId: stackAuthUserId,
    organizationId,
    email: `test-${Date.now()}@example.com`,
    fullName: 'Test User',
  });

  // Create user role
  await db.insert(userRoles).values({
    userId: stackAuthUserId,
    organizationId,
    role,
  });

  return { userId: stackAuthUserId, profileId, role };
}

// Create a test site
export async function createTestSite(
  organizationId: string,
  data: Partial<{ name: string; timezone: string }> = {},
): Promise<{ id: string; name: string }> {
  const name = data.name || `Test Site ${Date.now()}`;

  const [site] = await db
    .insert(sites)
    .values({
      organizationId,
      name,
      timezone: data.timezone || 'UTC',
    })
    .returning();

  return { id: site.id, name: site.name };
}

// Create a test area
export async function createTestArea(
  siteId: string,
  data: Partial<{ name: string; sortOrder: number }> = {},
): Promise<{ id: string; name: string }> {
  const name = data.name || `Test Area ${Date.now()}`;

  const [area] = await db
    .insert(areas)
    .values({
      siteId,
      name,
      sortOrder: data.sortOrder || 0,
    })
    .returning();

  return { id: area.id, name: area.name };
}

// Create a test unit
export async function createTestUnit(
  areaId: string,
  data: Partial<{ name: string; unitType: string; tempMin: number; tempMax: number }> = {},
): Promise<{ id: string; name: string }> {
  const name = data.name || `Test Unit ${Date.now()}`;

  const [unit] = await db
    .insert(units)
    .values({
      areaId,
      name,
      unitType: (data.unitType as any) || 'fridge',
      tempMin: data.tempMin || 320, // 32.0 F
      tempMax: data.tempMax || 400, // 40.0 F
      tempUnit: 'F',
    })
    .returning();

  return { id: unit.id, name: unit.name };
}

// Clean up test data (run after each test)
export async function cleanupTestData(orgIds: string[]): Promise<void> {
  // Cascade delete handles sites, areas, units
  for (const orgId of orgIds) {
    await db.delete(organizations).where((await import('drizzle-orm')).eq(organizations.id, orgId));
  }
}
```

  </action>
  <verify>Run `cd backend && npx tsc --noEmit` to verify no TypeScript errors.</verify>
  <done>Test fixtures created for seeding organizations, users, sites, areas, and units.</done>
</task>

<task type="auto">
  <name>Task 2: Create organization and site API tests</name>
  <files>backend/tests/api/organizations.test.ts, backend/tests/api/sites.test.ts</files>
  <action>
Create `backend/tests/api/organizations.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach, vi } from 'vitest';
import { buildApp } from '../../src/app.js';
import type { FastifyInstance } from 'fastify';
import { createTestOrg, createTestUser, cleanupTestData } from '../helpers/fixtures.js';
import { mockAuthenticatedUser } from '../helpers/auth.js';

describe('Organizations API', () => {
  let app: FastifyInstance;
  let testOrgIds: string[] = [];

  beforeAll(async () => {
    app = buildApp({ logger: false });
    await app.ready();
  });

  afterAll(async () => {
    await cleanupTestData(testOrgIds);
    await app.close();
  });

  afterEach(async () => {
    vi.restoreAllMocks();
  });

  describe('GET /api/orgs/:organizationId', () => {
    it('should return organization for member', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const user = await createTestUser(org.id, 'viewer');
      mockAuthenticatedUser(user.userId, org.id, 'viewer');

      const response = await app.inject({
        method: 'GET',
        url: `/api/orgs/${org.id}`,
        headers: { authorization: 'Bearer test-token' },
      });

      expect(response.statusCode).toBe(200);
      expect(response.json()).toMatchObject({
        id: org.id,
        name: org.name,
        slug: org.slug,
      });
    });

    it('should return 403 for non-member', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const otherOrg = await createTestOrg();
      testOrgIds.push(otherOrg.id);
      const user = await createTestUser(otherOrg.id, 'viewer');
      mockAuthenticatedUser(user.userId, otherOrg.id, 'viewer');

      const response = await app.inject({
        method: 'GET',
        url: `/api/orgs/${org.id}`,
        headers: { authorization: 'Bearer test-token' },
      });

      expect(response.statusCode).toBe(403);
    });
  });

  describe('PUT /api/orgs/:organizationId', () => {
    it('should update organization for owner', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const user = await createTestUser(org.id, 'owner');
      mockAuthenticatedUser(user.userId, org.id, 'owner');

      const response = await app.inject({
        method: 'PUT',
        url: `/api/orgs/${org.id}`,
        headers: { authorization: 'Bearer test-token' },
        payload: { name: 'Updated Name' },
      });

      expect(response.statusCode).toBe(200);
      expect(response.json()).toMatchObject({
        id: org.id,
        name: 'Updated Name',
      });
    });

    it('should return 403 for non-owner', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const user = await createTestUser(org.id, 'admin');
      mockAuthenticatedUser(user.userId, org.id, 'admin');

      const response = await app.inject({
        method: 'PUT',
        url: `/api/orgs/${org.id}`,
        headers: { authorization: 'Bearer test-token' },
        payload: { name: 'Updated Name' },
      });

      expect(response.statusCode).toBe(403);
    });
  });

  describe('GET /api/orgs/:organizationId/members', () => {
    it('should list organization members', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      await createTestUser(org.id, 'owner');
      const user = await createTestUser(org.id, 'viewer');
      mockAuthenticatedUser(user.userId, org.id, 'viewer');

      const response = await app.inject({
        method: 'GET',
        url: `/api/orgs/${org.id}/members`,
        headers: { authorization: 'Bearer test-token' },
      });

      expect(response.statusCode).toBe(200);
      expect(response.json()).toHaveLength(2);
    });
  });
});
```

Create `backend/tests/api/sites.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll, afterEach, vi } from 'vitest';
import { buildApp } from '../../src/app.js';
import type { FastifyInstance } from 'fastify';
import {
  createTestOrg,
  createTestUser,
  createTestSite,
  cleanupTestData,
} from '../helpers/fixtures.js';
import { mockAuthenticatedUser } from '../helpers/auth.js';

describe('Sites API', () => {
  let app: FastifyInstance;
  let testOrgIds: string[] = [];

  beforeAll(async () => {
    app = buildApp({ logger: false });
    await app.ready();
  });

  afterAll(async () => {
    await cleanupTestData(testOrgIds);
    await app.close();
  });

  afterEach(async () => {
    vi.restoreAllMocks();
  });

  describe('GET /api/orgs/:organizationId/sites', () => {
    it('should list sites for organization member', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      await createTestSite(org.id, { name: 'Site 1' });
      await createTestSite(org.id, { name: 'Site 2' });
      const user = await createTestUser(org.id, 'viewer');
      mockAuthenticatedUser(user.userId, org.id, 'viewer');

      const response = await app.inject({
        method: 'GET',
        url: `/api/orgs/${org.id}/sites`,
        headers: { authorization: 'Bearer test-token' },
      });

      expect(response.statusCode).toBe(200);
      expect(response.json()).toHaveLength(2);
    });
  });

  describe('POST /api/orgs/:organizationId/sites', () => {
    it('should create site for admin', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const user = await createTestUser(org.id, 'admin');
      mockAuthenticatedUser(user.userId, org.id, 'admin');

      const response = await app.inject({
        method: 'POST',
        url: `/api/orgs/${org.id}/sites`,
        headers: { authorization: 'Bearer test-token' },
        payload: {
          name: 'New Site',
          city: 'Boston',
          timezone: 'America/New_York',
        },
      });

      expect(response.statusCode).toBe(201);
      expect(response.json()).toMatchObject({
        name: 'New Site',
        city: 'Boston',
        organizationId: org.id,
      });
    });

    it('should return 403 for non-admin', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const user = await createTestUser(org.id, 'manager');
      mockAuthenticatedUser(user.userId, org.id, 'manager');

      const response = await app.inject({
        method: 'POST',
        url: `/api/orgs/${org.id}/sites`,
        headers: { authorization: 'Bearer test-token' },
        payload: { name: 'New Site' },
      });

      expect(response.statusCode).toBe(403);
    });

    it('should return 400 for missing required fields', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const user = await createTestUser(org.id, 'admin');
      mockAuthenticatedUser(user.userId, org.id, 'admin');

      const response = await app.inject({
        method: 'POST',
        url: `/api/orgs/${org.id}/sites`,
        headers: { authorization: 'Bearer test-token' },
        payload: {}, // Missing name
      });

      expect(response.statusCode).toBe(400);
    });
  });

  describe('DELETE /api/orgs/:organizationId/sites/:siteId', () => {
    it('should soft delete site for admin', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const site = await createTestSite(org.id);
      const user = await createTestUser(org.id, 'admin');
      mockAuthenticatedUser(user.userId, org.id, 'admin');

      const response = await app.inject({
        method: 'DELETE',
        url: `/api/orgs/${org.id}/sites/${site.id}`,
        headers: { authorization: 'Bearer test-token' },
      });

      expect(response.statusCode).toBe(204);

      // Verify it's not in list anymore
      const listResponse = await app.inject({
        method: 'GET',
        url: `/api/orgs/${org.id}/sites`,
        headers: { authorization: 'Bearer test-token' },
      });

      expect(listResponse.json().find((s: any) => s.id === site.id)).toBeUndefined();
    });
  });
});
```

  </action>
  <verify>Run `cd backend && pnpm test` to verify tests pass.</verify>
  <done>Organization and site API tests created with authorization and CRUD tests.</done>
</task>

<task type="auto">
  <name>Task 3: Create area and unit API tests</name>
  <files>backend/tests/api/areas.test.ts, backend/tests/api/units.test.ts</files>
  <action>
Create `backend/tests/api/areas.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll, afterEach, vi } from 'vitest';
import { buildApp } from '../../src/app.js';
import type { FastifyInstance } from 'fastify';
import {
  createTestOrg,
  createTestUser,
  createTestSite,
  createTestArea,
  cleanupTestData,
} from '../helpers/fixtures.js';
import { mockAuthenticatedUser } from '../helpers/auth.js';

describe('Areas API', () => {
  let app: FastifyInstance;
  let testOrgIds: string[] = [];

  beforeAll(async () => {
    app = buildApp({ logger: false });
    await app.ready();
  });

  afterAll(async () => {
    await cleanupTestData(testOrgIds);
    await app.close();
  });

  afterEach(async () => {
    vi.restoreAllMocks();
  });

  describe('GET /api/orgs/:orgId/sites/:siteId/areas', () => {
    it('should list areas for site', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const site = await createTestSite(org.id);
      await createTestArea(site.id, { name: 'Area 1' });
      await createTestArea(site.id, { name: 'Area 2' });
      const user = await createTestUser(org.id, 'viewer');
      mockAuthenticatedUser(user.userId, org.id, 'viewer');

      const response = await app.inject({
        method: 'GET',
        url: `/api/orgs/${org.id}/sites/${site.id}/areas`,
        headers: { authorization: 'Bearer test-token' },
      });

      expect(response.statusCode).toBe(200);
      expect(response.json()).toHaveLength(2);
    });

    it('should return 404 for non-existent site', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const user = await createTestUser(org.id, 'viewer');
      mockAuthenticatedUser(user.userId, org.id, 'viewer');
      const fakeSiteId = crypto.randomUUID();

      const response = await app.inject({
        method: 'GET',
        url: `/api/orgs/${org.id}/sites/${fakeSiteId}/areas`,
        headers: { authorization: 'Bearer test-token' },
      });

      expect(response.statusCode).toBe(404);
    });
  });

  describe('POST /api/orgs/:orgId/sites/:siteId/areas', () => {
    it('should create area for admin', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const site = await createTestSite(org.id);
      const user = await createTestUser(org.id, 'admin');
      mockAuthenticatedUser(user.userId, org.id, 'admin');

      const response = await app.inject({
        method: 'POST',
        url: `/api/orgs/${org.id}/sites/${site.id}/areas`,
        headers: { authorization: 'Bearer test-token' },
        payload: {
          name: 'New Area',
          description: 'Test area',
          sortOrder: 1,
        },
      });

      expect(response.statusCode).toBe(201);
      expect(response.json()).toMatchObject({
        name: 'New Area',
        siteId: site.id,
      });
    });

    it('should prevent creating area with site from different org', async () => {
      const org1 = await createTestOrg();
      testOrgIds.push(org1.id);
      const org2 = await createTestOrg();
      testOrgIds.push(org2.id);
      const siteInOrg2 = await createTestSite(org2.id);
      const user = await createTestUser(org1.id, 'admin');
      mockAuthenticatedUser(user.userId, org1.id, 'admin');

      // Try to create area in org1's context but using org2's site
      const response = await app.inject({
        method: 'POST',
        url: `/api/orgs/${org1.id}/sites/${siteInOrg2.id}/areas`,
        headers: { authorization: 'Bearer test-token' },
        payload: { name: 'Sneaky Area' },
      });

      expect(response.statusCode).toBe(404); // Site not found in org1
    });
  });
});
```

Create `backend/tests/api/units.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll, afterEach, vi } from 'vitest';
import { buildApp } from '../../src/app.js';
import type { FastifyInstance } from 'fastify';
import {
  createTestOrg,
  createTestUser,
  createTestSite,
  createTestArea,
  createTestUnit,
  cleanupTestData,
} from '../helpers/fixtures.js';
import { mockAuthenticatedUser } from '../helpers/auth.js';

describe('Units API', () => {
  let app: FastifyInstance;
  let testOrgIds: string[] = [];

  beforeAll(async () => {
    app = buildApp({ logger: false });
    await app.ready();
  });

  afterAll(async () => {
    await cleanupTestData(testOrgIds);
    await app.close();
  });

  afterEach(async () => {
    vi.restoreAllMocks();
  });

  describe('GET /api/orgs/:orgId/sites/:siteId/areas/:areaId/units', () => {
    it('should list units for area', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const site = await createTestSite(org.id);
      const area = await createTestArea(site.id);
      await createTestUnit(area.id, { name: 'Fridge 1' });
      await createTestUnit(area.id, { name: 'Freezer 1', unitType: 'freezer' });
      const user = await createTestUser(org.id, 'viewer');
      mockAuthenticatedUser(user.userId, org.id, 'viewer');

      const response = await app.inject({
        method: 'GET',
        url: `/api/orgs/${org.id}/sites/${site.id}/areas/${area.id}/units`,
        headers: { authorization: 'Bearer test-token' },
      });

      expect(response.statusCode).toBe(200);
      expect(response.json()).toHaveLength(2);
    });
  });

  describe('POST /api/orgs/:orgId/sites/:siteId/areas/:areaId/units', () => {
    it('should create unit for manager', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const site = await createTestSite(org.id);
      const area = await createTestArea(site.id);
      const user = await createTestUser(org.id, 'manager');
      mockAuthenticatedUser(user.userId, org.id, 'manager');

      const response = await app.inject({
        method: 'POST',
        url: `/api/orgs/${org.id}/sites/${site.id}/areas/${area.id}/units`,
        headers: { authorization: 'Bearer test-token' },
        payload: {
          name: 'New Fridge',
          unitType: 'fridge',
          tempMin: 320,
          tempMax: 400,
          tempUnit: 'F',
        },
      });

      expect(response.statusCode).toBe(201);
      expect(response.json()).toMatchObject({
        name: 'New Fridge',
        unitType: 'fridge',
        areaId: area.id,
      });
    });

    it('should return 403 for staff (below manager)', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const site = await createTestSite(org.id);
      const area = await createTestArea(site.id);
      const user = await createTestUser(org.id, 'staff');
      mockAuthenticatedUser(user.userId, org.id, 'staff');

      const response = await app.inject({
        method: 'POST',
        url: `/api/orgs/${org.id}/sites/${site.id}/areas/${area.id}/units`,
        headers: { authorization: 'Bearer test-token' },
        payload: {
          name: 'New Fridge',
          unitType: 'fridge',
          tempMin: 320,
          tempMax: 400,
        },
      });

      expect(response.statusCode).toBe(403);
    });

    it('should validate tempMin < tempMax', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const site = await createTestSite(org.id);
      const area = await createTestArea(site.id);
      const user = await createTestUser(org.id, 'manager');
      mockAuthenticatedUser(user.userId, org.id, 'manager');

      const response = await app.inject({
        method: 'POST',
        url: `/api/orgs/${org.id}/sites/${site.id}/areas/${area.id}/units`,
        headers: { authorization: 'Bearer test-token' },
        payload: {
          name: 'Invalid Fridge',
          unitType: 'fridge',
          tempMin: 500, // Higher than max
          tempMax: 400,
        },
      });

      expect(response.statusCode).toBe(400);
    });
  });

  describe('Hierarchy validation', () => {
    it('should return 404 when area is not in site', async () => {
      const org = await createTestOrg();
      testOrgIds.push(org.id);
      const site1 = await createTestSite(org.id);
      const site2 = await createTestSite(org.id);
      const areaInSite2 = await createTestArea(site2.id);
      const user = await createTestUser(org.id, 'viewer');
      mockAuthenticatedUser(user.userId, org.id, 'viewer');

      // Try to list units in site1 but with area from site2
      const response = await app.inject({
        method: 'GET',
        url: `/api/orgs/${org.id}/sites/${site1.id}/areas/${areaInSite2.id}/units`,
        headers: { authorization: 'Bearer test-token' },
      });

      expect(response.statusCode).toBe(404);
    });

    it('should return 404 when site is not in org', async () => {
      const org1 = await createTestOrg();
      testOrgIds.push(org1.id);
      const org2 = await createTestOrg();
      testOrgIds.push(org2.id);
      const siteInOrg2 = await createTestSite(org2.id);
      const areaInOrg2 = await createTestArea(siteInOrg2.id);
      const user = await createTestUser(org1.id, 'viewer');
      mockAuthenticatedUser(user.userId, org1.id, 'viewer');

      const response = await app.inject({
        method: 'GET',
        url: `/api/orgs/${org1.id}/sites/${siteInOrg2.id}/areas/${areaInOrg2.id}/units`,
        headers: { authorization: 'Bearer test-token' },
      });

      expect(response.statusCode).toBe(404);
    });
  });
});
```

  </action>
  <verify>Run `cd backend && pnpm test` to verify all tests pass.</verify>
  <done>Area and unit API tests created with hierarchy validation and authorization tests.</done>
</task>

</tasks>

<verification>
1. `pnpm test` runs all tests and they pass
2. Organization tests cover GET, PUT, members list
3. Site tests cover CRUD and authorization
4. Area tests cover CRUD and hierarchy validation
5. Unit tests cover CRUD, role requirements (manager+), and full hierarchy validation
6. Cross-org access is blocked at all levels
</verification>

<success_criteria>

- All API tests pass
- Authorization is verified at each endpoint (viewer, staff, manager, admin, owner)
- Hierarchy validation is tested (area must be in site, site must be in org)
- Validation errors return 400 with structured response
- Non-existent resources return 404
- Cross-org access returns 403
  </success_criteria>

<output>
After completion, create `.planning/phases/03-core-api-endpoints/03-06-SUMMARY.md`
</output>
