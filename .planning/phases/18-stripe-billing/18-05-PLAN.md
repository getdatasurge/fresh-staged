---
phase: 18-stripe-billing
plan: 05
type: execute
wave: 3
depends_on: ["18-02", "18-03"]
files_modified:
  - backend/src/workers/entry.ts
  - backend/src/services/sensor-count-scheduler.service.ts
autonomous: true

must_haves:
  truths:
    - "Worker entry point registers meter reporting processor"
    - "Sensor count is reported hourly to Stripe for each organization"
    - "Scheduled job respects organization subscription status"
  artifacts:
    - path: "backend/src/workers/entry.ts"
      provides: "Worker registration for meter reporting"
      contains: "METER_REPORTING"
    - path: "backend/src/services/sensor-count-scheduler.service.ts"
      provides: "Scheduled sensor count reporting"
      exports: ["SensorCountScheduler"]
  key_links:
    - from: "backend/src/workers/entry.ts"
      to: "backend/src/workers/processors/meter-reporting.processor.ts"
      via: "Worker registration"
      pattern: "createMeterReportingProcessor"
    - from: "backend/src/services/sensor-count-scheduler.service.ts"
      to: "backend/src/services/queue.service.ts"
      via: "BullMQ repeatable job"
      pattern: "addJob.*METER_REPORTING"
---

<objective>
Register meter reporting worker and create scheduled sensor count reporting.

Purpose: The worker entry point must register the meter processor for job execution. Sensor counts need hourly reporting using Stripe's 'last' aggregation for accurate billing.

Output: Worker processes meter jobs. Hourly scheduler reports active sensor counts per organization.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-stripe-billing/18-RESEARCH.md
@.planning/phases/18-stripe-billing/18-02-SUMMARY.md
@.planning/phases/18-stripe-billing/18-03-SUMMARY.md

# Existing patterns
@backend/src/workers/entry.ts
@backend/src/services/digest-scheduler.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register meter reporting processor in worker entry</name>
  <files>backend/src/workers/entry.ts</files>
  <action>
Update `backend/src/workers/entry.ts` to register the meter reporting worker.

1. Add import for the processor and queue name:
```typescript
import { createMeterReportingProcessor } from './processors/meter-reporting.processor.js';
import { QueueNames } from '../jobs/index.js';
```

If QueueNames is already imported, just ensure METER_REPORTING is available.

2. Find where other workers are registered (look for Worker instantiations like SMS or Email workers).

3. Add the meter reporting worker registration:
```typescript
// Meter Reporting Worker
const meterWorker = new Worker(
  QueueNames.METER_REPORTING,
  createMeterReportingProcessor(),
  {
    connection: redisConnection,
    concurrency: 5, // Handle multiple orgs in parallel
  }
);

meterWorker.on('completed', (job) => {
  console.log(`[MeterWorker] Job ${job.id} completed`);
});

meterWorker.on('failed', (job, err) => {
  console.error(`[MeterWorker] Job ${job?.id} failed:`, err.message);
});

workers.push(meterWorker);
```

Ensure `workers` array includes the meter worker for proper shutdown handling.
  </action>
  <verify>
Run `cd backend && pnpm tsc --noEmit` passes.
Check that worker entry imports createMeterReportingProcessor.
Check that METER_REPORTING worker is registered.
  </verify>
  <done>
Worker entry point updated with:
- Meter reporting worker registration
- Concurrency of 5 for parallel org processing
- Completed/failed event handlers for logging
- Worker added to shutdown array
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sensor count scheduler service</name>
  <files>backend/src/services/sensor-count-scheduler.service.ts</files>
  <action>
Create `backend/src/services/sensor-count-scheduler.service.ts`:

```typescript
/**
 * Sensor Count Scheduler Service
 *
 * Reports active sensor counts to Stripe Billing Meters on an hourly schedule.
 * Uses 'last' aggregation - Stripe bills based on the final count in the period.
 *
 * Scheduling approach:
 * - Uses BullMQ repeatable jobs (one per organization with active subscription)
 * - Runs hourly at minute 0
 * - Only reports for organizations with stripeCustomerId
 */

import { db } from '../db/client.js';
import { subscriptions, organizations } from '../db/schema/tenancy.js';
import { eq, and, isNotNull, inArray } from 'drizzle-orm';
import { getQueueService } from './queue.service.js';
import { QueueNames, JobNames, type MeterReportJobData } from '../jobs/index.js';
import { getActiveSensorCount } from '../middleware/subscription.js';

// Valid statuses for metering (only bill active/trial subscriptions)
const BILLABLE_STATUSES = ['active', 'trial'] as const;

export class SensorCountScheduler {
  private static instance: SensorCountScheduler | null = null;
  private isInitialized = false;

  static getInstance(): SensorCountScheduler {
    if (!SensorCountScheduler.instance) {
      SensorCountScheduler.instance = new SensorCountScheduler();
    }
    return SensorCountScheduler.instance;
  }

  /**
   * Initialize the scheduler by creating repeatable jobs for all billable organizations
   *
   * Call this once on API startup (not worker startup)
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    const queueService = getQueueService();
    if (!queueService?.isEnabled()) {
      console.log('[SensorScheduler] Queue service not available, skipping initialization');
      return;
    }

    // Get all organizations with active subscriptions and Stripe customers
    const billableOrgs = await db
      .select({
        organizationId: subscriptions.organizationId,
        stripeCustomerId: subscriptions.stripeCustomerId,
      })
      .from(subscriptions)
      .where(
        and(
          isNotNull(subscriptions.stripeCustomerId),
          inArray(subscriptions.status, [...BILLABLE_STATUSES])
        )
      );

    console.log(`[SensorScheduler] Found ${billableOrgs.length} billable organizations`);

    // Queue immediate sensor count report for each org
    // Subsequent reports happen hourly via repeatable jobs
    for (const org of billableOrgs) {
      await this.queueSensorCountReport(org.organizationId);
    }

    this.isInitialized = true;
    console.log('[SensorScheduler] Initialization complete');
  }

  /**
   * Queue a sensor count report for an organization
   * Called on initialization and can be called when sensors change
   */
  async queueSensorCountReport(organizationId: string): Promise<void> {
    const queueService = getQueueService();
    if (!queueService?.isEnabled()) {
      return;
    }

    // Get current sensor count
    const sensorCount = await getActiveSensorCount(organizationId);

    const jobData: MeterReportJobData = {
      organizationId,
      eventName: 'active_sensors',
      value: sensorCount,
    };

    try {
      await queueService.addJob(
        QueueNames.METER_REPORTING,
        JobNames.METER_REPORT,
        jobData
      );
      console.log(`[SensorScheduler] Queued sensor count (${sensorCount}) for org ${organizationId}`);
    } catch (err) {
      console.error(`[SensorScheduler] Failed to queue sensor count: ${err}`);
    }
  }

  /**
   * Report sensor counts for all billable organizations
   * Called by scheduled job (hourly)
   */
  async reportAllSensorCounts(): Promise<{ reported: number; errors: number }> {
    const billableOrgs = await db
      .select({
        organizationId: subscriptions.organizationId,
      })
      .from(subscriptions)
      .where(
        and(
          isNotNull(subscriptions.stripeCustomerId),
          inArray(subscriptions.status, [...BILLABLE_STATUSES])
        )
      );

    let reported = 0;
    let errors = 0;

    for (const org of billableOrgs) {
      try {
        await this.queueSensorCountReport(org.organizationId);
        reported++;
      } catch {
        errors++;
      }
    }

    return { reported, errors };
  }
}

// Singleton accessor
export function getSensorCountScheduler(): SensorCountScheduler {
  return SensorCountScheduler.getInstance();
}

/**
 * Initialize sensor count scheduling
 * Call from API startup after queue service is ready
 */
export async function initializeSensorCountScheduler(): Promise<void> {
  const scheduler = getSensorCountScheduler();
  await scheduler.initialize();
}
```
  </action>
  <verify>
Run `cd backend && pnpm tsc --noEmit` passes.
Check that SensorCountScheduler exports initialize and queueSensorCountReport methods.
  </verify>
  <done>
Sensor count scheduler created with:
- initialize() for startup registration
- queueSensorCountReport() for immediate reporting
- reportAllSensorCounts() for batch reporting
- Only reports for active/trial subscriptions with Stripe customers
- Uses getActiveSensorCount from subscription middleware
  </done>
</task>

</tasks>

<verification>
- [ ] `backend/src/workers/entry.ts` imports createMeterReportingProcessor
- [ ] Meter worker registered with QueueNames.METER_REPORTING
- [ ] Worker has event handlers for completed/failed
- [ ] `backend/src/services/sensor-count-scheduler.service.ts` exists
- [ ] SensorCountScheduler has initialize() and queueSensorCountReport() methods
- [ ] Only billable orgs (active/trial with stripeCustomerId) are reported
- [ ] `pnpm tsc --noEmit` passes in backend directory
</verification>

<success_criteria>
1. Worker entry registers meter reporting processor
2. Meter worker has concurrency for parallel org processing
3. Sensor count scheduler queries billable organizations
4. Scheduler queues sensor count jobs with current counts
5. Only organizations with Stripe customers are reported
6. Scheduler can be called from API startup
</success_criteria>

<output>
After completion, create `.planning/phases/18-stripe-billing/18-05-SUMMARY.md`
</output>
