---
phase: 18-stripe-billing
plan: 05
type: execute
wave: 3
depends_on: ["18-02", "18-03", "18-04"]
files_modified:
  - backend/src/workers/entry.ts
  - backend/src/services/sensor-count-scheduler.service.ts
  - backend/src/plugins/queue.plugin.ts
  - backend/src/jobs/index.ts
autonomous: true

must_haves:
  truths:
    - "Worker entry point registers meter reporting processor"
    - "Sensor count is reported hourly to Stripe for each organization"
    - "Scheduled job respects organization subscription status"
    - "Scheduler initializes automatically on API startup"
  artifacts:
    - path: "backend/src/workers/entry.ts"
      provides: "Worker registration for meter reporting"
      contains: "METER_REPORTING"
    - path: "backend/src/services/sensor-count-scheduler.service.ts"
      provides: "Scheduled sensor count reporting with hourly cron"
      exports: ["SensorCountScheduler", "initializeSensorCountScheduler"]
    - path: "backend/src/plugins/queue.plugin.ts"
      provides: "Scheduler initialization on startup"
      contains: "initializeSensorCountScheduler"
  key_links:
    - from: "backend/src/workers/entry.ts"
      to: "backend/src/workers/processors/meter-reporting.processor.ts"
      via: "Worker registration"
      pattern: "createMeterReportingProcessor"
    - from: "backend/src/services/sensor-count-scheduler.service.ts"
      to: "backend/src/services/queue.service.ts"
      via: "BullMQ repeatable job with cron"
      pattern: "repeat.*cron.*0 \\* \\* \\* \\*"
    - from: "backend/src/plugins/queue.plugin.ts"
      to: "backend/src/services/sensor-count-scheduler.service.ts"
      via: "Startup initialization"
      pattern: "initializeSensorCountScheduler"
---

<objective>
Register meter reporting worker and create scheduled sensor count reporting with hourly BullMQ repeatable jobs.

Purpose: The worker entry point must register the meter processor for job execution. Sensor counts need hourly reporting using Stripe's 'last' aggregation for accurate billing. The scheduler must be wired to API startup.

Output: Worker processes meter jobs. Hourly scheduler reports active sensor counts per organization. Scheduler auto-initializes on API startup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-stripe-billing/18-RESEARCH.md
@.planning/phases/18-stripe-billing/18-02-SUMMARY.md
@.planning/phases/18-stripe-billing/18-03-SUMMARY.md
@.planning/phases/18-stripe-billing/18-04-SUMMARY.md

# Existing patterns
@backend/src/workers/entry.ts
@backend/src/plugins/queue.plugin.ts
@backend/src/services/queue.service.ts
@backend/src/jobs/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register meter reporting processor in worker entry</name>
  <files>backend/src/workers/entry.ts</files>
  <action>
Update `backend/src/workers/entry.ts` to register the meter reporting worker.

1. Add import for the processor and queue name:
```typescript
import { createMeterReportingProcessor } from './processors/meter-reporting.processor.js';
import { QueueNames } from '../jobs/index.js';
```

If QueueNames is already imported, just ensure METER_REPORTING is available.

2. Find where other workers are registered (look for Worker instantiations like SMS or Email workers).

3. Add the meter reporting worker registration:
```typescript
// Meter Reporting Worker
const meterWorker = new Worker(
  QueueNames.METER_REPORTING,
  createMeterReportingProcessor(),
  {
    connection: redisConnection,
    concurrency: 5, // Handle multiple orgs in parallel
  }
);

meterWorker.on('completed', (job) => {
  console.log(`[MeterWorker] Job ${job.id} completed`);
});

meterWorker.on('failed', (job, err) => {
  console.error(`[MeterWorker] Job ${job?.id} failed:`, err.message);
});

workers.push(meterWorker);
```

Ensure `workers` array includes the meter worker for proper shutdown handling.
  </action>
  <verify>
Run `cd backend && pnpm tsc --noEmit` passes.
Check that worker entry imports createMeterReportingProcessor.
Check that METER_REPORTING worker is registered.
  </verify>
  <done>
Worker entry point updated with:
- Meter reporting worker registration
- Concurrency of 5 for parallel org processing
- Completed/failed event handlers for logging
- Worker added to shutdown array
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SENSOR_COUNT_SCHEDULER job name constant</name>
  <files>backend/src/jobs/index.ts</files>
  <action>
Update `backend/src/jobs/index.ts` to add the scheduler job name constant.

Note: MeterReportJobData, METER_REPORTING queue, and METER_REPORT job name are already created by Plan 18-01. The METER_REPORTING queue is registered in queue.service.ts by Plan 18-04. This task ONLY adds the scheduler job name.

Add SENSOR_COUNT_SCHEDULER to JobNames (find the existing JobNames object):
```typescript
export const JobNames = {
  SMS_SEND: 'sms:send',
  EMAIL_DIGEST: 'email:digest',
  METER_REPORT: 'meter:report',
  SENSOR_COUNT_SCHEDULER: 'meter:sensor-count-scheduler',  // Add this line
} as const;
```

This job name is used by the sensor-count-scheduler.service.ts to create repeatable jobs for hourly sensor count reporting.
  </action>
  <verify>
Run `cd backend && pnpm tsc --noEmit` passes.
Grep for SENSOR_COUNT_SCHEDULER in jobs/index.ts.
  </verify>
  <done>
JobNames updated with SENSOR_COUNT_SCHEDULER constant for the repeatable scheduler job.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create sensor count scheduler service with BullMQ repeatable job</name>
  <files>backend/src/services/sensor-count-scheduler.service.ts</files>
  <action>
Create `backend/src/services/sensor-count-scheduler.service.ts`:

```typescript
/**
 * Sensor Count Scheduler Service
 *
 * Reports active sensor counts to Stripe Billing Meters on an hourly schedule.
 * Uses 'last' aggregation - Stripe bills based on the final count in the period.
 *
 * Scheduling approach:
 * - Uses BullMQ repeatable job with cron '0 * * * *' (hourly at minute 0)
 * - Single scheduler job that processes all billable organizations
 * - Only reports for organizations with stripeCustomerId and active/trial status
 */

import { db } from '../db/client.js';
import { subscriptions } from '../db/schema/tenancy.js';
import { and, isNotNull, inArray } from 'drizzle-orm';
import { getQueueService } from './queue.service.js';
import { QueueNames, JobNames, type MeterReportJobData } from '../jobs/index.js';
import { getActiveSensorCount } from '../middleware/subscription.js';

// Valid statuses for metering (only bill active/trial subscriptions)
const BILLABLE_STATUSES = ['active', 'trial'] as const;

// Cron expression for hourly at minute 0
const HOURLY_CRON = '0 * * * *';

export class SensorCountScheduler {
  private static instance: SensorCountScheduler | null = null;
  private isInitialized = false;

  static getInstance(): SensorCountScheduler {
    if (!SensorCountScheduler.instance) {
      SensorCountScheduler.instance = new SensorCountScheduler();
    }
    return SensorCountScheduler.instance;
  }

  /**
   * Initialize the scheduler by creating a repeatable job for hourly sensor count reporting
   *
   * Call this once on API startup (after queue service is ready)
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    const queueService = getQueueService();
    if (!queueService?.isEnabled()) {
      console.log('[SensorScheduler] Queue service not available, skipping initialization');
      return;
    }

    const queue = queueService.getQueue(QueueNames.METER_REPORTING);
    if (!queue) {
      console.log('[SensorScheduler] METER_REPORTING queue not available, skipping initialization');
      return;
    }

    try {
      // Remove any existing repeatable job with the same name to avoid duplicates
      const repeatableJobs = await queue.getRepeatableJobs();
      for (const job of repeatableJobs) {
        if (job.name === JobNames.SENSOR_COUNT_SCHEDULER) {
          await queue.removeRepeatableByKey(job.key);
          console.log('[SensorScheduler] Removed existing repeatable job');
        }
      }

      // Create the hourly repeatable job
      // This job triggers reportAllSensorCounts() via the processor
      await queue.add(
        JobNames.SENSOR_COUNT_SCHEDULER,
        { organizationId: 'system', eventName: 'scheduler', value: 0 }, // Placeholder data
        {
          repeat: {
            pattern: HOURLY_CRON, // '0 * * * *' = every hour at minute 0
          },
          removeOnComplete: 10,
          removeOnFail: 50,
        }
      );

      this.isInitialized = true;
      console.log(`[SensorScheduler] Hourly repeatable job created with cron: ${HOURLY_CRON}`);

      // Run initial report on startup
      await this.reportAllSensorCounts();
      console.log('[SensorScheduler] Initial sensor count report completed');
    } catch (err) {
      console.error('[SensorScheduler] Failed to initialize:', err);
    }
  }

  /**
   * Queue a sensor count report for a specific organization
   * Called when sensor count changes (add/remove/update sensor)
   */
  async queueSensorCountReport(organizationId: string): Promise<void> {
    const queueService = getQueueService();
    if (!queueService?.isEnabled()) {
      return;
    }

    // Get current sensor count
    const sensorCount = await getActiveSensorCount(organizationId);

    const jobData: MeterReportJobData = {
      organizationId,
      eventName: 'active_sensors',
      value: sensorCount,
    };

    try {
      await queueService.addJob(
        QueueNames.METER_REPORTING,
        JobNames.METER_REPORT,
        jobData
      );
      console.log(`[SensorScheduler] Queued sensor count (${sensorCount}) for org ${organizationId}`);
    } catch (err) {
      console.error(`[SensorScheduler] Failed to queue sensor count: ${err}`);
    }
  }

  /**
   * Report sensor counts for all billable organizations
   * Called by the hourly repeatable job processor
   */
  async reportAllSensorCounts(): Promise<{ reported: number; errors: number }> {
    const billableOrgs = await db
      .select({
        organizationId: subscriptions.organizationId,
      })
      .from(subscriptions)
      .where(
        and(
          isNotNull(subscriptions.stripeCustomerId),
          inArray(subscriptions.status, [...BILLABLE_STATUSES])
        )
      );

    console.log(`[SensorScheduler] Processing ${billableOrgs.length} billable organizations`);

    let reported = 0;
    let errors = 0;

    for (const org of billableOrgs) {
      try {
        await this.queueSensorCountReport(org.organizationId);
        reported++;
      } catch {
        errors++;
      }
    }

    console.log(`[SensorScheduler] Queued ${reported} reports, ${errors} errors`);
    return { reported, errors };
  }
}

// Singleton accessor
export function getSensorCountScheduler(): SensorCountScheduler {
  return SensorCountScheduler.getInstance();
}

/**
 * Initialize sensor count scheduling
 * Call from queue.plugin.ts after queue service is ready
 */
export async function initializeSensorCountScheduler(): Promise<void> {
  const scheduler = getSensorCountScheduler();
  await scheduler.initialize();
}
```
  </action>
  <verify>
Run `cd backend && pnpm tsc --noEmit` passes.
Grep for "repeat.*pattern" in sensor-count-scheduler.service.ts confirms cron setup.
Grep for "0 \\* \\* \\* \\*" confirms hourly cron.
Check that initializeSensorCountScheduler is exported.
  </verify>
  <done>
Sensor count scheduler created with:
- BullMQ repeatable job with cron '0 * * * *' (hourly at minute 0)
- Removes existing repeatable job before creating new one (avoids duplicates)
- reportAllSensorCounts() for batch reporting all billable orgs
- queueSensorCountReport() for on-demand single org reporting
- Initial report on startup
- Only reports for active/trial subscriptions with Stripe customers
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire scheduler initialization to API startup</name>
  <files>backend/src/plugins/queue.plugin.ts</files>
  <action>
Update `backend/src/plugins/queue.plugin.ts` to initialize the sensor count scheduler after queue service is ready.

1. Add import at the top:
```typescript
import { initializeSensorCountScheduler } from '../services/sensor-count-scheduler.service.js';
import { setQueueService } from '../services/queue.service.js';
```

2. After `await queueService.initialize();` and before Bull Board setup, add:
```typescript
// Set singleton for services that need queue access
setQueueService(queueService);

// Initialize sensor count scheduler (hourly Stripe meter reporting)
if (queueService.isRedisEnabled()) {
  await initializeSensorCountScheduler();
  fastify.log.info('[Queue Plugin] Sensor count scheduler initialized');
}
```

This ensures:
- Queue service is initialized and Redis connected
- Singleton is set so scheduler can access queues
- Scheduler creates repeatable job for hourly reporting
- Scheduler runs initial sensor count report
  </action>
  <verify>
Run `cd backend && pnpm tsc --noEmit` passes.
Grep for "initializeSensorCountScheduler" in queue.plugin.ts.
Grep for "setQueueService" in queue.plugin.ts.
  </verify>
  <done>
Queue plugin updated with:
- Import of initializeSensorCountScheduler
- Import of setQueueService
- setQueueService(queueService) called after initialize
- initializeSensorCountScheduler() called when Redis is enabled
- Startup log message confirming initialization
  </done>
</task>

</tasks>

<verification>
- [ ] `backend/src/workers/entry.ts` imports createMeterReportingProcessor
- [ ] Meter worker registered with QueueNames.METER_REPORTING
- [ ] Worker has event handlers for completed/failed
- [ ] `backend/src/jobs/index.ts` has SENSOR_COUNT_SCHEDULER job name constant
- [ ] `backend/src/services/sensor-count-scheduler.service.ts` exists
- [ ] Scheduler has BullMQ repeatable job with cron '0 * * * *'
- [ ] `backend/src/plugins/queue.plugin.ts` calls initializeSensorCountScheduler()
- [ ] `pnpm tsc --noEmit` passes in backend directory
</verification>

<success_criteria>
1. Worker entry registers meter reporting processor
2. Meter worker has concurrency for parallel org processing
3. SENSOR_COUNT_SCHEDULER job name added to JobNames
4. Sensor count scheduler creates BullMQ repeatable job with hourly cron
5. Scheduler is initialized on API startup via queue.plugin.ts
6. Only organizations with Stripe customers are reported
7. Initial sensor count report runs on startup
</success_criteria>

<output>
After completion, create `.planning/phases/18-stripe-billing/18-05-SUMMARY.md`
</output>
