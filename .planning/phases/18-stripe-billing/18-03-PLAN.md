---
phase: 18-stripe-billing
plan: 03
type: execute
wave: 2
depends_on: ['18-01']
files_modified:
  - backend/src/middleware/subscription.ts
  - backend/src/routes/devices.ts
autonomous: true

must_haves:
  truths:
    - 'Users without active subscription cannot access protected routes'
    - 'Users at sensor limit cannot add new sensors'
    - 'Trial and active subscriptions are allowed access'
  artifacts:
    - path: 'backend/src/middleware/subscription.ts'
      provides: 'Subscription enforcement middleware'
      exports: ['requireActiveSubscription', 'requireSensorCapacity']
  key_links:
    - from: 'backend/src/middleware/subscription.ts'
      to: 'backend/src/db/schema/tenancy.ts'
      via: 'subscriptions table query'
      pattern: "from\\(subscriptions\\)"
    - from: 'backend/src/routes/devices.ts'
      to: 'backend/src/middleware/subscription.ts'
      via: 'preHandler hook'
      pattern: 'requireSensorCapacity'

user_setup:
  - service: stripe
    why: 'Usage-based billing configuration'
    dashboard_config:
      - task: "Create 'active_sensors' meter with 'last' aggregation"
        location: 'Stripe Dashboard -> Billing -> Meters'
      - task: "Create 'temperature_readings' meter with 'sum' aggregation"
        location: 'Stripe Dashboard -> Billing -> Meters'
---

<objective>
Create subscription enforcement middleware for access control and sensor limits.

Purpose: Subscription status must be enforced server-side to prevent unauthorized access after cancellation and to enforce plan-based sensor limits. This follows the existing RBAC middleware pattern.

Output: requireActiveSubscription and requireSensorCapacity middleware ready for route protection.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-stripe-billing/18-RESEARCH.md

# Pattern to follow

@backend/src/middleware/rbac.ts
@backend/src/services/checkout.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create subscription enforcement middleware</name>
  <files>backend/src/middleware/subscription.ts</files>
  <action>
Create `backend/src/middleware/subscription.ts`:

```typescript
/**
 * Subscription Enforcement Middleware
 *
 * Enforces subscription status and plan limits:
 * - requireActiveSubscription: Blocks access without active/trial subscription
 * - requireSensorCapacity: Prevents adding sensors beyond plan limit
 *
 * Follows the same pattern as rbac.ts middleware.
 */

import type { FastifyRequest, FastifyReply } from 'fastify';
import type { preHandlerHookHandler } from 'fastify';
import { db } from '../db/client.js';
import { subscriptions, organizations } from '../db/schema/tenancy.js';
import { devices } from '../db/schema/devices.js';
import { units } from '../db/schema/hierarchy.js';
import { areas } from '../db/schema/hierarchy.js';
import { sites } from '../db/schema/hierarchy.js';
import { eq, and, sql } from 'drizzle-orm';

// Valid subscription statuses that allow access
const ACTIVE_STATUSES = ['active', 'trial'] as const;

/**
 * Require an active or trial subscription to access route
 *
 * Returns 403 SUBSCRIPTION_REQUIRED if:
 * - No subscription exists for the organization
 * - Subscription status is not 'active' or 'trial'
 *
 * @example
 * fastify.get('/protected',
 *   { preHandler: [requireActiveSubscription] },
 *   async (request, reply) => { ... }
 * )
 */
export const requireActiveSubscription: preHandlerHookHandler = async function (
  request: FastifyRequest,
  reply: FastifyReply,
): Promise<void> {
  // Check authentication
  if (!request.user) {
    return reply.status(401).send({
      error: {
        code: 'UNAUTHORIZED',
        message: 'Authentication required',
      },
    });
  }

  const organizationId = request.user.organizationId;
  if (!organizationId) {
    return reply.status(403).send({
      error: {
        code: 'NO_ORGANIZATION',
        message: 'Organization context required',
      },
    });
  }

  // Fetch subscription status
  const [sub] = await db
    .select({
      status: subscriptions.status,
      plan: subscriptions.plan,
    })
    .from(subscriptions)
    .where(eq(subscriptions.organizationId, organizationId))
    .limit(1);

  // Check subscription exists and is active
  if (!sub || !ACTIVE_STATUSES.includes(sub.status as (typeof ACTIVE_STATUSES)[number])) {
    return reply.status(403).send({
      error: {
        code: 'SUBSCRIPTION_REQUIRED',
        message: 'Active subscription required to access this feature',
        status: sub?.status || 'none',
      },
    });
  }

  // Subscription check passed - continue to route handler
};

/**
 * Require capacity to add more sensors
 *
 * Returns 403 SENSOR_LIMIT_REACHED if:
 * - Current active sensor count >= organization's sensor limit
 *
 * Use on routes that create new devices/sensors.
 *
 * @example
 * fastify.post('/devices',
 *   { preHandler: [requireActiveSubscription, requireSensorCapacity] },
 *   async (request, reply) => { ... }
 * )
 */
export const requireSensorCapacity: preHandlerHookHandler = async function (
  request: FastifyRequest,
  reply: FastifyReply,
): Promise<void> {
  // Check authentication
  if (!request.user) {
    return reply.status(401).send({
      error: {
        code: 'UNAUTHORIZED',
        message: 'Authentication required',
      },
    });
  }

  const organizationId = request.user.organizationId;
  if (!organizationId) {
    return reply.status(403).send({
      error: {
        code: 'NO_ORGANIZATION',
        message: 'Organization context required',
      },
    });
  }

  // Get organization's sensor limit
  const [org] = await db
    .select({ sensorLimit: organizations.sensorLimit })
    .from(organizations)
    .where(eq(organizations.id, organizationId))
    .limit(1);

  if (!org) {
    return reply.status(404).send({
      error: {
        code: 'NOT_FOUND',
        message: 'Organization not found',
      },
    });
  }

  // Count active devices through hierarchy:
  // devices -> units -> areas -> sites -> organizations
  const countResult = await db
    .select({ count: sql<number>`count(*)` })
    .from(devices)
    .innerJoin(units, eq(devices.unitId, units.id))
    .innerJoin(areas, eq(units.areaId, areas.id))
    .innerJoin(sites, eq(areas.siteId, sites.id))
    .where(and(eq(sites.organizationId, organizationId), eq(devices.isActive, true)));

  const currentCount = Number(countResult[0]?.count ?? 0);
  const limit = org.sensorLimit;

  if (currentCount >= limit) {
    return reply.status(403).send({
      error: {
        code: 'SENSOR_LIMIT_REACHED',
        message: `Sensor limit (${limit}) reached. Upgrade your plan to add more sensors.`,
        currentCount,
        limit,
      },
    });
  }

  // Capacity check passed - continue to route handler
};

/**
 * Get current sensor count for an organization
 * Utility function for use in other services
 */
export async function getActiveSensorCount(organizationId: string): Promise<number> {
  const countResult = await db
    .select({ count: sql<number>`count(*)` })
    .from(devices)
    .innerJoin(units, eq(devices.unitId, units.id))
    .innerJoin(areas, eq(units.areaId, areas.id))
    .innerJoin(sites, eq(areas.siteId, sites.id))
    .where(and(eq(sites.organizationId, organizationId), eq(devices.isActive, true)));

  return Number(countResult[0]?.count ?? 0);
}
```

  </action>
  <verify>
Run `cd backend && pnpm tsc --noEmit` passes.
Check that middleware exports requireActiveSubscription and requireSensorCapacity.
  </verify>
  <done>
Subscription middleware created with:
- requireActiveSubscription checking for active/trial status
- requireSensorCapacity checking against organization sensorLimit
- getActiveSensorCount utility for use in metering
- Follows rbac.ts pattern for consistency
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply requireSensorCapacity to device creation route</name>
  <files>backend/src/routes/devices.ts</files>
  <action>
Update `backend/src/routes/devices.ts` to enforce sensor capacity on device creation.

1. Add import at top (near other middleware imports):

```typescript
import { requireSensorCapacity } from '../middleware/subscription.js';
```

2. Find the POST route for creating devices (likely `POST /` or similar) and add requireSensorCapacity to its preHandler.

Look for a route like:

```typescript
app.withTypeProvider<ZodTypeProvider>().route({
  method: 'POST',
  url: '/',
  // or url: '/devices' if at root level
  ...
});
```

Update its preHandler to include requireSensorCapacity:

```typescript
preHandler: [requireSensorCapacity],
```

If the route already has preHandlers (like auth), append to the array:

```typescript
preHandler: [existingHandler, requireSensorCapacity],
```

Note: requireActiveSubscription is NOT added here because device creation typically requires auth which already implies organization context. The sensor limit is the relevant check.
</action>
<verify>
Run `cd backend && pnpm tsc --noEmit` passes.
Check that POST device route includes requireSensorCapacity in preHandler.
</verify>
<done>
Device creation route now enforces sensor capacity limit.
Users at their plan's sensor limit will receive 403 SENSOR_LIMIT_REACHED.
</done>
</task>

</tasks>

<verification>
- [ ] `backend/src/middleware/subscription.ts` exists
- [ ] requireActiveSubscription middleware exported
- [ ] requireSensorCapacity middleware exported
- [ ] getActiveSensorCount utility function exported
- [ ] devices.ts imports requireSensorCapacity
- [ ] POST device route has requireSensorCapacity in preHandler
- [ ] `pnpm tsc --noEmit` passes in backend directory
</verification>

<success_criteria>

1. requireActiveSubscription blocks access for canceled/past_due subscriptions
2. requireActiveSubscription allows access for active and trial subscriptions
3. requireSensorCapacity returns 403 when at sensor limit
4. Error responses include helpful details (current count, limit)
5. Device creation is protected by sensor capacity check
6. Middleware follows rbac.ts pattern for consistency
   </success_criteria>

<output>
After completion, create `.planning/phases/18-stripe-billing/18-03-SUMMARY.md`
</output>
