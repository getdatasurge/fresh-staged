---
phase: 18-stripe-billing
plan: 02
type: execute
wave: 2
depends_on: ['18-01']
files_modified:
  - backend/src/services/stripe-meter.service.ts
  - backend/src/services/stripe-webhook.service.ts
autonomous: true

must_haves:
  truths:
    - 'Meter events are sent to Stripe for active sensors (last aggregation)'
    - 'Meter events are sent to Stripe for temperature readings (sum aggregation)'
    - 'Webhook events are checked for idempotency before processing'
  artifacts:
    - path: 'backend/src/services/stripe-meter.service.ts'
      provides: 'StripeMeterService with reportActiveSensors and reportReadingVolume'
      exports: ['StripeMeterService', 'getStripeMeterService']
    - path: 'backend/src/services/stripe-webhook.service.ts'
      provides: 'Webhook idempotency integration'
      contains: 'stripeEvents'
  key_links:
    - from: 'backend/src/services/stripe-meter.service.ts'
      to: 'stripe'
      via: 'billing.meterEvents.create'
      pattern: "stripe\\.billing\\.meterEvents\\.create"
    - from: 'backend/src/services/stripe-webhook.service.ts'
      to: 'backend/src/db/schema/billing.ts'
      via: 'stripeEvents table query'
      pattern: "from\\(stripeEvents\\)"
---

<objective>
Create the core Stripe metering service and add webhook idempotency.

Purpose: StripeMeterService reports usage to Stripe Billing Meters API for accurate billing. Webhook idempotency prevents duplicate subscription activations when Stripe retries failed webhooks.

Output: Working meter service that can report sensor count and reading volume. Webhook handler that checks stripeEvents table before processing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-stripe-billing/18-RESEARCH.md
@.planning/phases/18-stripe-billing/18-01-SUMMARY.md

# Existing services to follow/modify

@backend/src/services/checkout.service.ts
@backend/src/services/stripe-webhook.service.ts
@backend/src/db/schema/tenancy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StripeMeterService for usage reporting</name>
  <files>backend/src/services/stripe-meter.service.ts</files>
  <action>
Create `backend/src/services/stripe-meter.service.ts`:

```typescript
/**
 * Stripe Meter Service - Usage-based billing integration
 *
 * Reports usage metrics to Stripe Billing Meters API:
 * - Active sensors: uses 'last' aggregation (final count in period billed)
 * - Temperature readings: uses 'sum' aggregation (total readings billed)
 *
 * Important: Meters must be created in Stripe Dashboard with matching event_names:
 * - 'active_sensors' meter with 'last' formula
 * - 'temperature_readings' meter with 'sum' formula
 */

import Stripe from 'stripe';
import { db } from '../db/client.js';
import { subscriptions } from '../db/schema/tenancy.js';
import { eq } from 'drizzle-orm';

// Lazy-initialized Stripe client
let stripeClient: Stripe | null = null;

function getStripeClient(): Stripe {
  if (!stripeClient) {
    const secretKey = process.env.STRIPE_SECRET_KEY;
    if (!secretKey) {
      throw new Error('STRIPE_SECRET_KEY environment variable is not set');
    }
    stripeClient = new Stripe(secretKey, {
      apiVersion: '2025-12-15.clover',
    });
  }
  return stripeClient;
}

export class StripeMeterService {
  private static instance: StripeMeterService | null = null;

  static getInstance(): StripeMeterService {
    if (!StripeMeterService.instance) {
      StripeMeterService.instance = new StripeMeterService();
    }
    return StripeMeterService.instance;
  }

  /**
   * Report active sensor count for an organization
   * Uses 'last' aggregation - only the final value in the billing period is billed
   *
   * @param organizationId - Organization UUID
   * @param sensorCount - Current count of active sensors
   */
  async reportActiveSensors(
    organizationId: string,
    sensorCount: number,
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const customerId = await this.getStripeCustomerId(organizationId);
      if (!customerId) {
        // No Stripe customer yet - org hasn't subscribed
        return { success: false, error: 'No Stripe customer for organization' };
      }

      const stripe = getStripeClient();
      await stripe.billing.meterEvents.create({
        event_name: 'active_sensors',
        payload: {
          stripe_customer_id: customerId,
          value: Math.max(0, Math.floor(sensorCount)).toString(),
        },
      });

      console.log(`[Meter] Reported ${sensorCount} active sensors for org ${organizationId}`);
      return { success: true };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error';
      console.error(`[Meter] Failed to report active sensors: ${message}`);
      return { success: false, error: message };
    }
  }

  /**
   * Report temperature reading volume for an organization
   * Uses 'sum' aggregation - all values in the billing period are added together
   *
   * @param organizationId - Organization UUID
   * @param readingCount - Number of readings ingested
   */
  async reportReadingVolume(
    organizationId: string,
    readingCount: number,
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const customerId = await this.getStripeCustomerId(organizationId);
      if (!customerId) {
        return { success: false, error: 'No Stripe customer for organization' };
      }

      const stripe = getStripeClient();
      await stripe.billing.meterEvents.create({
        event_name: 'temperature_readings',
        payload: {
          stripe_customer_id: customerId,
          value: Math.max(0, Math.floor(readingCount)).toString(),
        },
      });

      console.log(`[Meter] Reported ${readingCount} readings for org ${organizationId}`);
      return { success: true };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error';
      console.error(`[Meter] Failed to report reading volume: ${message}`);
      return { success: false, error: message };
    }
  }

  /**
   * Report active sensor count with explicit timestamp
   * Use for historical reporting or scheduled batch updates
   *
   * @param organizationId - Organization UUID
   * @param sensorCount - Current count of active sensors
   * @param timestamp - Unix timestamp in seconds
   */
  async reportActiveSensorsWithTimestamp(
    organizationId: string,
    sensorCount: number,
    timestamp: number,
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const customerId = await this.getStripeCustomerId(organizationId);
      if (!customerId) {
        return { success: false, error: 'No Stripe customer for organization' };
      }

      const stripe = getStripeClient();
      await stripe.billing.meterEvents.create({
        event_name: 'active_sensors',
        payload: {
          stripe_customer_id: customerId,
          value: Math.max(0, Math.floor(sensorCount)).toString(),
        },
        timestamp,
      });

      return { success: true };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error';
      return { success: false, error: message };
    }
  }

  /**
   * Lookup Stripe customer ID for an organization
   */
  private async getStripeCustomerId(organizationId: string): Promise<string | null> {
    const [sub] = await db
      .select({ customerId: subscriptions.stripeCustomerId })
      .from(subscriptions)
      .where(eq(subscriptions.organizationId, organizationId))
      .limit(1);

    return sub?.customerId || null;
  }
}

// Singleton accessor
export function getStripeMeterService(): StripeMeterService {
  return StripeMeterService.getInstance();
}
```

  </action>
  <verify>
Run `cd backend && pnpm tsc --noEmit` passes.
Check that StripeMeterService exports reportActiveSensors and reportReadingVolume methods.
  </verify>
  <done>
StripeMeterService created with:
- reportActiveSensors (last aggregation for gauge metric)
- reportReadingVolume (sum aggregation for counter metric)
- reportActiveSensorsWithTimestamp for scheduled batch updates
- Error handling that doesn't throw (returns success/error)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add webhook idempotency to stripe-webhook.service.ts</name>
  <files>backend/src/services/stripe-webhook.service.ts</files>
  <action>
Update `backend/src/services/stripe-webhook.service.ts` to add idempotency checking:

1. Add import at top:

```typescript
import { stripeEvents, type InsertStripeEvent } from '../db/schema/billing.js';
```

2. Add helper function before handleWebhookEvent:

```typescript
/**
 * Check if a webhook event has already been processed
 * Returns true if event exists (already processed), false otherwise
 */
async function isEventProcessed(eventId: string): Promise<boolean> {
  const [existing] = await db
    .select({ id: stripeEvents.id })
    .from(stripeEvents)
    .where(eq(stripeEvents.eventId, eventId))
    .limit(1);

  return !!existing;
}

/**
 * Record that a webhook event has been processed
 */
async function recordProcessedEvent(eventId: string, eventType: string): Promise<void> {
  const insert: InsertStripeEvent = {
    eventId,
    eventType,
  };

  await db.insert(stripeEvents).values(insert).onConflictDoNothing();
}
```

3. Update handleWebhookEvent to check and record events:

```typescript
/**
 * Main webhook event handler
 * Routes events to appropriate handlers with idempotency protection
 */
export async function handleWebhookEvent(event: Stripe.Event): Promise<void> {
  // Idempotency check - Stripe retries failed webhooks for up to 3 days
  if (await isEventProcessed(event.id)) {
    console.log(`[Stripe Webhook] Event ${event.id} already processed, skipping`);
    return;
  }

  switch (event.type) {
    case 'checkout.session.completed': {
      const session = event.data.object as Stripe.Checkout.Session;
      await handleCheckoutCompleted(session);
      break;
    }
    case 'customer.subscription.updated': {
      const subscription = event.data.object as Stripe.Subscription;
      await handleSubscriptionUpdated(subscription);
      break;
    }
    case 'customer.subscription.deleted': {
      const subscription = event.data.object as Stripe.Subscription;
      await handleSubscriptionDeleted(subscription);
      break;
    }
    case 'invoice.payment_failed': {
      const invoice = event.data.object as Stripe.Invoice;
      await handleInvoicePaymentFailed(invoice);
      break;
    }
    default:
      // Unhandled event type - log for monitoring
      console.log(`[Stripe Webhook] Unhandled event type: ${event.type}`);
  }

  // Record successful processing for idempotency
  await recordProcessedEvent(event.id, event.type);
}
```

  </action>
  <verify>
Run `cd backend && pnpm tsc --noEmit` passes.
Check that handleWebhookEvent now imports from billing.ts and calls isEventProcessed.
  </verify>
  <done>
Webhook service updated with:
- isEventProcessed helper checking stripeEvents table
- recordProcessedEvent helper inserting processed events
- handleWebhookEvent checks idempotency before processing
- Duplicate events are skipped with log message
  </done>
</task>

</tasks>

<verification>
- [ ] `backend/src/services/stripe-meter.service.ts` exists
- [ ] StripeMeterService has reportActiveSensors method
- [ ] StripeMeterService has reportReadingVolume method
- [ ] stripe-webhook.service.ts imports from billing.ts
- [ ] handleWebhookEvent checks stripeEvents before processing
- [ ] handleWebhookEvent records events after processing
- [ ] `pnpm tsc --noEmit` passes in backend directory
</verification>

<success_criteria>

1. StripeMeterService can report sensor counts to Stripe Billing Meters
2. StripeMeterService can report reading volumes to Stripe Billing Meters
3. Values are properly formatted (whole number strings)
4. Errors are caught and logged without throwing
5. Webhook handler checks idempotency before processing
6. Processed events are recorded to prevent duplicates
   </success_criteria>

<output>
After completion, create `.planning/phases/18-stripe-billing/18-02-SUMMARY.md`
</output>
