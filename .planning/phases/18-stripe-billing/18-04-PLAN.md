---
phase: 18-stripe-billing
plan: 04
type: execute
wave: 3
depends_on: ["18-01", "18-02"]
files_modified:
  - backend/src/workers/processors/meter-reporting.processor.ts
  - backend/src/workers/processors/index.ts
  - backend/src/services/queue.service.ts
  - backend/src/services/reading-ingestion.service.ts
autonomous: true

must_haves:
  truths:
    - "Meter events are queued as background jobs during reading ingestion"
    - "Processor sends meter events to Stripe via StripeMeterService"
    - "Failed meter reports are retried with exponential backoff"
  artifacts:
    - path: "backend/src/workers/processors/meter-reporting.processor.ts"
      provides: "BullMQ processor for meter reporting jobs"
      exports: ["createMeterReportingProcessor"]
    - path: "backend/src/services/reading-ingestion.service.ts"
      provides: "Integration with meter reporting queue"
      contains: "METER_REPORTING"
  key_links:
    - from: "backend/src/workers/processors/meter-reporting.processor.ts"
      to: "backend/src/services/stripe-meter.service.ts"
      via: "StripeMeterService method calls"
      pattern: "getStripeMeterService\\(\\)"
    - from: "backend/src/services/reading-ingestion.service.ts"
      to: "backend/src/services/queue.service.ts"
      via: "addJob for meter reporting"
      pattern: "QueueNames\\.METER_REPORTING"
---

<objective>
Create meter reporting processor and integrate with reading ingestion pipeline.

Purpose: Meter events must be sent asynchronously to avoid blocking the ingestion API. BullMQ provides retry logic and job persistence for reliable delivery to Stripe.

Output: Working meter reporting worker that processes queued jobs. Reading ingestion automatically queues meter events for temperature reading volume.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-stripe-billing/18-RESEARCH.md
@.planning/phases/18-stripe-billing/18-01-SUMMARY.md
@.planning/phases/18-stripe-billing/18-02-SUMMARY.md

# Existing patterns
@backend/src/workers/processors/sms.processor.ts
@backend/src/services/reading-ingestion.service.ts
@backend/src/services/queue.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create meter reporting processor</name>
  <files>
    backend/src/workers/processors/meter-reporting.processor.ts
    backend/src/workers/processors/index.ts
  </files>
  <action>
Create `backend/src/workers/processors/meter-reporting.processor.ts`:

```typescript
/**
 * Meter Reporting Processor
 *
 * Processes meter reporting jobs for Stripe Billing Meters:
 * - 'active_sensors': Reports current sensor count (last aggregation)
 * - 'temperature_readings': Reports reading volume (sum aggregation)
 *
 * Jobs are queued by:
 * - reading-ingestion.service.ts (temperature readings)
 * - scheduled sensor count job (active sensors)
 */

import { Processor } from 'bullmq';
import type { MeterReportJobData, MeterReportJob } from '../../jobs/index.js';
import { getStripeMeterService } from '../../services/stripe-meter.service.js';

/**
 * Create the meter reporting processor function
 *
 * @returns BullMQ Processor for meter reporting jobs
 */
export function createMeterReportingProcessor(): Processor<MeterReportJobData> {
  return async (job: MeterReportJob): Promise<void> => {
    const { organizationId, eventName, value, timestamp } = job.data;

    console.log(`[MeterProcessor] Processing ${eventName} job for org ${organizationId}, value: ${value}`);

    const meterService = getStripeMeterService();
    let result: { success: boolean; error?: string };

    switch (eventName) {
      case 'active_sensors':
        if (timestamp) {
          result = await meterService.reportActiveSensorsWithTimestamp(
            organizationId,
            value,
            timestamp
          );
        } else {
          result = await meterService.reportActiveSensors(organizationId, value);
        }
        break;

      case 'temperature_readings':
        result = await meterService.reportReadingVolume(organizationId, value);
        break;

      default:
        throw new Error(`Unknown meter event name: ${eventName}`);
    }

    if (!result.success) {
      // Throw to trigger BullMQ retry
      throw new Error(`Meter reporting failed: ${result.error}`);
    }

    console.log(`[MeterProcessor] Successfully reported ${eventName} for org ${organizationId}`);
  };
}
```

Update `backend/src/workers/processors/index.ts` to export the new processor:

Add the export:
```typescript
export { createMeterReportingProcessor } from './meter-reporting.processor.js';
```
  </action>
  <verify>
Run `cd backend && pnpm tsc --noEmit` passes.
Check that createMeterReportingProcessor is exported from processors/index.ts.
  </verify>
  <done>
Meter reporting processor created that:
- Handles both active_sensors and temperature_readings events
- Uses StripeMeterService for Stripe API calls
- Throws on failure to trigger BullMQ retry
- Supports optional timestamp for scheduled reporting
  </done>
</task>

<task type="auto">
  <name>Task 2: Register meter reporting queue in queue service</name>
  <files>backend/src/services/queue.service.ts</files>
  <action>
Update `backend/src/services/queue.service.ts` to register the meter reporting queue.

1. Add import for meter job options:
```typescript
import { ..., meterReportJobOptions } from '../jobs/index.js';
```

2. In the QueueService constructor or initialization, add the METER_REPORTING queue registration.

Look for where SMS_NOTIFICATIONS and EMAIL_DIGESTS queues are registered, and add:
```typescript
// Register meter reporting queue
this.queues.set(QueueNames.METER_REPORTING, new Queue(QueueNames.METER_REPORTING, {
  connection: this.connection,
  defaultJobOptions: meterReportJobOptions,
}));
```

3. Ensure the queue is properly typed in the queues Map.

Note: The worker registration happens in the worker entry point, not here. This just sets up the queue for adding jobs.
  </action>
  <verify>
Run `cd backend && pnpm tsc --noEmit` passes.
Check that QueueNames.METER_REPORTING is used in queue.service.ts.
  </verify>
  <done>
Queue service updated to register METER_REPORTING queue with proper job options.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate meter reporting into reading ingestion</name>
  <files>backend/src/services/reading-ingestion.service.ts</files>
  <action>
Update `backend/src/services/reading-ingestion.service.ts` to queue meter events after successful ingestion.

1. Add imports at top:
```typescript
import { getQueueService } from './queue.service.js';
import { QueueNames, JobNames, type MeterReportJobData } from '../jobs/index.js';
```

2. In the `ingestReadings` function, after successful insertion (after `const insertResult = ...`), add meter reporting:

```typescript
// Queue meter event for reading volume (async, don't await)
try {
  const queueService = getQueueService();
  if (queueService?.isEnabled()) {
    const meterJobData: MeterReportJobData = {
      organizationId,
      eventName: 'temperature_readings',
      value: insertResult.insertedCount,
    };

    queueService.addJob(
      QueueNames.METER_REPORTING,
      JobNames.METER_REPORT,
      meterJobData
    ).catch((err) => {
      // Log but don't fail ingestion if queue is unavailable
      console.warn(`[Ingestion] Failed to queue meter event: ${err.message}`);
    });
  }
} catch (err) {
  // Queue service not available - skip metering silently
  console.warn('[Ingestion] Queue service unavailable for metering');
}
```

Place this after step 1 (batch insert) and before step 2 (streaming). The meter job is fire-and-forget - we don't await it to avoid blocking the ingestion response.
  </action>
  <verify>
Run `cd backend && pnpm tsc --noEmit` passes.
Check that ingestReadings imports QueueNames.METER_REPORTING.
Check that addJob is called with 'temperature_readings' event.
  </verify>
  <done>
Reading ingestion now:
- Queues meter reporting job after successful batch insert
- Uses fire-and-forget pattern (don't await)
- Fails silently if queue unavailable (doesn't break ingestion)
- Reports actual inserted count, not requested count
  </done>
</task>

</tasks>

<verification>
- [ ] `backend/src/workers/processors/meter-reporting.processor.ts` exists
- [ ] createMeterReportingProcessor exported from processors/index.ts
- [ ] queue.service.ts registers METER_REPORTING queue
- [ ] reading-ingestion.service.ts imports from jobs/index.ts
- [ ] ingestReadings queues meter:report job with temperature_readings event
- [ ] Meter job uses fire-and-forget pattern (.catch instead of await)
- [ ] `pnpm tsc --noEmit` passes in backend directory
</verification>

<success_criteria>
1. Meter reporting processor handles active_sensors and temperature_readings
2. Processor throws on failure to trigger BullMQ retry
3. Queue service registers METER_REPORTING queue with proper options
4. Reading ingestion queues meter events without blocking
5. Queue failures don't break reading ingestion
6. Inserted count (not requested count) is reported
</success_criteria>

<output>
After completion, create `.planning/phases/18-stripe-billing/18-04-SUMMARY.md`
</output>
