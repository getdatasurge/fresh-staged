---
phase: 13-e2e-validation-cutover
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/test/e2e-alert-notifications.sh
  - scripts/test/webhook-receiver.sh
  - scripts/test/README.md
autonomous: true

must_haves:
  truths:
    - "Alert triggers notification dispatch to configured webhook endpoint"
    - "Webhook receiver captures notification payload with correct alert data"
    - "Alert acknowledgment updates alert status in database"
    - "Alert resolution updates alert status and optionally creates corrective action"
    - "Full lifecycle (trigger → acknowledge → resolve) can be tested end-to-end"
  artifacts:
    - path: "scripts/test/e2e-alert-notifications.sh"
      provides: "E2E alert notification pipeline test script"
      min_lines: 120
    - path: "scripts/test/webhook-receiver.sh"
      provides: "Simple webhook receiver for capturing notifications"
      min_lines: 40
  key_links:
    - from: "e2e-alert-notifications.sh"
      to: "backend/src/services/alert.service.ts"
      via: "POST /api/alerts/:id/acknowledge"
      pattern: "alerts/.*/acknowledge"
    - from: "e2e-alert-notifications.sh"
      to: "backend/src/services/alert.service.ts"
      via: "POST /api/alerts/:id/resolve"
      pattern: "alerts/.*/resolve"
---

<objective>
Create E2E alert notification pipeline test that validates the complete alert lifecycle and notification delivery.

Purpose: Validate TEST-02 requirement that alert notifications are delivered successfully (webhook tested end-to-end).
Output: Test scripts that validate alert trigger → notification → acknowledgment → resolution flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-e2e-validation-cutover/13-RESEARCH.md
@backend/src/routes/alerts.ts
@backend/src/services/alert.service.ts
@backend/src/services/alert-evaluator.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create webhook receiver helper script</name>
  <files>scripts/test/webhook-receiver.sh</files>
  <action>
Create a simple webhook receiver script using netcat or Python that:

1. **Purpose:** Capture incoming webhook notifications during E2E testing

2. **Implementation (choose simplest approach):**
   - Option A: Python one-liner HTTP server that logs requests to file
   - Option B: netcat listener that captures first request

   Use Python http.server approach (more portable):
   ```bash
   #!/bin/bash
   # Simple webhook receiver for E2E testing
   # Captures notification payloads to verify delivery
   ```

3. **Features:**
   - Start listener on configurable port (default: 8888)
   - Log received payloads to /tmp/webhook-test-<timestamp>.json
   - Timeout after configurable seconds (default: 60s)
   - Return 200 OK to caller
   - Print received payload to stdout

4. **Usage:**
   - Can run in background during E2E tests
   - Provides webhook URL: http://localhost:8888/webhook
   - Test can verify file was created with expected payload

Note: Keep this simple - it's just for testing, not production use.
  </action>
  <verify>
Run: chmod +x scripts/test/webhook-receiver.sh && ./scripts/test/webhook-receiver.sh --help 2>/dev/null || head -20 scripts/test/webhook-receiver.sh
Script should show usage or have clear header comments.
  </verify>
  <done>
Webhook receiver script exists and can capture incoming HTTP requests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create E2E alert notification test script</name>
  <files>scripts/test/e2e-alert-notifications.sh</files>
  <action>
Create scripts/test/e2e-alert-notifications.sh that tests the full alert lifecycle:

1. **Configuration:**
   - BASE_URL (default: http://localhost:3000)
   - TEST_JWT (required - for authenticated alert operations)
   - TTN_WEBHOOK_SECRET (required - for sensor reading injection)
   - WEBHOOK_PORT (default: 8888 - for test webhook receiver)
   - ORGANIZATION_ID (required - for API calls)

2. **Pre-flight checks:**
   - Verify backend health
   - Verify jq is installed
   - Verify required env vars are set

3. **Test flow (8 steps):**

   Step 1: Start webhook receiver in background (optional - if WEBHOOK_TEST=true)

   Step 2: Inject sensor reading above threshold to trigger alert
   - POST to /api/readings with temperature above limit
   - Use unique device ID

   Step 3: Wait for alert creation (poll /api/alerts for new alert)
   - Poll every 2 seconds, timeout after 30 seconds
   - Extract alert ID for subsequent steps

   Step 4: Verify alert details
   - GET /api/alerts/{id}
   - Verify status is 'triggered' or 'active'
   - Verify severity matches expectation

   Step 5: Test alert acknowledgment
   - POST /api/alerts/{id}/acknowledge
   - Verify response shows status 'acknowledged'
   - Verify acknowledgedAt timestamp is set

   Step 6: Verify acknowledgment persisted
   - GET /api/alerts/{id}
   - Confirm status is 'acknowledged'

   Step 7: Test alert resolution
   - POST /api/alerts/{id}/resolve with resolution notes
   - Verify response shows status 'resolved'
   - Verify resolvedAt timestamp is set

   Step 8: (If webhook test enabled) Verify webhook received notification
   - Check webhook receiver log file
   - Verify payload contains alert ID

4. **Output:**
   - Clear step-by-step output
   - Summary of passed/failed tests
   - Exit 0 on success, 1 on failure

5. **Edge cases:**
   - Handle case where no alert rules exist (skip alert creation test with warning)
   - Handle already-acknowledged alerts gracefully
   - Timeout handling for async operations
  </action>
  <verify>
Run: chmod +x scripts/test/e2e-alert-notifications.sh && shellcheck scripts/test/e2e-alert-notifications.sh
Script should pass shellcheck validation.
  </verify>
  <done>
Script exists with all 8 test steps implemented.
Script tests full alert lifecycle: trigger → acknowledge → resolve.
Script passes shellcheck validation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update README with alert notification test documentation</name>
  <files>scripts/test/README.md</files>
  <action>
Append to scripts/test/README.md documentation for alert notification testing:

1. **E2E Alert Notifications (e2e-alert-notifications.sh):**
   - What it tests (full alert lifecycle + notification delivery)
   - Required environment variables
   - Example usage

2. **Webhook Receiver (webhook-receiver.sh):**
   - Purpose and when to use
   - How to run alongside notification tests
   - Where payloads are logged

3. **Testing Notification Channels:**
   - Webhook testing (covered by scripts)
   - Email testing (manual verification steps - check logs/email provider)
   - Note: Email requires SMTP configuration

4. **Complete E2E Test Sequence:**
   - Document running both scripts in order:
     1. e2e-sensor-pipeline.sh (basic ingestion)
     2. e2e-alert-notifications.sh (alert lifecycle)
   - Document expected results for production validation
  </action>
  <verify>
Run: grep -c "e2e-alert-notifications" scripts/test/README.md
Should return at least 3 (multiple references to the script).
  </verify>
  <done>
README updated with alert notification test documentation.
Complete testing workflow documented.
  </done>
</task>

</tasks>

<verification>
Test the alert notification script against local development:
```bash
cd /home/skynet/freshtrack-pro-local/freshtrack-pro
export BASE_URL=http://localhost:3000
export TEST_JWT=<valid-jwt>
export TTN_WEBHOOK_SECRET=test-secret
export ORGANIZATION_ID=<test-org-id>
./scripts/test/e2e-alert-notifications.sh
```
</verification>

<success_criteria>
- e2e-alert-notifications.sh tests full alert lifecycle (trigger → acknowledge → resolve)
- webhook-receiver.sh can capture notification payloads
- Scripts are documented in README.md
- TEST-02 requirement (alert notification pipeline validated) is addressed
</success_criteria>

<output>
After completion, create `.planning/phases/13-e2e-validation-cutover/13-02-SUMMARY.md`
</output>
