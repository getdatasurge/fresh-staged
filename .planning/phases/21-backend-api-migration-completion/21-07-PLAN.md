---
phase: 21-backend-api-migration-completion
plan: 07
type: execute
wave: 4
depends_on: ['21-06']
files_modified:
  - backend/src/routers/escalation-contacts.router.ts
  - backend/src/schemas/escalation-contacts.ts
  - backend/tests/trpc/escalation-contacts.router.test.ts
autonomous: true

must_haves:
  truths:
    - 'Escalation contacts can be listed via tRPC'
    - 'Escalation contacts can be created, updated, deleted via tRPC'
    - 'Role-based access enforced for escalation contact mutations'
  artifacts:
    - path: 'backend/src/routers/escalation-contacts.router.ts'
      provides: 'Escalation contacts router with CRUD operations'
      min_lines: 120
      exports: ['escalationContactsRouter']
    - path: 'backend/src/schemas/escalation-contacts.ts'
      provides: 'Zod schemas for escalation contacts'
      contains: 'EscalationContactSchema'
    - path: 'backend/tests/trpc/escalation-contacts.router.test.ts'
      provides: 'Test coverage for escalation contacts procedures'
      min_lines: 40
  key_links:
    - from: 'backend/src/trpc/router.ts'
      to: 'escalationContactsRouter'
      via: 'router composition'
      pattern: 'escalationContacts.*escalationContactsRouter'
---

<objective>
Create escalation contacts backend router for CRUD operations.

Purpose: Enable migration of useEscalationContacts hook from direct Supabase queries to tRPC.

Output: escalationContactsRouter with procedures for list, create, update, delete.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-backend-api-migration-completion/21-VERIFICATION.md

Reference existing routers for patterns:
@backend/src/routers/notification-policies.router.ts
@backend/src/routers/sites.router.ts

Reference hook that needs this router:
@src/hooks/useEscalationContacts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create escalation contacts schemas and router</name>
  <files>
    backend/src/schemas/escalation-contacts.ts
    backend/src/routers/escalation-contacts.router.ts
  </files>
  <action>
1. Create backend/src/schemas/escalation-contacts.ts:

```typescript
import { z } from 'zod';

export const EscalationContactSchema = z.object({
  id: z.string().uuid(),
  organization_id: z.string().uuid(),
  name: z.string().min(1).max(255),
  email: z.string().email().nullable(),
  phone: z.string().nullable(),
  priority: z.number().int().min(1),
  notification_channels: z.array(z.string()),
  is_active: z.boolean(),
  user_id: z.string().uuid().nullable(),
  created_at: z.string(),
});

export const CreateEscalationContactSchema = z.object({
  name: z.string().min(1).max(255),
  email: z.string().email().nullable(),
  phone: z.string().nullable(),
  priority: z.number().int().min(1),
  notification_channels: z.array(z.string()).default(['email']),
  is_active: z.boolean().default(true),
  user_id: z.string().uuid().nullable(),
});

export const UpdateEscalationContactSchema = z.object({
  name: z.string().min(1).max(255).optional(),
  email: z.string().email().nullable().optional(),
  phone: z.string().nullable().optional(),
  priority: z.number().int().min(1).optional(),
  notification_channels: z.array(z.string()).optional(),
  is_active: z.boolean().optional(),
  user_id: z.string().uuid().nullable().optional(),
});

export type EscalationContact = z.infer<typeof EscalationContactSchema>;
export type CreateEscalationContact = z.infer<typeof CreateEscalationContactSchema>;
export type UpdateEscalationContact = z.infer<typeof UpdateEscalationContactSchema>;
```

2. Create backend/src/routers/escalation-contacts.router.ts:

```typescript
import { z } from 'zod';
import { TRPCError } from '@trpc/server';
import { router } from '../trpc/index.js';
import { orgProcedure } from '../trpc/procedures.js';
import {
  EscalationContactSchema,
  CreateEscalationContactSchema,
  UpdateEscalationContactSchema,
} from '../schemas/escalation-contacts.js';

const OrgInput = z.object({
  organizationId: z.string().uuid(),
});

const ContactIdInput = z.object({
  organizationId: z.string().uuid(),
  contactId: z.string().uuid(),
});

const CreateInput = z.object({
  organizationId: z.string().uuid(),
  data: CreateEscalationContactSchema,
});

const UpdateInput = z.object({
  organizationId: z.string().uuid(),
  contactId: z.string().uuid(),
  data: UpdateEscalationContactSchema,
});

export const escalationContactsRouter = router({
  list: orgProcedure
    .input(OrgInput)
    .output(z.array(EscalationContactSchema))
    .query(async ({ input, ctx }) => {
      const { db } = ctx;

      const contacts = await db
        .selectFrom('escalation_contacts')
        .selectAll()
        .where('organization_id', '=', input.organizationId)
        .where('is_active', '=', true)
        .orderBy('priority', 'asc')
        .execute();

      return contacts;
    }),

  create: orgProcedure
    .input(CreateInput)
    .output(EscalationContactSchema)
    .mutation(async ({ input, ctx }) => {
      const { db, user } = ctx;

      // Manager+ role required for escalation contacts
      if (!['manager', 'admin', 'owner'].includes(user.role)) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'Only managers and above can create escalation contacts',
        });
      }

      const newContact = await db
        .insertInto('escalation_contacts')
        .values({
          organization_id: input.organizationId,
          ...input.data,
        })
        .returningAll()
        .executeTakeFirstOrThrow();

      return newContact;
    }),

  update: orgProcedure.input(UpdateInput).mutation(async ({ input, ctx }) => {
    const { db, user } = ctx;

    // Manager+ role required
    if (!['manager', 'admin', 'owner'].includes(user.role)) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: 'Only managers and above can update escalation contacts',
      });
    }

    // Verify contact belongs to org
    const existing = await db
      .selectFrom('escalation_contacts')
      .select('id')
      .where('id', '=', input.contactId)
      .where('organization_id', '=', input.organizationId)
      .executeTakeFirst();

    if (!existing) {
      throw new TRPCError({
        code: 'NOT_FOUND',
        message: 'Escalation contact not found',
      });
    }

    await db
      .updateTable('escalation_contacts')
      .set(input.data)
      .where('id', '=', input.contactId)
      .execute();

    return { success: true };
  }),

  delete: orgProcedure.input(ContactIdInput).mutation(async ({ input, ctx }) => {
    const { db, user } = ctx;

    // Manager+ role required
    if (!['manager', 'admin', 'owner'].includes(user.role)) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: 'Only managers and above can delete escalation contacts',
      });
    }

    // Verify contact belongs to org
    const existing = await db
      .selectFrom('escalation_contacts')
      .select('id')
      .where('id', '=', input.contactId)
      .where('organization_id', '=', input.organizationId)
      .executeTakeFirst();

    if (!existing) {
      throw new TRPCError({
        code: 'NOT_FOUND',
        message: 'Escalation contact not found',
      });
    }

    // Soft delete by marking inactive
    await db
      .updateTable('escalation_contacts')
      .set({ is_active: false })
      .where('id', '=', input.contactId)
      .execute();

    return { success: true };
  }),
});
```

  </action>
  <verify>
Files exist at backend/src/schemas/escalation-contacts.ts and backend/src/routers/escalation-contacts.router.ts
Exports escalationContactsRouter constant
Contains 4 procedures: list, create, update, delete
TypeScript compilation passes: `cd backend && npm run typecheck`
  </verify>
  <done>
Escalation contacts router created with CRUD operations, manager+ role checks enforced
  </done>
</task>

<task type="auto">
  <name>Task 2: Register router and create tests</name>
  <files>
    backend/src/trpc/router.ts
    backend/tests/trpc/escalation-contacts.router.test.ts
  </files>
  <action>
1. Register router in backend/src/trpc/router.ts:

Add import (alphabetical order):

```typescript
import { escalationContactsRouter } from '../routers/escalation-contacts.router.js';
```

Add to appRouter (after availability):

```typescript
export const appRouter = router({
  // ... existing routers ...
  availability: availabilityRouter,
  escalationContacts: escalationContactsRouter,
  // ... rest ...
});
```

2. Create backend/tests/trpc/escalation-contacts.router.test.ts:

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { mockContext, mockOrgProcedureContext } from '../helpers/trpc-test-helpers.js';
import { escalationContactsRouter } from '../../src/routers/escalation-contacts.router.js';

describe('escalationContactsRouter', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('list', () => {
    it('returns active contacts ordered by priority', async () => {
      const mockContacts = [
        {
          id: 'contact-1',
          organization_id: 'org-123',
          name: 'Primary Contact',
          email: 'primary@example.com',
          phone: null,
          priority: 1,
          notification_channels: ['email'],
          is_active: true,
          user_id: null,
          created_at: '2024-01-01T00:00:00Z',
        },
        {
          id: 'contact-2',
          organization_id: 'org-123',
          name: 'Secondary Contact',
          email: 'secondary@example.com',
          phone: '+1234567890',
          priority: 2,
          notification_channels: ['email', 'sms'],
          is_active: true,
          user_id: null,
          created_at: '2024-01-01T00:00:00Z',
        },
      ];

      const ctx = mockOrgProcedureContext({
        dbResults: {
          escalation_contacts: mockContacts,
        },
      });

      const caller = escalationContactsRouter.createCaller(ctx);
      const result = await caller.list({
        organizationId: 'org-123',
      });

      expect(result).toHaveLength(2);
      expect(result[0].name).toBe('Primary Contact');
    });
  });

  describe('create', () => {
    it('creates contact when user is manager', async () => {
      const ctx = mockOrgProcedureContext({
        user: { role: 'manager' },
      });

      const caller = escalationContactsRouter.createCaller(ctx);
      const result = await caller.create({
        organizationId: 'org-123',
        data: {
          name: 'New Contact',
          email: 'new@example.com',
          phone: null,
          priority: 1,
          notification_channels: ['email'],
          is_active: true,
          user_id: null,
        },
      });

      expect(ctx.db.insertInto).toHaveBeenCalledWith('escalation_contacts');
    });

    it('throws FORBIDDEN when user is staff', async () => {
      const ctx = mockOrgProcedureContext({
        user: { role: 'staff' },
      });

      const caller = escalationContactsRouter.createCaller(ctx);
      await expect(
        caller.create({
          organizationId: 'org-123',
          data: {
            name: 'New Contact',
            email: 'new@example.com',
            phone: null,
            priority: 1,
            notification_channels: ['email'],
            is_active: true,
            user_id: null,
          },
        }),
      ).rejects.toThrow('Only managers');
    });
  });

  describe('update', () => {
    it('updates contact when user is manager', async () => {
      const ctx = mockOrgProcedureContext({
        user: { role: 'manager' },
        dbResults: {
          escalation_contacts: [{ id: 'contact-1' }],
        },
      });

      const caller = escalationContactsRouter.createCaller(ctx);
      await caller.update({
        organizationId: 'org-123',
        contactId: 'contact-1',
        data: { name: 'Updated Name' },
      });

      expect(ctx.db.updateTable).toHaveBeenCalledWith('escalation_contacts');
    });

    it('throws NOT_FOUND when contact does not exist', async () => {
      const ctx = mockOrgProcedureContext({
        user: { role: 'manager' },
        dbResults: {
          escalation_contacts: [],
        },
      });

      const caller = escalationContactsRouter.createCaller(ctx);
      await expect(
        caller.update({
          organizationId: 'org-123',
          contactId: 'nonexistent',
          data: { name: 'Updated Name' },
        }),
      ).rejects.toThrow('not found');
    });
  });

  describe('delete', () => {
    it('soft deletes contact by marking inactive', async () => {
      const ctx = mockOrgProcedureContext({
        user: { role: 'manager' },
        dbResults: {
          escalation_contacts: [{ id: 'contact-1' }],
        },
      });

      const caller = escalationContactsRouter.createCaller(ctx);
      await caller.delete({
        organizationId: 'org-123',
        contactId: 'contact-1',
      });

      expect(ctx.db.updateTable).toHaveBeenCalledWith('escalation_contacts');
    });
  });
});
```

3. Run tests:

```bash
cd backend && npm test -- escalation-contacts.router.test.ts
```

  </action>
  <verify>
Router registered in backend/src/trpc/router.ts
Test file exists at backend/tests/trpc/escalation-contacts.router.test.ts
All tests pass: `cd backend && npm test -- escalation-contacts.router.test.ts`
TypeScript compilation passes for entire backend
  </verify>
  <done>
Escalation contacts router registered in appRouter, 8+ tests passing covering all CRUD operations
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes for backend
2. Tests pass: `cd backend && npm test -- escalation-contacts.router.test.ts`
3. Router exports escalationContactsRouter and is registered in appRouter
4. Schemas validate escalation contact structure with proper types
</verification>

<success_criteria>

- Escalation contacts router created with 4 procedures (list, create, update, delete)
- Zod schemas define escalation contact shape and validation
- Router registered in appRouter at `escalationContacts` namespace
- 8+ tests passing covering all procedures and error cases
- Manager+ role checks enforced for mutations
- Soft delete implemented (marks is_active: false)
- TypeScript compilation passes for backend
  </success_criteria>

<output>
After completion, create `.planning/phases/21-backend-api-migration-completion/21-07-SUMMARY.md`
</output>
