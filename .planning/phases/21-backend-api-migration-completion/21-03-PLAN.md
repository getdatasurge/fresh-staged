---
phase: 21-backend-api-migration-completion
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/routers/admin.router.ts
  - backend/src/routers/assets.router.ts
  - backend/src/routers/availability.router.ts
  - backend/src/trpc/router.ts
  - backend/src/trpc/index.ts
  - backend/tests/trpc/admin.router.test.ts
  - backend/tests/trpc/assets.router.test.ts
  - backend/tests/trpc/availability.router.test.ts
autonomous: true

must_haves:
  truths:
    - 'Authenticated user can check queue health and system status via tRPC'
    - 'User can get pre-signed upload URLs for asset uploads via tRPC'
    - 'Public users can check email/phone availability during registration'
  artifacts:
    - path: 'backend/src/routers/admin.router.ts'
      provides: 'Queue monitoring and system status'
      exports: ['adminRouter']
    - path: 'backend/src/routers/assets.router.ts'
      provides: 'Pre-signed URL asset upload'
      exports: ['assetsRouter']
    - path: 'backend/src/routers/availability.router.ts'
      provides: 'Email/phone availability checks'
      exports: ['availabilityRouter']
  key_links:
    - from: 'backend/src/trpc/router.ts'
      to: 'admin, assets, availability routers'
      via: 'router composition'
      pattern: 'admin: adminRouter'
---

<objective>
Create tRPC routers for Admin/Utility domains: queue monitoring, asset uploads (pre-signed URL pattern), and public availability checks.

Purpose: Complete backend tRPC router coverage for all remaining domains that need type-safe API access.

Output: Three new tRPC routers (including first public procedures) registered in appRouter with tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-backend-api-migration-completion/21-RESEARCH.md

Reference existing patterns:
@backend/src/trpc/router.ts
@backend/src/trpc/index.ts
@backend/tests/trpc/organizations.router.test.ts

Reference REST routes being replaced:
@backend/src/routes/admin.ts
@backend/src/routes/assets.ts
@backend/src/routes/availability.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create admin and assets tRPC routers</name>
  <files>
    backend/src/routers/admin.router.ts
    backend/src/routers/assets.router.ts
    backend/src/trpc/router.ts
  </files>
  <action>
Create backend/src/routers/admin.router.ts with 2 procedures:

1. `queueHealth` - protectedProcedure
   - Access fastify.queueService from context (need to pass through tRPC context)
   - If queueService not available or Redis not enabled, return service unavailable status
   - Get all queues and their stats (waiting, active, completed, failed, delayed)
   - Return { redisEnabled: boolean, queues: QueueStats[], timestamp: string }

2. `systemStatus` - protectedProcedure
   - Return { queues: { enabled: boolean, count: number }, timestamp: string }

Note: The admin router needs access to fastify instance. This can be done by:

- Adding queueService to the tRPC context in trpc/context.ts
- Or creating a separate context extension for admin routes

Create backend/src/routers/assets.router.ts with 1 procedure:

1. `getUploadUrl` - orgProcedure
   - Input: { organizationId, filename, mimeType, assetType: 'profile'|'site'|'unit'|'area', entityId?: string }
   - Validate file type and size limits using assetStorageService.validateFile
   - Generate pre-signed upload URL using assetStorageService (add method if needed)
   - Return { uploadUrl: string, publicUrl: string, key: string }

Note: The current assets route uses multipart upload. For tRPC, use pre-signed URL pattern:

1. Client calls getUploadUrl to get S3/MinIO pre-signed URL
2. Client uploads directly to storage using the URL
3. More scalable and avoids tRPC body size limits

If assetStorageService doesn't have getPresignedUploadUrl, add a TODO comment and implement a basic version that returns the storage endpoint + key.

Register both in router.ts:

- `admin: adminRouter`
- `assets: assetsRouter`
  </action>
  <verify>
  npx tsc --noEmit -p backend/tsconfig.json
  grep -q "adminRouter" backend/src/trpc/router.ts
  grep -q "assetsRouter" backend/src/trpc/router.ts
  </verify>
  <done>
  Admin and assets routers compile and are registered in appRouter
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create availability tRPC router with public procedures</name>
  <files>
    backend/src/routers/availability.router.ts
    backend/src/trpc/index.ts
    backend/src/trpc/router.ts
  </files>
  <action>
First, ensure publicProcedure is properly exported from backend/src/trpc/index.ts.
The existing health check uses publicProcedure, so it should already be available.

Create backend/src/routers/availability.router.ts with 2 procedures:

1. `checkEmail` - publicProcedure (no auth required)
   - Input: { email: z.string().email() }
   - Call checkEmailAvailability(email) from availability.service.js
   - Return { available: boolean, message: string }

2. `checkPhone` - publicProcedure (no auth required)
   - Input: { phone: z.string() }
   - Call checkPhoneAvailability(phone) from availability.service.js
   - Return { available: boolean, message: string }

These are public endpoints used during registration to validate uniqueness in real-time.

Register in router.ts:

- `availability: availabilityRouter`
  </action>
  <verify>
  npx tsc --noEmit -p backend/tsconfig.json
  grep -q "availabilityRouter" backend/src/trpc/router.ts
  </verify>
  <done>
  Availability router with public procedures compiles and is registered
  </done>
  </task>

<task type="auto">
  <name>Task 3: Add unit tests for admin, assets, and availability routers</name>
  <files>
    backend/tests/trpc/admin.router.test.ts
    backend/tests/trpc/assets.router.test.ts
    backend/tests/trpc/availability.router.test.ts
  </files>
  <action>
Create backend/tests/trpc/admin.router.test.ts:
- Mock queueService
- Test queueHealth: returns queue stats when Redis enabled
- Test queueHealth: returns unavailable when Redis disabled
- Test systemStatus: returns system info
- Verify protected (requires auth)

Create backend/tests/trpc/assets.router.test.ts:

- Mock assetStorageService
- Test getUploadUrl: returns pre-signed URL for valid input
- Test getUploadUrl: validates file type
- Test getUploadUrl: validates file size
- Verify orgProcedure (requires org context)

Create backend/tests/trpc/availability.router.test.ts:

- Mock availabilityService functions
- Test checkEmail: available email returns { available: true }
- Test checkEmail: taken email returns { available: false }
- Test checkPhone: available phone returns { available: true }
- Test checkPhone: taken phone returns { available: false }
- Verify public (no auth required)

Each test file should have ~6-10 test cases.
</action>
<verify>
npm run test -- backend/tests/trpc/admin.router.test.ts backend/tests/trpc/assets.router.test.ts backend/tests/trpc/availability.router.test.ts --run
</verify>
<done>
All utility router tests pass
</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit -p backend/tsconfig.json`
2. All three routers registered in appRouter
3. Public procedures work without authentication
4. All new tests pass
5. REST routes still work (parallel operation until frontend migrates)
</verification>

<success_criteria>

- adminRouter, assetsRouter, availabilityRouter exported and registered
- publicProcedure used for availability checks
- Pre-signed URL pattern for asset uploads
- 5 total procedures across 3 routers
- ~20 new tests passing
- Backend builds without type errors
  </success_criteria>

<output>
After completion, create `.planning/phases/21-backend-api-migration-completion/21-03-SUMMARY.md`
</output>
