---
phase: 40-settings-components
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/settings/WebhookStatusCard.tsx
  - src/components/settings/AlertRulesScopedEditor.tsx
autonomous: true

must_haves:
  truths:
    - "WebhookStatusCard renders webhook config and stats from tRPC without supabase"
    - "AlertRulesScopedEditor fetches sites and units from tRPC without supabase"
    - "Both components load and display data without errors"
  artifacts:
    - path: "src/components/settings/WebhookStatusCard.tsx"
      provides: "Webhook status display using tRPC"
      contains: "useTRPC"
    - path: "src/components/settings/AlertRulesScopedEditor.tsx"
      provides: "Alert rules editor using tRPC for sites/units"
      contains: "useTRPC"
  key_links:
    - from: "src/components/settings/WebhookStatusCard.tsx"
      to: "backend telnyx/webhook procedures"
      via: "queryOptions"
      pattern: "trpc\\.telnyx.*\\.queryOptions"
    - from: "src/components/settings/AlertRulesScopedEditor.tsx"
      to: "backend sites and units procedures"
      via: "queryOptions"
      pattern: "trpc\\.(sites|units).*\\.queryOptions"
---

<objective>
Migrate 2 medium-complexity settings components from supabase to tRPC data fetching.

Purpose: WebhookStatusCard has multiple queries (config + stats) and AlertRulesScopedEditor needs site/unit selection data. Both require careful handling of dependencies and multiple queries.

Output: 2 components using tRPC hooks instead of supabase-placeholder imports.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/38-test-infrastructure/38-01-SUMMARY.md (tRPC mock patterns)
@.planning/phases/39-dashboard-widgets/39-01-SUMMARY.md (widget migration patterns)
@src/hooks/useSites.ts (tRPC hook pattern reference)
@src/hooks/useUnits.ts (tRPC hook pattern reference)
@src/lib/trpc.ts (tRPC client setup)
@backend/src/routers/telnyx.router.ts (Telnyx procedures)
@backend/src/routers/sites.router.ts (sites procedures)
@backend/src/routers/units.router.ts (units procedures)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backend procedures for webhook data, then migrate WebhookStatusCard</name>
  <files>
    backend/src/routers/telnyx.router.ts
    src/components/settings/WebhookStatusCard.tsx
  </files>
  <action>
WebhookStatusCard currently queries two tables:
1. `telnyx_webhook_config` - config status
2. `telnyx_webhook_events` - event counts and last event

First, add backend procedures in telnyx.router.ts:

```typescript
/**
 * Get Telnyx webhook configuration for organization
 */
getWebhookConfig: orgProcedure
  .input(z.object({ organizationId: z.string().uuid() }))
  .output(z.object({
    id: z.string().uuid(),
    webhookId: z.string().nullable(),
    webhookUrl: z.string(),
    status: z.enum(['pending', 'active', 'error']),
    lastEventAt: z.date().nullable(),
    lastError: z.string().nullable(),
    createdAt: z.date(),
  }).nullable())
  .query(async ({ ctx }) => {
    // Query telnyx_webhook_config for org or global
    const config = await db.query.telnyxWebhookConfig.findFirst({
      where: or(
        eq(telnyxWebhookConfig.organizationId, ctx.user.organizationId),
        isNull(telnyxWebhookConfig.organizationId)
      ),
      orderBy: [desc(telnyxWebhookConfig.organizationId)], // Prefer org-specific
    });
    if (!config) return null;
    return {
      id: config.id,
      webhookId: config.webhookId,
      webhookUrl: config.webhookUrl,
      status: config.status,
      lastEventAt: config.lastEventAt,
      lastError: config.lastError,
      createdAt: config.createdAt,
    };
  }),

/**
 * Get Telnyx webhook event stats
 */
getWebhookStats: orgProcedure
  .input(z.object({ organizationId: z.string().uuid() }))
  .output(z.object({
    eventsToday: z.number(),
    lastEventType: z.string().nullable(),
  }))
  .query(async ({ ctx }) => {
    const todayStart = new Date();
    todayStart.setHours(0, 0, 0, 0);

    // Count events today
    const countResult = await db
      .select({ count: count() })
      .from(telnyxWebhookEvents)
      .where(gte(telnyxWebhookEvents.createdAt, todayStart));

    // Get last event type
    const lastEvent = await db.query.telnyxWebhookEvents.findFirst({
      orderBy: [desc(telnyxWebhookEvents.createdAt)],
      columns: { eventType: true },
    });

    return {
      eventsToday: countResult[0]?.count ?? 0,
      lastEventType: lastEvent?.eventType ?? null,
    };
  }),
```

Note: Check if telnyxWebhookConfig and telnyxWebhookEvents exist in drizzle schema. If not, may need to add schema or use raw SQL.

Then in WebhookStatusCard.tsx:
1. Remove: `import { supabase } from "@/lib/supabase-placeholder";`
2. Replace the two useQuery calls:

```tsx
const trpc = useTRPC();

// Fetch webhook config
const configQueryOptions = trpc.telnyx.getWebhookConfig.queryOptions({
  organizationId: organizationId!,
});
const { data: config, isLoading: configLoading } = useQuery({
  ...configQueryOptions,
  enabled: !!organizationId,
});

// Fetch webhook event stats
const statsQueryOptions = trpc.telnyx.getWebhookStats.queryOptions({
  organizationId: organizationId!,
});
const { data: stats } = useQuery({
  ...statsQueryOptions,
  enabled: !!organizationId,
  refetchInterval: 30000, // Refresh every 30 seconds
});
```

3. Update field references from snake_case to camelCase:
   - `webhook_id` -> `webhookId`
   - `webhook_url` -> `webhookUrl`
   - `last_event_at` -> `lastEventAt`
   - `last_error` -> `lastError`
   - `created_at` -> `createdAt`

4. The mutation for configureWebhook already uses tRPC - keep it as is.
  </action>
  <verify>
`grep -c "supabase-placeholder" src/components/settings/WebhookStatusCard.tsx` returns 0
`grep -c "useTRPC" src/components/settings/WebhookStatusCard.tsx` returns 1+
`npx tsc --noEmit` passes
  </verify>
  <done>WebhookStatusCard fetches data via tRPC, no supabase imports remain</done>
</task>

<task type="auto">
  <name>Task 2: Migrate AlertRulesScopedEditor to use existing tRPC hooks for sites/units</name>
  <files>src/components/settings/AlertRulesScopedEditor.tsx</files>
  <action>
AlertRulesScopedEditor uses supabase for two purposes:
1. `supabase.from("sites").select("id, name")` - site list for dropdown
2. `supabase.from("units").select(...)` - units list for dropdown (filtered by site)

Both can use existing hooks/procedures:
- Sites: `useSites` from `@/hooks/useSites` or `trpc.sites.list`
- Units: `useUnits` from `@/hooks/useUnits` or `trpc.units.listByOrg` with client-side filtering

Migration steps:
1. Remove: `import { supabase } from "@/lib/supabase-placeholder";`
2. Add imports:
```tsx
import { useSites } from "@/hooks/useSites";
import { useTRPC } from "@/lib/trpc";
import { useQuery } from "@tanstack/react-query";
```

3. Replace sites loading useEffect with useSites hook:
```tsx
// Remove useState for sites, isLoadingSites
const { data: sitesData, isLoading: isLoadingSites } = useSites(organizationId);
const sites = useMemo(() =>
  (sitesData ?? []).map(s => ({ id: s.id, name: s.name })),
  [sitesData]
);
```

4. Replace units loading useEffect with tRPC:
```tsx
const trpc = useTRPC();
const unitsQueryOptions = trpc.units.listByOrg.queryOptions({
  organizationId: organizationId!,
});
const { data: allUnits, isLoading: isLoadingUnits } = useQuery({
  ...unitsQueryOptions,
  enabled: !!organizationId && scopeTab === "unit" && !!selectedSiteId,
});

// Filter units for selected site
const units = useMemo(() => {
  if (!allUnits || !selectedSiteId) return [];
  return allUnits
    .filter(u => u.area?.siteId === selectedSiteId)
    .map(u => ({
      id: u.id,
      name: u.name,
      area_name: u.area?.name || '',
    }));
}, [allUnits, selectedSiteId]);
```

5. Remove the useEffects that load sites and units (lines ~78-119)

6. The hooks useOrgAlertRules, useSiteAlertRules, useUnitAlertRulesOverride, and useOrgNotificationPolicies, useSiteNotificationPolicies, useUnitNotificationPolicies should already be tRPC-based (from hooks/useAlertRules.ts and hooks/useNotificationPolicies.ts).

Note: Check that u.area?.siteId matches the field structure from units.listByOrg. May need to adjust field path based on actual response shape.
  </action>
  <verify>
`grep -c "supabase-placeholder" src/components/settings/AlertRulesScopedEditor.tsx` returns 0
`grep -c "useSites\|useTRPC" src/components/settings/AlertRulesScopedEditor.tsx` returns 1+
`npx tsc --noEmit` passes
  </verify>
  <done>AlertRulesScopedEditor fetches sites/units via tRPC, no supabase imports remain</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Check no supabase imports remain in migrated components:
```bash
grep -l "supabase-placeholder" src/components/settings/WebhookStatusCard.tsx src/components/settings/AlertRulesScopedEditor.tsx
```
Should return empty.

2. TypeScript compilation:
```bash
npx tsc --noEmit
```

3. Verify tRPC/hook usage:
```bash
grep -c "useTRPC\|useSites" src/components/settings/WebhookStatusCard.tsx
grep -c "useTRPC\|useSites" src/components/settings/AlertRulesScopedEditor.tsx
```
Each should return 1+.

4. Run backend tests if new procedures added:
```bash
npm run test:backend -- --testPathPattern="telnyx"
```
</verification>

<success_criteria>
- 2 components migrated from supabase to tRPC
- Zero supabase-placeholder imports in migrated files
- Backend procedures added as needed for webhook config/stats
- TypeScript compiles without errors
- Each component uses useTRPC() or existing hooks (useSites)
</success_criteria>

<output>
After completion, create `.planning/phases/40-settings-components/40-02-SUMMARY.md`
</output>
