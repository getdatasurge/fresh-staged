---
phase: 40-settings-components
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/settings/NotificationSettingsCard.tsx
  - src/components/settings/EmulatorResyncCard.tsx
autonomous: true

must_haves:
  truths:
    - "NotificationSettingsCard loads and saves notification settings via tRPC without supabase"
    - "EmulatorResyncCard loads sync log and triggers resync via tRPC without supabase"
    - "Both components handle CRUD operations correctly"
    - "Save/update operations work without errors"
  artifacts:
    - path: "src/components/settings/NotificationSettingsCard.tsx"
      provides: "Notification settings CRUD using tRPC"
      contains: "useTRPC"
    - path: "src/components/settings/EmulatorResyncCard.tsx"
      provides: "Emulator resync functionality using tRPC"
      contains: "useTRPC"
  key_links:
    - from: "src/components/settings/NotificationSettingsCard.tsx"
      to: "backend notification settings procedures"
      via: "queryOptions and mutate"
      pattern: "trpc\\..*Settings.*"
    - from: "src/components/settings/EmulatorResyncCard.tsx"
      to: "backend user sync procedures"
      via: "queryOptions and mutate"
      pattern: "trpc\\..*\\.(query|mutate)"
---

<objective>
Migrate 2 CRUD-heavy settings components from supabase to tRPC data fetching.

Purpose: NotificationSettingsCard has full CRUD for org notification settings, and EmulatorResyncCard has read + update operations. Both involve mutations in addition to queries.

Output: 2 components using tRPC hooks for both queries and mutations instead of supabase-placeholder imports.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/38-test-infrastructure/38-01-SUMMARY.md (tRPC mock patterns)
@.planning/phases/39-dashboard-widgets/39-01-SUMMARY.md (widget migration patterns)
@src/hooks/useSites.ts (tRPC hook pattern with mutations)
@src/lib/trpc.ts (tRPC client setup)
@backend/src/routers/notification-policies.router.ts (notification procedures)
@backend/src/routers/organizations.router.ts (org procedures)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backend procedures for notification settings, then migrate NotificationSettingsCard</name>
  <files>
    backend/src/routers/notification-policies.router.ts
    src/components/settings/NotificationSettingsCard.tsx
  </files>
  <action>
NotificationSettingsCard uses supabase for:
1. `supabase.from("notification_settings").select("*").eq("organization_id", organizationId).maybeSingle()` - load settings
2. `supabase.from("notification_settings").update({...}).eq("id", settings.id)` - update existing
3. `supabase.from("notification_settings").insert({...}).select().single()` - insert new

Add backend procedures in notification-policies.router.ts (or create notification-settings.router.ts):

```typescript
// Notification settings schema
const NotificationSettingsSchema = z.object({
  id: z.string().uuid().optional(),
  emailEnabled: z.boolean(),
  recipients: z.array(z.string()),
  notifyTempExcursion: z.boolean(),
  notifyAlarmActive: z.boolean(),
  notifyManualRequired: z.boolean(),
  notifyOffline: z.boolean(),
  notifyLowBattery: z.boolean(),
  notifyWarnings: z.boolean(),
});

/**
 * Get organization notification settings
 */
getNotificationSettings: orgProcedure
  .input(z.object({ organizationId: z.string().uuid() }))
  .output(NotificationSettingsSchema.nullable())
  .query(async ({ ctx }) => {
    const settings = await db.query.notificationSettings.findFirst({
      where: eq(notificationSettings.organizationId, ctx.user.organizationId),
    });
    if (!settings) return null;
    return {
      id: settings.id,
      emailEnabled: settings.emailEnabled,
      recipients: settings.recipients ?? [],
      notifyTempExcursion: settings.notifyTempExcursion,
      notifyAlarmActive: settings.notifyAlarmActive,
      notifyManualRequired: settings.notifyManualRequired,
      notifyOffline: settings.notifyOffline,
      notifyLowBattery: settings.notifyLowBattery,
      notifyWarnings: settings.notifyWarnings,
    };
  }),

/**
 * Upsert organization notification settings
 */
upsertNotificationSettings: orgProcedure
  .input(z.object({
    organizationId: z.string().uuid(),
    data: NotificationSettingsSchema.omit({ id: true }),
  }))
  .output(NotificationSettingsSchema)
  .mutation(async ({ ctx, input }) => {
    // Admin/owner check
    if (!['admin', 'owner'].includes(ctx.user.role)) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: 'Only administrators can update notification settings',
      });
    }

    const existing = await db.query.notificationSettings.findFirst({
      where: eq(notificationSettings.organizationId, ctx.user.organizationId),
    });

    if (existing) {
      // Update
      const [updated] = await db
        .update(notificationSettings)
        .set(input.data)
        .where(eq(notificationSettings.id, existing.id))
        .returning();
      return { ...input.data, id: updated.id };
    } else {
      // Insert
      const [created] = await db
        .insert(notificationSettings)
        .values({ ...input.data, organizationId: ctx.user.organizationId })
        .returning();
      return { ...input.data, id: created.id };
    }
  }),
```

Note: Check if notificationSettings table exists in drizzle schema.

Then in NotificationSettingsCard.tsx:
1. Remove: `import { supabase } from "@/lib/supabase-placeholder";`
2. Add imports:
```tsx
import { useTRPC, useTRPCClient } from "@/lib/trpc";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
```

3. Replace loadSettings with useQuery:
```tsx
const trpc = useTRPC();
const queryClient = useQueryClient();
const client = useTRPCClient();

const settingsQueryOptions = trpc.notificationPolicies.getNotificationSettings.queryOptions({
  organizationId: organizationId!,
});
const { data: loadedSettings, isLoading } = useQuery({
  ...settingsQueryOptions,
  enabled: !!organizationId,
});

// Sync to local state when loaded
useEffect(() => {
  if (loadedSettings) {
    setSettings({
      id: loadedSettings.id,
      email_enabled: loadedSettings.emailEnabled,
      recipients: loadedSettings.recipients,
      notify_temp_excursion: loadedSettings.notifyTempExcursion,
      notify_alarm_active: loadedSettings.notifyAlarmActive,
      notify_manual_required: loadedSettings.notifyManualRequired,
      notify_offline: loadedSettings.notifyOffline,
      notify_low_battery: loadedSettings.notifyLowBattery,
      notify_warnings: loadedSettings.notifyWarnings,
    });
  }
}, [loadedSettings]);
```

4. Replace saveSettings with useMutation:
```tsx
const saveMutation = useMutation({
  mutationFn: async (data: typeof settings) => {
    return client.notificationPolicies.upsertNotificationSettings.mutate({
      organizationId: organizationId!,
      data: {
        emailEnabled: data.email_enabled,
        recipients: data.recipients,
        notifyTempExcursion: data.notify_temp_excursion,
        notifyAlarmActive: data.notify_alarm_active,
        notifyManualRequired: data.notify_manual_required,
        notifyOffline: data.notify_offline,
        notifyLowBattery: data.notify_low_battery,
        notifyWarnings: data.notify_warnings,
      },
    });
  },
  onSuccess: (result) => {
    setSettings(prev => ({ ...prev, id: result.id }));
    queryClient.invalidateQueries({ queryKey: settingsQueryOptions.queryKey });
    toast.success("Notification settings saved");
  },
  onError: (error) => {
    toast.error(`Failed to save: ${error.message}`);
  },
});

const saveSettings = async () => {
  saveMutation.mutate(settings);
};
```

5. Replace `isSaving` with `saveMutation.isPending`
  </action>
  <verify>
`grep -c "supabase-placeholder" src/components/settings/NotificationSettingsCard.tsx` returns 0
`grep -c "useTRPC" src/components/settings/NotificationSettingsCard.tsx` returns 1+
`npx tsc --noEmit` passes
  </verify>
  <done>NotificationSettingsCard uses tRPC for all data operations, no supabase imports remain</done>
</task>

<task type="auto">
  <name>Task 2: Add backend procedures for user sync, then migrate EmulatorResyncCard</name>
  <files>
    backend/src/routers/users.router.ts
    src/components/settings/EmulatorResyncCard.tsx
  </files>
  <action>
EmulatorResyncCard uses supabase for:
1. `supabase.from("user_sync_log").select("*").eq("user_id", user.id).order("created_at", { ascending: false }).limit(1).maybeSingle()` - get last sync
2. `supabase.from("profiles").update({ updated_at: ... }).eq("user_id", user.id)` - trigger sync

Add backend procedures in users.router.ts:

```typescript
/**
 * Get last user sync log entry
 */
getLastSyncLog: protectedProcedure
  .output(z.object({
    id: z.string().uuid(),
    userId: z.string(),
    eventType: z.string(),
    payload: z.record(z.unknown()),
    status: z.string(),
    lastError: z.string().nullable(),
    createdAt: z.date(),
    sentAt: z.date().nullable(),
  }).nullable())
  .query(async ({ ctx }) => {
    const log = await db.query.userSyncLog.findFirst({
      where: eq(userSyncLog.userId, ctx.user.userId),
      orderBy: [desc(userSyncLog.createdAt)],
    });
    if (!log) return null;
    return {
      id: log.id,
      userId: log.userId,
      eventType: log.eventType,
      payload: log.payload ?? {},
      status: log.status,
      lastError: log.lastError,
      createdAt: log.createdAt,
      sentAt: log.sentAt,
    };
  }),

/**
 * Trigger emulator sync by updating profile
 */
triggerEmulatorSync: protectedProcedure
  .output(z.object({ success: z.boolean() }))
  .mutation(async ({ ctx }) => {
    await db
      .update(profiles)
      .set({ updatedAt: new Date() })
      .where(eq(profiles.userId, ctx.user.userId));
    return { success: true };
  }),
```

Note: Check if userSyncLog and profiles tables exist in drizzle schema.

Then in EmulatorResyncCard.tsx:
1. Remove: `import { supabase } from "@/lib/supabase-placeholder";`
2. Add imports:
```tsx
import { useTRPC, useTRPCClient } from "@/lib/trpc";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
```

3. Replace the useQuery for lastSync:
```tsx
const trpc = useTRPC();
const queryClient = useQueryClient();
const client = useTRPCClient();

const syncLogQueryOptions = trpc.users.getLastSyncLog.queryOptions();
const { data: lastSync, refetch: refetchSync } = useQuery({
  ...syncLogQueryOptions,
  enabled: !!organizationId,
});
```

4. Replace handleResync with useMutation:
```tsx
const resyncMutation = useMutation({
  mutationFn: () => client.users.triggerEmulatorSync.mutate(),
  onSuccess: () => {
    toast.success("Sync triggered - check Emulator in a few seconds");
    // Wait a moment then refetch to show new sync status
    setTimeout(() => {
      refetchSync();
    }, 2000);
  },
  onError: (error) => {
    toast.error(`Sync failed: ${error.message}`);
  },
});

const handleResync = () => {
  if (!organizationId || !user) {
    toast.error("No organization or user found");
    return;
  }
  resyncMutation.mutate();
};
```

5. Replace `isSyncing` with `resyncMutation.isPending`

6. Update field references from snake_case to camelCase:
   - `user_id` -> `userId`
   - `event_type` -> `eventType`
   - `last_error` -> `lastError`
   - `created_at` -> `createdAt`
   - `sent_at` -> `sentAt`

Note: The ttnPayload access `lastSync?.payload?.ttn` stays the same structure since payload is returned as-is.
  </action>
  <verify>
`grep -c "supabase-placeholder" src/components/settings/EmulatorResyncCard.tsx` returns 0
`grep -c "useTRPC" src/components/settings/EmulatorResyncCard.tsx` returns 1+
`npx tsc --noEmit` passes
  </verify>
  <done>EmulatorResyncCard uses tRPC for all data operations, no supabase imports remain</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Check no supabase imports remain in migrated components:
```bash
grep -l "supabase-placeholder" src/components/settings/NotificationSettingsCard.tsx src/components/settings/EmulatorResyncCard.tsx
```
Should return empty.

2. TypeScript compilation:
```bash
npx tsc --noEmit
```

3. Verify tRPC usage:
```bash
grep -c "useTRPC" src/components/settings/NotificationSettingsCard.tsx
grep -c "useTRPC" src/components/settings/EmulatorResyncCard.tsx
```
Each should return 1+.

4. Verify mutation patterns:
```bash
grep -c "useMutation" src/components/settings/NotificationSettingsCard.tsx
grep -c "useMutation" src/components/settings/EmulatorResyncCard.tsx
```
Each should return 1+.

5. Run backend tests:
```bash
npm run test:backend -- --testPathPattern="notification|users"
```
</verification>

<success_criteria>
- 2 components migrated from supabase to tRPC
- Zero supabase-placeholder imports in migrated files
- Backend procedures added for CRUD operations
- TypeScript compiles without errors
- Each component uses useTRPC() with both queryOptions and mutations
- Save/update operations work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/40-settings-components/40-03-SUMMARY.md`
</output>
