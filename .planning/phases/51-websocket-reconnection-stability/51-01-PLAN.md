---
phase: 51-websocket-reconnection-stability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/socket.ts
  - src/providers/RealtimeProvider.tsx
  - src/components/common/ConnectionStatus.tsx
autonomous: true

must_haves:
  truths:
    - "Socket.io connection persists through JWT token refresh (no disconnect/reconnect cycle)"
    - "Socket.io uses WebSocket transport only (no polling fallback/upgrade)"
    - "No visible connecting-to-connected flicker during normal app usage"
    - "Socket.io still reconnects correctly after actual network disconnection"
    - "Real-time updates (sensor data, alerts) continue working after reconnect"
  artifacts:
    - path: "src/lib/socket.ts"
      provides: "Auth callback function pattern + setTokenGetter export"
      exports: ["socket", "setTokenGetter", "connectSocket", "disconnectSocket"]
      contains: "auth: (cb)"
    - path: "src/providers/RealtimeProvider.tsx"
      provides: "Stable useEffect with token getter registration"
      contains: "setTokenGetter"
    - path: "src/components/common/ConnectionStatus.tsx"
      provides: "Debounced connecting state to suppress brief flicker"
      contains: "setTimeout"
  key_links:
    - from: "src/lib/socket.ts"
      to: "socket.io-client"
      via: "auth callback function invoked on every connect/reconnect"
      pattern: "auth:\\s*\\(cb\\)"
    - from: "src/providers/RealtimeProvider.tsx"
      to: "src/lib/socket.ts"
      via: "setTokenGetter called in useEffect to register fresh token source"
      pattern: "setTokenGetter"
    - from: "src/providers/RealtimeProvider.tsx"
      to: "@stackframe/react"
      via: "userRef.current.getAccessToken() called by token getter"
      pattern: "getAccessToken"
---

<objective>
Eliminate Socket.io reconnection flicker by replacing the imperative `socket.auth = { token }` pattern with Socket.io's `auth` callback function, which is invoked on every connection and reconnection attempt and waits for the callback before sending the handshake. Add a debounce to the ConnectionStatus UI to suppress brief visual transitions.

Purpose: The current `onReconnectAttempt` handler has a race condition — `getAccessToken()` is async but the handshake may be sent before the Promise resolves, causing auth failures and reconnection flicker. The `auth: (cb) => {...}` callback form is the official Socket.io solution that eliminates this race.

Output: Modified `src/lib/socket.ts` with auth callback, modified `RealtimeProvider.tsx` with token getter registration, and debounced `ConnectionStatus.tsx`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-websocket-reconnection-stability/51-RESEARCH.md

# Source files to modify
@src/lib/socket.ts
@src/providers/RealtimeProvider.tsx
@src/components/common/ConnectionStatus.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert socket auth to callback pattern and simplify RealtimeProvider</name>
  <files>src/lib/socket.ts, src/providers/RealtimeProvider.tsx</files>
  <action>
**src/lib/socket.ts** — Replace imperative auth with callback function:

1. Add a module-level `tokenGetter` variable:
   ```typescript
   let tokenGetter: (() => Promise<string | null>) | null = null;
   ```

2. Add `auth` callback to the `io()` options (alongside existing `autoConnect`, `transports`, `reconnection`, etc.):
   ```typescript
   auth: (cb) => {
     if (tokenGetter) {
       tokenGetter()
         .then((token) => cb({ token: token || '' }))
         .catch(() => cb({ token: '' }));
     } else {
       cb({ token: '' });
     }
   },
   ```

3. Export `setTokenGetter`:
   ```typescript
   export function setTokenGetter(getter: (() => Promise<string | null>) | null) {
     tokenGetter = getter;
   }
   ```

4. Change `connectSocket` to take NO arguments (remove the `token` parameter). It should just call `socket.connect()`. The auth callback handles token fetching automatically.

5. Keep all existing type interfaces (`ServerToClientEvents`, `ClientToServerEvents`, `SensorReading`, `AlertNotification`, `UnitStateChangeEvent`, `UnitDashboardState`) unchanged.

6. Keep all existing socket options (`autoConnect: false`, `transports: ['websocket']`, `reconnection: true`, `reconnectionAttempts: 5`, `reconnectionDelay: 2000`, `reconnectionDelayMax: 10000`, `timeout: 20000`) unchanged.

**src/providers/RealtimeProvider.tsx** — Use token getter instead of reconnect handler:

1. Update imports: Add `setTokenGetter` from `@/lib/socket`. Remove `connectSocket` parameter usage (it now takes no args).

2. In the `useEffect` body, REPLACE the `connectWithAuth` async function with:
   - Call `setTokenGetter(() => {...})` to register a token getter that uses `userRef.current.getAccessToken()`
   - Call `setIsConnecting(true)` and `setConnectionError(null)`
   - Call `connectSocket()` (no token argument)

   The token getter function should be:
   ```typescript
   setTokenGetter(() => {
     const currentUser = userRef.current;
     if (!currentUser) return Promise.resolve(null);
     return currentUser.getAccessToken();
   });
   ```

3. REMOVE the `onReconnectAttempt` handler entirely (lines 108-119 in current code). The auth callback now handles fresh token fetching on every reconnect automatically.

4. REMOVE the `socket.io.on('reconnect_attempt', onReconnectAttempt)` listener registration (line 124) and its cleanup in the return function (line 139).

5. In the cleanup function, add `setTokenGetter(null)` to clean up the token getter reference.

6. Keep the `onConnect`, `onDisconnect`, `onConnectError` handlers unchanged.

7. Keep the `connectErrorCountRef` pattern unchanged.

8. Keep the `userId` dependency array unchanged — it is already correct.

9. Keep the conditional `{isConnected && <RealtimeHandlers />}` rendering unchanged.

**Why NOT jsonwebtoken or jose on the client:** Stack Auth's `getAccessToken()` handles all token refresh logic internally. We never decode or verify JWTs on the client.

**Why remove onReconnectAttempt:** The auth callback form is invoked by Socket.io on EVERY connection and reconnection attempt, and Socket.io WAITS for the `cb()` call before sending the handshake. This eliminates the race condition where `getAccessToken()` might not resolve before the handshake is sent.
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` — zero TypeScript errors in frontend
2. `cd backend && pnpm exec tsc --noEmit` — zero TypeScript errors in backend (should be unaffected)
3. Grep for `socket.auth = { token }` in src/ — should NOT exist (replaced by callback)
4. Grep for `reconnect_attempt` in src/providers/ — should NOT exist (handler removed)
5. Grep for `auth: (cb)` in src/lib/socket.ts — should exist (callback pattern)
6. Grep for `setTokenGetter` in src/providers/RealtimeProvider.tsx — should exist
  </verify>
  <done>
- `connectSocket()` takes no arguments; auth callback fetches fresh token on every connect/reconnect
- No `onReconnectAttempt` handler exists (race condition eliminated)
- `setTokenGetter` is called in useEffect to register the token source
- `setTokenGetter(null)` is called in useEffect cleanup
- Both frontend and backend TypeScript compilation passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Add debounce to ConnectionStatus connecting indicator</name>
  <files>src/components/common/ConnectionStatus.tsx</files>
  <action>
Add a 500ms debounce before showing the "connecting" spinner in `ConnectionStatus.tsx`. This prevents brief visual flicker during quick reconnection cycles.

1. Add `useState` and `useEffect` imports (useState is likely already available via the existing component).

2. Add a debounced state inside the `ConnectionStatus` component:
   ```typescript
   const [showConnecting, setShowConnecting] = useState(false);

   useEffect(() => {
     if (isConnecting) {
       const timer = setTimeout(() => setShowConnecting(true), 500);
       return () => clearTimeout(timer);
     }
     setShowConnecting(false);
   }, [isConnecting]);
   ```

3. In `getStatusConfig()`, change the first condition from `if (isConnecting)` to `if (showConnecting)` so the yellow spinning loader only appears after 500ms of continuous "connecting" state.

4. Keep everything else unchanged: the Tooltip, icons, color classes, animate logic.

**Why 500ms:** Brief reconnections (network hiccup, token refresh) typically resolve in under 500ms. Only sustained connection issues should show visual feedback to avoid distracting the user.
  </action>
  <verify>
1. `pnpm exec tsc --noEmit` — zero TypeScript errors
2. Grep for `setTimeout` in ConnectionStatus.tsx — should exist (debounce timer)
3. Grep for `showConnecting` in ConnectionStatus.tsx — should exist (debounced state)
  </verify>
  <done>
- ConnectionStatus only shows the connecting spinner after 500ms of continuous connecting state
- Brief reconnections (under 500ms) produce no visible UI change
- TypeScript compilation passes
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **TypeScript clean build:**
   - `pnpm exec tsc --noEmit` passes with zero errors (frontend)
   - `cd backend && pnpm exec tsc --noEmit` passes with zero errors (backend)

2. **Auth callback pattern in place:**
   - `src/lib/socket.ts` contains `auth: (cb) =>` in socket options
   - `src/lib/socket.ts` exports `setTokenGetter`
   - `connectSocket()` takes no arguments

3. **Race condition eliminated:**
   - No `reconnect_attempt` handler in RealtimeProvider
   - No imperative `socket.auth = { token }` anywhere in `src/`

4. **Token getter lifecycle:**
   - `setTokenGetter(...)` called in useEffect body
   - `setTokenGetter(null)` called in useEffect cleanup

5. **UI debounce:**
   - ConnectionStatus uses 500ms debounce before showing connecting spinner
</verification>

<success_criteria>
- WS-01: Socket.io auth uses callback function that fetches fresh JWT on every connect/reconnect (no race condition)
- WS-02: Socket.io client has `transports: ['websocket']` (already present, preserved)
- WS-03: No visible connecting flicker — auth callback eliminates unnecessary disconnects, debounce suppresses brief transitions
- Both TypeScript compilations pass with zero errors
- No regression in real-time event handling (sensor data, alerts, unit state)
</success_criteria>

<output>
After completion, create `.planning/phases/51-websocket-reconnection-stability/51-01-SUMMARY.md`
</output>
