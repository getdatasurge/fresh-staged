---
phase: 05-frontend-migration
plan: 05
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/hooks/useNavTree.ts
  - src/hooks/useBranding.ts
  - src/hooks/useSoftDelete.ts
autonomous: true

must_haves:
  truths:
    - "Navigation tree loads from new API"
    - "Branding loads from new API"
    - "Soft delete operations use new API"
  artifacts:
    - path: "src/hooks/useNavTree.ts"
      provides: "Site/area/unit navigation hierarchy"
      exports: ["useNavTree"]
    - path: "src/hooks/useBranding.ts"
      provides: "Organization branding"
      exports: ["useBranding"]
    - path: "src/hooks/useSoftDelete.ts"
      provides: "Soft delete operations"
      exports: ["useSoftDelete"]
  key_links:
    - from: "src/hooks/useNavTree.ts"
      to: "src/lib/api/sites.ts"
      via: "import sitesApi"
      pattern: "sitesApi"
---

<objective>
Migrate navigation and organization data hooks to new API.

Purpose: These hooks provide essential navigation and organization-level data that many components depend on.

Output:
- useNavTree fetches hierarchy from new API
- useBranding fetches org branding from new API
- useSoftDelete uses new API for delete operations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-frontend-migration/05-RESEARCH.md
@.planning/phases/05-frontend-migration/05-01-SUMMARY.md
@.planning/phases/05-frontend-migration/05-02-SUMMARY.md
@src/hooks/useNavTree.ts
@src/hooks/useBranding.ts
@src/hooks/useSoftDelete.ts
@src/lib/queryKeys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate useNavTree</name>
  <files>src/hooks/useNavTree.ts</files>
  <action>
Migrate `useNavTree.ts` from Supabase to the new API:

**This hook likely:**
- Fetches sites for an org
- Fetches areas for each site
- Fetches units for each area
- Builds a hierarchical tree structure for navigation

**Migration pattern:**
```typescript
import { useQuery } from "@tanstack/react-query";
import { useUser } from "@stackframe/stack";
import { sitesApi, areasApi, unitsApi } from "@/lib/api";
import { qk } from "@/lib/queryKeys";
import { useOrgScope } from "./useOrgScope";

export function useNavTree() {
  const { orgId, isReady } = useOrgScope();
  const user = useUser();

  return useQuery({
    queryKey: qk.org(orgId).navTree(),  // SAME query key
    queryFn: async () => {
      if (!orgId || !user) return null;
      const { accessToken } = await user.getAuthJson();

      // Fetch sites
      const sites = await sitesApi.listSites(orgId, accessToken);

      // For each site, fetch areas
      const sitesWithAreas = await Promise.all(
        sites.map(async (site) => {
          const areas = await areasApi.listAreas(orgId, site.id, accessToken);

          // For each area, fetch units
          const areasWithUnits = await Promise.all(
            areas.map(async (area) => {
              const units = await unitsApi.listUnits(orgId, site.id, area.id, accessToken);
              return { ...area, units };
            })
          );

          return { ...site, areas: areasWithUnits };
        })
      );

      return sitesWithAreas;
    },
    enabled: isReady && !!user,
  });
}
```

**Important:**
- Preserve exact query key: `qk.org(orgId).navTree()`
- Maintain same return structure for consuming components
- Consider adding error handling for individual fetch failures
  </action>
  <verify>Hook compiles, uses new API imports, preserves query key</verify>
  <done>useNavTree fetches hierarchy via sitesApi, areasApi, unitsApi</done>
</task>

<task type="auto">
  <name>Task 2: Migrate useBranding</name>
  <files>src/hooks/useBranding.ts</files>
  <action>
Migrate `useBranding.ts` from Supabase to the new API:

**This hook likely:**
- Fetches organization branding (logo, colors, etc.)
- May use org profile data

**Migration pattern:**
```typescript
import { useQuery } from "@tanstack/react-query";
import { useUser } from "@stackframe/stack";
import { organizationsApi } from "@/lib/api";
import { qk } from "@/lib/queryKeys";
import { useOrgScope } from "./useOrgScope";

export function useBranding() {
  const { orgId, isReady } = useOrgScope();
  const user = useUser();

  return useQuery({
    queryKey: qk.org(orgId).branding(),  // SAME query key
    queryFn: async () => {
      if (!orgId || !user) return null;
      const { accessToken } = await user.getAuthJson();

      const org = await organizationsApi.getOrganization(orgId, accessToken);
      return {
        logoUrl: org.logoUrl,
        name: org.name,
        // Add other branding fields as needed
      };
    },
    enabled: isReady && !!user,
  });
}
```

Check existing hook implementation for exact fields needed and preserve return type.
  </action>
  <verify>Hook compiles, uses organizationsApi, preserves query key</verify>
  <done>useBranding fetches org branding via organizationsApi</done>
</task>

<task type="auto">
  <name>Task 3: Migrate useSoftDelete</name>
  <files>src/hooks/useSoftDelete.ts</files>
  <action>
Migrate `useSoftDelete.ts` from Supabase to the new API:

**This hook likely:**
- Provides soft delete operations for sites, areas, units
- Handles cache invalidation after delete
- May handle bulk operations

**Migration pattern:**
```typescript
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useUser } from "@stackframe/stack";
import { sitesApi, areasApi, unitsApi } from "@/lib/api";
import { qk } from "@/lib/queryKeys";
import { useOrgScope } from "./useOrgScope";

export function useSoftDelete() {
  const { orgId } = useOrgScope();
  const user = useUser();
  const queryClient = useQueryClient();

  const deleteSite = useMutation({
    mutationFn: async (siteId: string) => {
      if (!orgId || !user) throw new Error('Not authenticated');
      const { accessToken } = await user.getAuthJson();
      return sitesApi.deleteSite(orgId, siteId, accessToken);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: qk.org(orgId).sites() });
      queryClient.invalidateQueries({ queryKey: qk.org(orgId).navTree() });
    },
  });

  const deleteArea = useMutation({
    mutationFn: async ({ siteId, areaId }: { siteId: string; areaId: string }) => {
      if (!orgId || !user) throw new Error('Not authenticated');
      const { accessToken } = await user.getAuthJson();
      return areasApi.deleteArea(orgId, siteId, areaId, accessToken);
    },
    onSuccess: (_, { siteId }) => {
      queryClient.invalidateQueries({ queryKey: qk.site(siteId).areas() });
      queryClient.invalidateQueries({ queryKey: qk.org(orgId).navTree() });
    },
  });

  const deleteUnit = useMutation({
    mutationFn: async ({ siteId, areaId, unitId }: { siteId: string; areaId: string; unitId: string }) => {
      if (!orgId || !user) throw new Error('Not authenticated');
      const { accessToken } = await user.getAuthJson();
      return unitsApi.deleteUnit(orgId, siteId, areaId, unitId, accessToken);
    },
    onSuccess: (_, { areaId }) => {
      queryClient.invalidateQueries({ queryKey: qk.unit(null).all }); // Invalidate unit queries
      queryClient.invalidateQueries({ queryKey: qk.org(orgId).navTree() });
    },
  });

  return {
    deleteSite,
    deleteArea,
    deleteUnit,
  };
}
```

Preserve exact return interface and invalidation patterns from original hook.
  </action>
  <verify>Hook compiles, mutations use new API, invalidation works</verify>
  <done>useSoftDelete uses new API for all delete operations with proper cache invalidation</done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes
2. No Supabase imports in migrated hooks
3. Query keys preserved exactly from original implementations
4. Navigation tree loads in UI
5. Soft delete operations work with proper cache invalidation
</verification>

<success_criteria>
- useNavTree builds hierarchy from new API calls
- useBranding fetches org branding via organizationsApi
- useSoftDelete uses sitesApi, areasApi, unitsApi for delete operations
- All query keys preserved for cache continuity
</success_criteria>

<output>
After completion, create `.planning/phases/05-frontend-migration/05-05-SUMMARY.md`
</output>
