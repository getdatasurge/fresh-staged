---
phase: 05-frontend-migration
plan: 10
type: execute
wave: 4
depends_on: ['05-04', '05-05', '05-06', '05-07', '05-08', '05-09']
files_modified:
  - src/hooks/useCan.tsx
  - .env.example
  - vite.config.ts
autonomous: true

must_haves:
  truths:
    - 'Permission hook uses Stack Auth'
    - 'Environment variables configured for local backend'
    - 'Frontend can connect to local backend'
  artifacts:
    - path: 'src/hooks/useCan.tsx'
      provides: 'Permission checking'
      exports: ['useCan', 'Can']
    - path: '.env.example'
      provides: 'Environment variable documentation'
      contains: 'VITE_API_URL'
  key_links:
    - from: 'vite.config.ts'
      to: 'backend server'
      via: 'proxy configuration'
      pattern: 'proxy|VITE_API_URL'
---

<objective>
Finalize hook migration and configure frontend-backend connection.

Purpose: Complete the migration by updating remaining hooks and configuring the frontend to connect to the local backend.

Output:

- useCan hook migrated to Stack Auth
- Environment variables configured
- Frontend can connect to local backend server
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-frontend-migration/05-RESEARCH.md
@.planning/phases/05-frontend-migration/05-04-SUMMARY.md
@src/hooks/useCan.tsx
@.env.example
@vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate useCan permission hook</name>
  <files>src/hooks/useCan.tsx</files>
  <action>
Migrate `useCan.tsx` from Supabase to Stack Auth:

**useCan likely:**

- Checks if current user has permission for an action
- Uses role-based checks
- May provide Can component for declarative permission checks

**Migration:**

```typescript
import { useUser } from "@stackframe/stack";
import { useUserRole } from "./useUserRole";
import { useOrgScope } from "./useOrgScope";

type Permission = 'read' | 'create' | 'update' | 'delete' | 'admin' | 'owner';
type Resource = 'site' | 'area' | 'unit' | 'sensor' | 'alert' | 'settings';

// Role hierarchy (same as backend)
const ROLE_LEVELS = {
  viewer: 1,
  staff: 2,
  manager: 3,
  admin: 4,
  owner: 5,
} as const;

// Permission requirements
const PERMISSION_REQUIREMENTS: Record<Permission, Record<Resource, number>> = {
  read: { site: 1, area: 1, unit: 1, sensor: 1, alert: 1, settings: 1 },
  create: { site: 4, area: 4, unit: 3, sensor: 3, alert: 2, settings: 4 },
  update: { site: 4, area: 4, unit: 3, sensor: 3, alert: 2, settings: 4 },
  delete: { site: 4, area: 4, unit: 3, sensor: 3, alert: 4, settings: 5 },
  admin: { site: 4, area: 4, unit: 4, sensor: 4, alert: 4, settings: 4 },
  owner: { site: 5, area: 5, unit: 5, sensor: 5, alert: 5, settings: 5 },
};

export function useCan() {
  const { orgId, isReady } = useOrgScope();
  const { data: role, isLoading: roleLoading } = useUserRole(orgId);
  const user = useUser();

  const can = (permission: Permission, resource: Resource): boolean => {
    if (!isReady || !role || !user) return false;
    const requiredLevel = PERMISSION_REQUIREMENTS[permission]?.[resource] ?? 5;
    const userLevel = ROLE_LEVELS[role as keyof typeof ROLE_LEVELS] ?? 0;
    return userLevel >= requiredLevel;
  };

  const isLoading = !isReady || roleLoading;

  return { can, isLoading, role };
}

// Declarative Can component
interface CanProps {
  permission: Permission;
  resource: Resource;
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

export function Can({ permission, resource, children, fallback = null }: CanProps) {
  const { can, isLoading } = useCan();

  if (isLoading) return null;
  if (!can(permission, resource)) return <>{fallback}</>;
  return <>{children}</>;
}
```

Preserve the existing permission model and interface. Adjust permission mappings based on actual implementation.
</action>
<verify>Hook compiles, uses Stack Auth/useUserRole, Can component works</verify>
<done>useCan and Can component use Stack Auth role checking</done>
</task>

<task type="auto">
  <name>Task 2: Configure environment variables</name>
  <files>.env.example, .env.local (create if needed)</files>
  <action>
Update environment variable configuration for the new backend:

**Update .env.example:**

```env
# Frontend API Configuration
# URL of the self-hosted backend API
VITE_API_URL=http://localhost:3000

# Stack Auth Configuration
# These should already exist for Stack Auth integration
VITE_STACK_AUTH_PROJECT_ID=your-project-id
VITE_STACK_AUTH_PUBLISHABLE_CLIENT_KEY=your-client-key

# Feature Flags (optional)
# Set to 'true' to enable debug logging for API calls
VITE_DEBUG_API=false

# Legacy Supabase (temporary - remove after full migration)
# VITE_SUPABASE_URL=
# VITE_SUPABASE_ANON_KEY=
```

**Document the variables:**
Add comments explaining:

- VITE_API_URL: Points to self-hosted backend (default: localhost:3000)
- Stack Auth vars: Required for authentication
- Debug flag: Enables verbose API logging

**Note:** Do NOT commit actual .env.local with secrets. Only update .env.example as documentation.
</action>
<verify>.env.example contains VITE_API_URL and documentation</verify>
<done>Environment variables documented with new backend URL</done>
</task>

<task type="auto">
  <name>Task 3: Configure Vite proxy (optional) and verify connection</name>
  <files>vite.config.ts</files>
  <action>
Review and optionally configure Vite proxy for local development:

**Option 1: Direct connection (recommended)**
Frontend directly calls backend at VITE_API_URL (e.g., http://localhost:3000).
Backend must have CORS configured to allow frontend origin.

**Option 2: Vite proxy**
If CORS is an issue during development, add proxy to vite.config.ts:

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react-swc';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
        secure: false,
      },
    },
  },
  // ... existing config
});
```

If using proxy, update api-client.ts to use relative URL:

```typescript
const API_BASE_URL = import.meta.env.DEV ? '' : import.meta.env.VITE_API_URL;
```

**Recommendation:** Start with direct connection. Backend should have CORS configured from Phase 2/3. Only add proxy if needed.

**Verify setup:**

1. Start backend: `cd backend && pnpm dev`
2. Start frontend: `pnpm dev`
3. Check browser console for API connection
   </action>
   <verify>Frontend starts without errors, can make requests to backend (after backend is running)</verify>
   <done>Frontend configured to connect to local backend</done>
   </task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes
2. useCan hook works with Stack Auth
3. .env.example documents VITE_API_URL
4. Frontend starts with `pnpm dev`
5. API client configured with correct base URL
</verification>

<success_criteria>

- useCan permission hook uses Stack Auth role checking
- Environment variables properly documented
- Frontend can be configured to connect to local backend
- All hook migrations complete (27 hooks updated)
  </success_criteria>

<output>
After completion, create `.planning/phases/05-frontend-migration/05-10-SUMMARY.md`
</output>
