---
phase: 05-frontend-migration
plan: 07
type: execute
wave: 3
depends_on: ['05-04', '05-05']
files_modified:
  - src/hooks/useSiteLocationMutation.ts
  - src/hooks/useEscalationContacts.ts
  - src/hooks/useNotificationPolicies.ts
autonomous: true

must_haves:
  truths:
    - 'Site location mutation uses sitesApi (fully migrated)'
    - 'Escalation contacts hook uses Stack Auth with Supabase data calls marked TODO'
    - 'Notification policies hook uses Stack Auth with Supabase data calls marked TODO'
  artifacts:
    - path: 'src/hooks/useSiteLocationMutation.ts'
      provides: 'Site location update via sitesApi'
      exports: ['useSiteLocationMutation']
    - path: 'src/hooks/useEscalationContacts.ts'
      provides: 'Escalation contacts queries (hybrid)'
      exports: ['useEscalationContacts']
    - path: 'src/hooks/useNotificationPolicies.ts'
      provides: 'Notification policies queries (hybrid)'
      exports: ['useNotificationPolicies']
  key_links:
    - from: 'src/hooks/useSiteLocationMutation.ts'
      to: 'src/lib/api/sites.ts'
      via: 'import sitesApi'
      pattern: "sitesApi\\.updateSite"
---

<objective>
Migrate fully-migratable hooks (site location) and notification/escalation hooks to Stack Auth.

Purpose: Site location mutation can be fully migrated to sitesApi. Escalation contacts and notification policies don't have backend endpoints yet, so they use Stack Auth for identity but keep Supabase data calls with clear TODO markers.

Output:

- useSiteLocationMutation fully migrated to sitesApi
- useEscalationContacts uses Stack Auth, Supabase data calls marked
- useNotificationPolicies uses Stack Auth, Supabase data calls marked
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-frontend-migration/05-RESEARCH.md
@.planning/phases/05-frontend-migration/05-04-SUMMARY.md
@.planning/phases/05-frontend-migration/05-05-SUMMARY.md
@src/hooks/useSiteLocationMutation.ts
@src/hooks/useEscalationContacts.ts
@src/hooks/useNotificationPolicies.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate useSiteLocationMutation to sitesApi</name>
  <files>src/hooks/useSiteLocationMutation.ts</files>
  <action>
Migrate `useSiteLocationMutation.ts` to use sitesApi (backend has sites endpoints):

```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useUser } from '@stackframe/stack';
import { sitesApi } from '@/lib/api';
import { qk } from '@/lib/queryKeys';
import { useOrgScope } from './useOrgScope';

interface LocationUpdate {
  siteId: string;
  lat: number;
  lon: number;
}

export function useSiteLocationMutation() {
  const { orgId } = useOrgScope();
  const user = useUser();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ siteId, lat, lon }: LocationUpdate) => {
      if (!orgId || !user) throw new Error('Not authenticated');
      const { accessToken } = await user.getAuthJson();

      return sitesApi.updateSite(orgId, siteId, { lat, lon }, accessToken);
    },
    onSuccess: (_, { siteId }) => {
      // Invalidate site-specific queries
      queryClient.invalidateQueries({ queryKey: qk.site(siteId).details() });
      // Invalidate org sites list
      queryClient.invalidateQueries({ queryKey: qk.org(orgId).sites() });
    },
  });
}
```

This hook is fully migratable because the backend has site CRUD endpoints.
</action>
<verify>

1. Hook compiles without TypeScript errors
2. Uses sitesApi.updateSite
3. Stack Auth useUser for token
4. Query invalidation preserved
   </verify>
   <done>Site location mutation fully migrated to sitesApi</done>
   </task>

<task type="auto">
  <name>Task 2: Migrate useEscalationContacts to Stack Auth (hybrid)</name>
  <files>src/hooks/useEscalationContacts.ts</files>
  <action>
Migrate `useEscalationContacts.ts` to use Stack Auth for identity while keeping Supabase data calls temporarily:

**Why hybrid approach:**
Backend doesn't have escalation contacts endpoints yet (notification system is Phase 6+ work).

```typescript
/**
 * TODO: Full migration to new backend
 * - Create /api/orgs/:orgId/escalation-contacts endpoint
 * - Replace Supabase data calls with API calls
 * - Remove supabase import
 *
 * Current status: Stack Auth for identity, Supabase for data (Phase 5)
 */
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useUser } from '@stackframe/stack';
import { supabase } from '@/integrations/supabase/client'; // TEMPORARY
import { qk } from '@/lib/queryKeys';
import { useOrgScope } from './useOrgScope';

export function useEscalationContacts() {
  const { orgId, isReady } = useOrgScope();
  const user = useUser();

  return useQuery({
    queryKey: qk.org(orgId).escalationContacts(),
    queryFn: async () => {
      if (!orgId || !user) return [];

      // TODO Phase 6: Migrate to new API when backend endpoint available
      // Using Supabase directly for now (Stack Auth handles identity)
      const { data, error } = await supabase
        .from('escalation_contacts')
        .select('*')
        .eq('organization_id', orgId)
        .order('priority', { ascending: true });

      if (error) {
        console.error('[useEscalationContacts] Supabase error:', error);
        throw error;
      }

      return data || [];
    },
    enabled: isReady && !!user,
  });
}

// If there are mutations (create/update/delete), migrate them similarly:
export function useCreateEscalationContact() {
  const { orgId } = useOrgScope();
  const user = useUser();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (contact: Omit<EscalationContact, 'id' | 'organization_id'>) => {
      if (!orgId || !user) throw new Error('Not authenticated');

      // TODO Phase 6: Migrate to new API
      const { data, error } = await supabase
        .from('escalation_contacts')
        .insert({ ...contact, organization_id: orgId })
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: qk.org(orgId).escalationContacts() });
    },
  });
}
```

Preserve existing hook interface. Mark all Supabase data calls with TODO.
</action>
<verify>

1. Hook compiles without TypeScript errors
2. Stack Auth useUser imported
3. No supabase.auth calls remain
4. Supabase data calls have TODO comments
5. Query keys preserved
   </verify>
   <done>Escalation contacts hook uses Stack Auth, Supabase data calls marked for Phase 6</done>
   </task>

<task type="auto">
  <name>Task 3: Migrate useNotificationPolicies to Stack Auth (hybrid)</name>
  <files>src/hooks/useNotificationPolicies.ts</files>
  <action>
Migrate `useNotificationPolicies.ts` following same hybrid pattern:

```typescript
/**
 * TODO: Full migration to new backend
 * - Create /api/orgs/:orgId/notification-policies endpoint
 * - Replace Supabase data calls with API calls
 * - Remove supabase import
 *
 * Current status: Stack Auth for identity, Supabase for data (Phase 5)
 */
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useUser } from '@stackframe/stack';
import { supabase } from '@/integrations/supabase/client'; // TEMPORARY
import { qk } from '@/lib/queryKeys';
import { useOrgScope } from './useOrgScope';

export function useNotificationPolicies() {
  const { orgId, isReady } = useOrgScope();
  const user = useUser();

  return useQuery({
    queryKey: qk.org(orgId).notificationPolicies(),
    queryFn: async () => {
      if (!orgId || !user) return [];

      // TODO Phase 6: Migrate to new API when backend endpoint available
      const { data, error } = await supabase
        .from('notification_policies')
        .select('*')
        .eq('organization_id', orgId);

      if (error) {
        console.error('[useNotificationPolicies] Supabase error:', error);
        throw error;
      }

      return data || [];
    },
    enabled: isReady && !!user,
  });
}

// Mutations follow same pattern - use Stack Auth, mark Supabase calls with TODO
```

Same approach: Stack Auth for identity, Supabase for data with clear TODO markers.
</action>
<verify>

1. Hook compiles without TypeScript errors
2. Stack Auth useUser imported
3. No supabase.auth calls remain
4. Supabase data calls have TODO comments
5. Query keys preserved
   </verify>
   <done>Notification policies hook uses Stack Auth, Supabase data calls marked for Phase 6</done>
   </task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes
2. All hooks use Stack Auth for user identity
3. useSiteLocationMutation uses sitesApi (fully migrated)
4. Escalation/notification hooks have clear TODO markers
5. No supabase.auth calls in any migrated hook
6. Query keys preserved
</verification>

<success_criteria>

- Site location mutation fully migrated to sitesApi
- Escalation contacts uses Stack Auth, Supabase data clearly marked
- Notification policies uses Stack Auth, Supabase data clearly marked
- No Supabase auth calls remain
- Hooks still function correctly in hybrid mode
  </success_criteria>

<output>
After completion, create `.planning/phases/05-frontend-migration/05-07-SUMMARY.md`
</output>
