---
phase: 05-frontend-migration
plan: 06
type: execute
wave: 2
depends_on: ["05-01", "05-03"]
files_modified:
  - src/hooks/useAlertRules.ts
  - src/hooks/useAlertRulesHistory.ts
  - src/hooks/useUnitAlerts.ts
  - src/hooks/useUnitStatus.ts
autonomous: true

must_haves:
  truths:
    - "Alert rules hooks use Stack Auth and return DEFAULT_ALERT_RULES (rules CRUD is Phase 6+)"
    - "Unit alerts hook uses alertsApi for fetching alerts"
    - "Unit status hook derives status from nav tree query (no dedicated endpoint needed)"
  artifacts:
    - path: "src/hooks/useAlertRules.ts"
      provides: "Alert rules with default values (CRUD deferred to Phase 6)"
      exports: ["useUnitAlertRules", "useOrgAlertRules", "useSiteAlertRules", "DEFAULT_ALERT_RULES"]
    - path: "src/hooks/useUnitAlerts.ts"
      provides: "Unit alerts queries"
      exports: ["useUnitAlerts"]
    - path: "src/hooks/useUnitStatus.ts"
      provides: "Unit status derived from nav tree"
      exports: ["useUnitStatus"]
  key_links:
    - from: "src/hooks/useUnitAlerts.ts"
      to: "src/lib/api/alerts.ts"
      via: "import alertsApi"
      pattern: "alertsApi"
    - from: "src/hooks/useUnitStatus.ts"
      to: "src/hooks/useNavTree.ts"
      via: "derives status from nav tree units"
      pattern: "useNavTree|navTree\\.sites"
---

<objective>
Migrate alert and unit status hooks to new API.

Purpose: These hooks provide critical alert monitoring and unit status functionality. Alert rules CRUD endpoints don't exist in backend Phase 4 (which focused on alert evaluation), so rules hooks will return defaults for Phase 5. Rules configuration is admin-level functionality deferred to Phase 6+.

Output:
- useAlertRules hooks return DEFAULT_ALERT_RULES (evaluation uses server-side defaults)
- useUnitAlerts uses alertsApi for alert queries
- useUnitStatus derives status from nav tree data (no separate endpoint needed)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-frontend-migration/05-RESEARCH.md
@.planning/phases/05-frontend-migration/05-01-SUMMARY.md
@.planning/phases/05-frontend-migration/05-03-SUMMARY.md
@src/hooks/useAlertRules.ts
@src/hooks/useAlertRulesHistory.ts
@src/hooks/useUnitAlerts.ts
@src/hooks/useUnitStatus.ts
@src/hooks/useNavTree.ts
@src/lib/queryKeys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate useAlertRules to Stack Auth with default rules</name>
  <files>src/hooks/useAlertRules.ts</files>
  <action>
Migrate the alert rules hooks from Supabase to Stack Auth. Since backend Phase 4 built alert evaluation but NOT alert rules CRUD endpoints, these hooks will return defaults for Phase 5.

**Scope for Phase 5:**
- Alert EVALUATION happens server-side using DEFAULT_ALERT_RULES
- Alert rules CRUD (configuring custom thresholds) is Phase 6+ work
- Hooks should return defaults and be clearly documented

**Migration approach:**

1. Keep DEFAULT_ALERT_RULES constant unchanged - it defines the default thresholds
2. Keep pure JavaScript helper functions unchanged (computeMissedCheckins, computeOfflineSeverity, etc.)
3. Migrate query hooks to use Stack Auth but return defaults

```typescript
import { useQuery } from "@tanstack/react-query";
import { useUser } from "@stackframe/stack";
import { qk } from "@/lib/queryKeys";

/**
 * NOTE: Alert rules CRUD is Phase 6+ work.
 * For Phase 5, these hooks return DEFAULT_ALERT_RULES.
 * The backend alert evaluator uses these same defaults server-side.
 */

export const DEFAULT_ALERT_RULES: AlertRulesRow = {
  // ... existing defaults unchanged ...
};

export function useOrgAlertRules(orgId: string | null) {
  const user = useUser();

  return useQuery({
    queryKey: qk.org(orgId).alertRules(),  // SAME key for cache compatibility
    queryFn: async (): Promise<AlertRulesRow | null> => {
      if (!orgId || !user) return null;
      // Phase 5: Return defaults (rules CRUD endpoints don't exist yet)
      // TODO Phase 6: Call /api/orgs/:orgId/alert-rules when endpoint exists
      return DEFAULT_ALERT_RULES;
    },
    enabled: !!orgId && !!user,
    staleTime: Infinity, // Defaults never change
  });
}

export function useSiteAlertRules(siteId: string | null) {
  const user = useUser();

  return useQuery({
    queryKey: qk.site(siteId).alertRules(),
    queryFn: async (): Promise<AlertRulesRow | null> => {
      if (!siteId || !user) return null;
      // Phase 5: Return null (no site-level overrides, fall back to org/defaults)
      // TODO Phase 6: Call /api/orgs/:orgId/sites/:siteId/alert-rules
      return null;
    },
    enabled: !!siteId && !!user,
    staleTime: Infinity,
  });
}

export function useUnitAlertRules(unitId: string | null) {
  const user = useUser();

  return useQuery({
    queryKey: qk.unit(unitId).alertRules(),
    queryFn: async (): Promise<AlertRulesRow | null> => {
      if (!unitId || !user) return null;
      // Phase 5: Return null (no unit-level overrides)
      // TODO Phase 6: Call /api/orgs/:orgId/...units/:unitId/alert-rules
      return null;
    },
    enabled: !!unitId && !!user,
    staleTime: Infinity,
  });
}

// Keep mutation hooks but make them no-ops with clear documentation
export function useUpsertAlertRules() {
  // TODO Phase 6: Implement when backend endpoint exists
  // For now, return a mutation that throws with helpful message
  return useMutation({
    mutationFn: async () => {
      throw new Error('Alert rules configuration is not yet available. Using default rules.');
    },
  });
}
```

**Critical:** Keep the DEFAULT_ALERT_RULES constant and helper functions (computeMissedCheckins, etc.) unchanged. These are used for client-side display calculations.
  </action>
  <verify>
1. Hook compiles without TypeScript errors
2. useUser from Stack Auth is imported
3. DEFAULT_ALERT_RULES is exported and unchanged
4. Query keys preserved exactly
5. Helper functions (computeMissedCheckins, etc.) unchanged
  </verify>
  <done>Alert rules hooks return defaults with clear Phase 6 TODO markers</done>
</task>

<task type="auto">
  <name>Task 2: Migrate useUnitAlerts to alertsApi</name>
  <files>src/hooks/useUnitAlerts.ts</files>
  <action>
Migrate `useUnitAlerts.ts` to use alertsApi (backend has alerts endpoints from Phase 4):

```typescript
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { useUser } from "@stackframe/stack";
import { alertsApi } from "@/lib/api";
import { qk } from "@/lib/queryKeys";
import { useOrgScope } from "./useOrgScope";

export function useUnitAlerts(unitId: string | null) {
  const { orgId, isReady } = useOrgScope();
  const user = useUser();

  return useQuery({
    queryKey: qk.unit(unitId).alerts?.() ?? ['unit', unitId, 'alerts'],
    queryFn: async () => {
      if (!unitId || !orgId || !user) return [];
      const { accessToken } = await user.getAuthJson();

      const response = await alertsApi.listAlerts(orgId, {
        unitId,
        limit: 50,
      }, accessToken);

      return response.data;
    },
    enabled: isReady && !!unitId && !!user,
  });
}

export function useAcknowledgeAlert() {
  const { orgId } = useOrgScope();
  const user = useUser();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (alertId: string) => {
      if (!orgId || !user) throw new Error('Not authenticated');
      const { accessToken } = await user.getAuthJson();
      return alertsApi.acknowledgeAlert(orgId, alertId, accessToken);
    },
    onSuccess: () => {
      // Invalidate all alert queries for this org
      queryClient.invalidateQueries({ queryKey: qk.org(orgId).alerts() });
    },
  });
}

export function useResolveAlert() {
  const { orgId } = useOrgScope();
  const user = useUser();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ alertId, notes }: { alertId: string; notes?: string }) => {
      if (!orgId || !user) throw new Error('Not authenticated');
      const { accessToken } = await user.getAuthJson();
      return alertsApi.resolveAlert(orgId, alertId, notes, accessToken);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: qk.org(orgId).alerts() });
    },
  });
}
```

Preserve the hook's return interface for consuming components. Check existing hook signature and match it.
  </action>
  <verify>
1. Hook compiles without TypeScript errors
2. Uses alertsApi from lib/api
3. Stack Auth useUser is used for token
4. Query keys preserved
  </verify>
  <done>useUnitAlerts fetches alerts via alertsApi with proper filtering</done>
</task>

<task type="auto">
  <name>Task 3: Migrate useUnitStatus to derive from nav tree</name>
  <files>src/hooks/useUnitStatus.ts</files>
  <action>
Migrate `useUnitStatus.ts` to derive unit status from the nav tree query (which already loads all units with status).

**Why this approach:**
- The nav tree already fetches all units with their status field
- No dedicated /api/orgs/:orgId/units/:unitId endpoint exists (units are hierarchical)
- Creating a unit-by-id endpoint just for status is unnecessary overhead

**Implementation:**

```typescript
import { useMemo } from "react";
import { useUser } from "@stackframe/stack";
import { useNavTree } from "./useNavTree";
import { useOrgScope } from "./useOrgScope";

interface UnitStatusData {
  unitId: string;
  status: string;
  unitName: string;
  unitType: string;
  // Add other fields if the existing hook returns them
}

/**
 * Get unit status by deriving from the nav tree query.
 *
 * The nav tree already loads all units with status, so we reuse that data
 * rather than making a separate API call. This avoids needing a dedicated
 * unit-by-id endpoint.
 */
export function useUnitStatus(unitId: string | null) {
  const { orgId, isReady } = useOrgScope();
  const user = useUser();
  const { sites, isLoading, error } = useNavTree(orgId);

  // Find the unit in the nav tree
  const unitStatus = useMemo((): UnitStatusData | null => {
    if (!unitId || !sites.length) return null;

    for (const site of sites) {
      for (const unit of site.units) {
        if (unit.unitId === unitId) {
          return {
            unitId: unit.unitId,
            status: unit.status,
            unitName: unit.unitName,
            unitType: unit.unitType,
          };
        }
      }
    }
    return null;
  }, [unitId, sites]);

  return {
    data: unitStatus,
    isLoading: isLoading || !isReady,
    error,
    // Provide same interface as previous hook if it had isFetching, etc.
  };
}
```

**Alternative if hook needs more data:**
If the existing useUnitStatus returns more than what's in nav tree (like lastTemperature, lastReadingAt), check if those fields exist in the nav tree unit data. If not, we can:
1. Add those fields to the nav tree query (if they're in the units table)
2. Or create a separate query that joins with latest reading

Check the existing hook interface and match it.
  </action>
  <verify>
1. Hook compiles without TypeScript errors
2. useNavTree is imported and used
3. Stack Auth useUser is imported
4. No separate API call for unit-by-id
5. Returns status data derived from nav tree
  </verify>
  <done>useUnitStatus derives status from nav tree data without dedicated endpoint</done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes
2. No Supabase imports in migrated hooks
3. Query keys preserved exactly
4. Helper functions (computeMissedCheckins, etc.) unchanged
5. Alert list loads for units via alertsApi
6. Unit status displays correctly from nav tree data
</verification>

<success_criteria>
- Alert rules hooks compile and use Stack Auth
- Alert rules return DEFAULT_ALERT_RULES with clear Phase 6 TODO
- useUnitAlerts fetches from alertsApi
- useUnitStatus derives from nav tree (no separate endpoint)
- All query keys preserved for cache continuity
- Pure helper functions unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/05-frontend-migration/05-06-SUMMARY.md`
</output>
