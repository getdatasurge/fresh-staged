---
phase: 05-frontend-migration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/api/readings.ts
  - src/lib/api/alerts.ts
  - src/lib/api/index.ts
autonomous: true

must_haves:
  truths:
    - "API functions exist for readings queries"
    - "API functions exist for alerts queries and mutations"
    - "Alert acknowledge and resolve operations available"
  artifacts:
    - path: "src/lib/api/readings.ts"
      provides: "Readings API functions"
      exports: ["listReadings", "getLatestReading"]
    - path: "src/lib/api/alerts.ts"
      provides: "Alerts API functions"
      exports: ["listAlerts", "getAlert", "acknowledgeAlert", "resolveAlert"]
  key_links:
    - from: "src/lib/api/readings.ts"
      to: "src/lib/api-client.ts"
      via: "import createAuthenticatedClient"
      pattern: "createAuthenticatedClient"
---

<objective>
Create typed API functions for readings and alerts.

Purpose: Provide type-safe functions for sensor data queries and alert management operations.

Output:
- readingsApi module for querying temperature readings
- alertsApi module for alert queries and lifecycle operations (acknowledge, resolve)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-frontend-migration/05-RESEARCH.md
@backend/src/routes/readings.ts
@backend/src/routes/alerts.ts
@backend/src/schemas/readings.ts
@backend/src/schemas/alerts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create readings API module</name>
  <files>src/lib/api/readings.ts</files>
  <action>
Create `src/lib/api/readings.ts` with typed API functions for sensor readings:

```typescript
import { createAuthenticatedClient } from '../api-client';
import type { ReadingResponse, ReadingsListResponse, PaginationParams } from '../api-types';

export const readingsApi = {
  /**
   * List readings for a unit with pagination
   * GET /api/orgs/:orgId/units/:unitId/readings
   */
  listReadings: async (
    orgId: string,
    unitId: string,
    params: PaginationParams & { startDate?: string; endDate?: string },
    accessToken: string
  ): Promise<ReadingsListResponse> => {
    const client = createAuthenticatedClient(accessToken);
    const searchParams = new URLSearchParams();
    if (params.page) searchParams.set('page', String(params.page));
    if (params.limit) searchParams.set('limit', String(params.limit));
    if (params.startDate) searchParams.set('startDate', params.startDate);
    if (params.endDate) searchParams.set('endDate', params.endDate);

    const url = `api/orgs/${orgId}/units/${unitId}/readings${searchParams.toString() ? '?' + searchParams.toString() : ''}`;
    return client.get(url).json<ReadingsListResponse>();
  },

  /**
   * Get latest reading for a unit
   * GET /api/orgs/:orgId/units/:unitId/readings/latest
   */
  getLatestReading: async (
    orgId: string,
    unitId: string,
    accessToken: string
  ): Promise<ReadingResponse | null> => {
    const client = createAuthenticatedClient(accessToken);
    // Use list with limit=1 sorted by most recent, or a dedicated endpoint if available
    const response = await client.get(`api/orgs/${orgId}/units/${unitId}/readings?limit=1`).json<ReadingsListResponse>();
    return response.data[0] || null;
  },
};
```

NOTE: The backend readings route is at `/api/orgs/:orgId/units/:unitId/readings` based on Phase 4 implementation. Verify exact route structure and adjust if needed.
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>readingsApi exports listReadings, getLatestReading functions</done>
</task>

<task type="auto">
  <name>Task 2: Create alerts API module</name>
  <files>src/lib/api/alerts.ts</files>
  <action>
Create `src/lib/api/alerts.ts` with typed API functions for alerts:

```typescript
import { createAuthenticatedClient } from '../api-client';
import type {
  AlertResponse,
  AlertsListResponse,
  PaginationParams,
  AlertStatus
} from '../api-types';

export const alertsApi = {
  /**
   * List alerts for organization with optional filters
   * GET /api/orgs/:orgId/alerts
   */
  listAlerts: async (
    orgId: string,
    params: PaginationParams & {
      status?: AlertStatus | AlertStatus[];
      unitId?: string;
      siteId?: string;
    },
    accessToken: string
  ): Promise<AlertsListResponse> => {
    const client = createAuthenticatedClient(accessToken);
    const searchParams = new URLSearchParams();
    if (params.page) searchParams.set('page', String(params.page));
    if (params.limit) searchParams.set('limit', String(params.limit));
    if (params.status) {
      const statuses = Array.isArray(params.status) ? params.status : [params.status];
      statuses.forEach(s => searchParams.append('status', s));
    }
    if (params.unitId) searchParams.set('unitId', params.unitId);
    if (params.siteId) searchParams.set('siteId', params.siteId);

    const url = `api/orgs/${orgId}/alerts${searchParams.toString() ? '?' + searchParams.toString() : ''}`;
    return client.get(url).json<AlertsListResponse>();
  },

  /**
   * Get single alert by ID
   * GET /api/orgs/:orgId/alerts/:alertId
   */
  getAlert: async (
    orgId: string,
    alertId: string,
    accessToken: string
  ): Promise<AlertResponse> => {
    const client = createAuthenticatedClient(accessToken);
    return client.get(`api/orgs/${orgId}/alerts/${alertId}`).json<AlertResponse>();
  },

  /**
   * Acknowledge an alert
   * POST /api/orgs/:orgId/alerts/:alertId/acknowledge
   * Requires staff+ role
   */
  acknowledgeAlert: async (
    orgId: string,
    alertId: string,
    accessToken: string
  ): Promise<AlertResponse> => {
    const client = createAuthenticatedClient(accessToken);
    return client.post(`api/orgs/${orgId}/alerts/${alertId}/acknowledge`).json<AlertResponse>();
  },

  /**
   * Resolve an alert with corrective action
   * POST /api/orgs/:orgId/alerts/:alertId/resolve
   * Requires staff+ role
   */
  resolveAlert: async (
    orgId: string,
    alertId: string,
    resolution: { correctiveAction: string },
    accessToken: string
  ): Promise<AlertResponse> => {
    const client = createAuthenticatedClient(accessToken);
    return client.post(`api/orgs/${orgId}/alerts/${alertId}/resolve`, {
      json: resolution
    }).json<AlertResponse>();
  },

  /**
   * List alerts for a specific unit
   * Convenience method using listAlerts with unitId filter
   */
  listUnitAlerts: async (
    orgId: string,
    unitId: string,
    params: PaginationParams & { status?: AlertStatus | AlertStatus[] },
    accessToken: string
  ): Promise<AlertsListResponse> => {
    return alertsApi.listAlerts(orgId, { ...params, unitId }, accessToken);
  },
};
```

Include all alert lifecycle operations from Phase 4 backend (acknowledge, resolve).
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>alertsApi exports listAlerts, getAlert, acknowledgeAlert, resolveAlert functions</done>
</task>

<task type="auto">
  <name>Task 3: Update API barrel export</name>
  <files>src/lib/api/index.ts</files>
  <action>
Update `src/lib/api/index.ts` to include readings and alerts:

```typescript
// API modules barrel export
export { organizationsApi } from './organizations';
export { sitesApi } from './sites';
export { areasApi } from './areas';
export { unitsApi } from './units';
export { readingsApi } from './readings';
export { alertsApi } from './alerts';

// Re-export types for convenience
export type * from '../api-types';
```
  </action>
  <verify>All exports resolve correctly</verify>
  <done>Barrel export includes readingsApi and alertsApi</done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes with no type errors
2. readingsApi exports listReadings, getLatestReading
3. alertsApi exports listAlerts, getAlert, acknowledgeAlert, resolveAlert
4. Barrel export includes both new modules
</verification>

<success_criteria>
- readingsApi can query readings with pagination and date filters
- alertsApi can list, get, acknowledge, and resolve alerts
- All functions accept accessToken for authentication
- Types match backend response schemas
</success_criteria>

<output>
After completion, create `.planning/phases/05-frontend-migration/05-03-SUMMARY.md`
</output>
