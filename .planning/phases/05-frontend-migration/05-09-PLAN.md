---
phase: 05-frontend-migration
plan: 09
type: execute
wave: 3
depends_on: ['05-04']
files_modified:
  - src/hooks/useAccountDeletion.ts
  - src/hooks/useAuditedWrite.ts
  - src/hooks/useBatteryForecast.ts
  - src/hooks/useOfflineSync.ts
  - src/hooks/useQuickCreateEntityLayout.ts
autonomous: true

must_haves:
  truths:
    - 'Remaining Supabase hooks use Stack Auth for authentication'
    - 'Core functionality preserved'
    - 'Supabase data calls marked for migration'
  artifacts:
    - path: 'src/hooks/useAccountDeletion.ts'
      provides: 'Account deletion functionality'
      exports: ['useAccountDeletion']
    - path: 'src/hooks/useAuditedWrite.ts'
      provides: 'Audited database writes'
      exports: ['useAuditedWrite']
  key_links:
    - from: 'src/hooks/useAccountDeletion.ts'
      to: '@stackframe/stack'
      via: 'import useUser'
      pattern: 'useUser'
---

<objective>
Migrate remaining utility and feature hooks from Supabase to Stack Auth.

Purpose: Complete the hook migration by updating remaining hooks that use Supabase.

Output:

- All remaining hooks use Stack Auth for authentication
- Supabase auth completely removed from hooks
- Data calls marked for future migration where needed
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-frontend-migration/05-RESEARCH.md
@.planning/phases/05-frontend-migration/05-04-SUMMARY.md
@src/hooks/useAccountDeletion.ts
@src/hooks/useAuditedWrite.ts
@src/hooks/useBatteryForecast.ts
@src/hooks/useOfflineSync.ts
@src/hooks/useQuickCreateEntityLayout.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate useAccountDeletion and useAuditedWrite</name>
  <files>src/hooks/useAccountDeletion.ts, src/hooks/useAuditedWrite.ts</files>
  <action>
Migrate account and audit hooks:

**useAccountDeletion:**

- Handles user account deletion requests
- May call edge function or RPC for secure deletion

```typescript
import { useMutation } from '@tanstack/react-query';
import { useUser } from '@stackframe/stack';
import { supabase } from '@/integrations/supabase/client'; // TEMPORARY

export function useAccountDeletion() {
  const user = useUser();

  return useMutation({
    mutationFn: async () => {
      if (!user) throw new Error('Not authenticated');
      const { accessToken } = await user.getAuthJson();

      // TODO: Migrate to new backend endpoint
      // Account deletion needs secure backend handling
      // Current: Likely calls Supabase RPC or edge function
      console.warn('[useAccountDeletion] TODO: migrate to new backend');

      // For Stack Auth, account deletion should go through Stack Auth API
      // The backend then cleans up local data

      // Keep existing logic temporarily...
      const { error } = await supabase.rpc('delete_user_account');
      if (error) throw error;
    },
  });
}
```

**useAuditedWrite:**

- Wraps database writes with audit logging
- Creates audit trail entries

```typescript
import { useCallback } from 'react';
import { useUser } from '@stackframe/stack';
import { supabase } from '@/integrations/supabase/client'; // TEMPORARY

export function useAuditedWrite() {
  const user = useUser();

  const auditedWrite = useCallback(
    async (
      table: string,
      operation: 'INSERT' | 'UPDATE' | 'DELETE',
      data: any,
      entityId?: string,
    ) => {
      if (!user) throw new Error('Not authenticated');
      const { accessToken } = await user.getAuthJson();

      // TODO: Migrate to new backend API
      // Backend should handle audit logging automatically
      // For now, keep Supabase calls with Stack Auth user context
      console.warn('[useAuditedWrite] TODO: migrate to new backend');

      // Existing Supabase logic...
    },
    [user],
  );

  return { auditedWrite };
}
```

  </action>
  <verify>Hooks compile with Stack Auth imports</verify>
  <done>Account deletion and audited write hooks use Stack Auth</done>
</task>

<task type="auto">
  <name>Task 2: Migrate useBatteryForecast and useOfflineSync</name>
  <files>src/hooks/useBatteryForecast.ts, src/hooks/useOfflineSync.ts</files>
  <action>
Migrate sensor and offline hooks:

**useBatteryForecast:**

- Calculates battery life forecasts for sensors
- Likely reads sensor/reading data

```typescript
import { useQuery } from '@tanstack/react-query';
import { useUser } from '@stackframe/stack';
import { supabase } from '@/integrations/supabase/client'; // TEMPORARY
import { useOrgScope } from './useOrgScope';

export function useBatteryForecast(sensorId: string | null) {
  const { orgId, isReady } = useOrgScope();
  const user = useUser();

  return useQuery({
    queryKey: ['sensor', sensorId, 'battery-forecast'],
    queryFn: async () => {
      if (!sensorId || !orgId || !user) return null;

      // TODO: Migrate to new backend API
      // Battery forecast needs sensor data and reading history
      const { data, error } = await supabase
        .from('lora_sensors')
        .select('*, readings:sensor_readings(battery_level, recorded_at)')
        .eq('id', sensorId)
        .single();

      if (error) throw error;

      // Calculate forecast from data...
      return calculateBatteryForecast(data);
    },
    enabled: isReady && !!sensorId && !!user,
  });
}
```

**useOfflineSync:**

- Handles offline data synchronization
- Queues mutations when offline, syncs when online
- This is infrastructure - may not need Supabase auth at all

Review useOfflineSync:

- If it only uses navigator.onLine and localStorage, no changes needed
- If it calls Supabase auth, replace with Stack Auth
- Keep queue/sync logic unchanged
  </action>
  <verify>Hooks compile, Stack Auth used where needed</verify>
  <done>Battery forecast uses Stack Auth, offline sync reviewed and updated if needed</done>
  </task>

<task type="auto">
  <name>Task 3: Migrate useQuickCreateEntityLayout</name>
  <files>src/hooks/useQuickCreateEntityLayout.ts</files>
  <action>
Migrate quick create hook:

**useQuickCreateEntityLayout:**

- Creates entities (sites, areas, units) with default layouts
- May use multiple Supabase operations

```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useUser } from '@stackframe/stack';
import { sitesApi, areasApi, unitsApi } from '@/lib/api';
import { qk } from '@/lib/queryKeys';
import { useOrgScope } from './useOrgScope';

export function useQuickCreateEntityLayout() {
  const { orgId } = useOrgScope();
  const user = useUser();
  const queryClient = useQueryClient();

  const createSiteWithLayout = useMutation({
    mutationFn: async (siteData: CreateSiteRequest) => {
      if (!orgId || !user) throw new Error('Not authenticated');
      const { accessToken } = await user.getAuthJson();

      // Create site via new API
      const site = await sitesApi.createSite(orgId, siteData, accessToken);

      // TODO: Create default layout via new API or keep Supabase temporarily
      // Layout creation may need backend endpoint

      return site;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: qk.org(orgId).sites() });
      queryClient.invalidateQueries({ queryKey: qk.org(orgId).navTree() });
    },
  });

  const createAreaWithLayout = useMutation({
    mutationFn: async ({ siteId, areaData }: { siteId: string; areaData: CreateAreaRequest }) => {
      if (!orgId || !user) throw new Error('Not authenticated');
      const { accessToken } = await user.getAuthJson();

      const area = await areasApi.createArea(orgId, siteId, areaData, accessToken);
      // TODO: Layout creation

      return area;
    },
    onSuccess: (_, { siteId }) => {
      queryClient.invalidateQueries({ queryKey: qk.site(siteId).areas() });
      queryClient.invalidateQueries({ queryKey: qk.org(orgId).navTree() });
    },
  });

  const createUnitWithLayout = useMutation({
    mutationFn: async ({
      siteId,
      areaId,
      unitData,
    }: {
      siteId: string;
      areaId: string;
      unitData: CreateUnitRequest;
    }) => {
      if (!orgId || !user) throw new Error('Not authenticated');
      const { accessToken } = await user.getAuthJson();

      const unit = await unitsApi.createUnit(orgId, siteId, areaId, unitData, accessToken);
      // TODO: Layout creation

      return unit;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: qk.org(orgId).navTree() });
    },
  });

  return {
    createSiteWithLayout,
    createAreaWithLayout,
    createUnitWithLayout,
  };
}
```

Entity creation uses new API. Layout creation marked with TODO if backend endpoint not available.
</action>
<verify>Hook compiles, entity creation uses new API</verify>
<done>Quick create uses new API for entities, layout creation marked for migration</done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes
2. All hooks import useUser from @stackframe/stack
3. No supabase.auth calls remain in any hook
4. Entity CRUD operations use new API where possible
5. TODO comments mark remaining Supabase data calls
</verification>

<success_criteria>

- All 5 hooks use Stack Auth for authentication
- Entity creation operations use new API (sites, areas, units)
- Supabase auth completely removed from hooks
- Non-migrated operations clearly marked with TODO
  </success_criteria>

<output>
After completion, create `.planning/phases/05-frontend-migration/05-09-SUMMARY.md`
</output>
