---
phase: 05-frontend-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/api-client.ts
  - src/lib/api-types.ts
  - src/lib/api/index.ts
autonomous: true

must_haves:
  truths:
    - "API client can make authenticated requests to backend"
    - "TypeScript types match backend Zod schemas"
    - "Errors are logged to console AND thrown for component handling"
  artifacts:
    - path: "src/lib/api-client.ts"
      provides: "Ky HTTP client with auth interceptor and error handling"
      exports: ["apiClient", "createAuthenticatedClient"]
    - path: "src/lib/api-types.ts"
      provides: "TypeScript types derived from backend Zod schemas"
      contains: "OrganizationResponse"
    - path: "src/lib/api/index.ts"
      provides: "API module barrel export"
      exports: ["api"]
  key_links:
    - from: "src/lib/api-client.ts"
      to: "backend Zod schemas"
      via: "shared types in api-types.ts"
      pattern: "import.*from.*api-types"
---

<objective>
Create the API client infrastructure for frontend-to-backend communication.

Purpose: Establish the foundation for all frontend hooks to communicate with the new self-hosted backend API instead of Supabase.

Output:
- Ky HTTP client with auth interceptor
- TypeScript types matching backend Zod schemas
- Error handling that logs to console AND surfaces in DOM
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-frontend-migration/05-CONTEXT.md
@.planning/phases/05-frontend-migration/05-RESEARCH.md
@backend/src/schemas/index.ts
@backend/src/schemas/organizations.ts
@backend/src/schemas/sites.ts
@backend/src/schemas/areas.ts
@backend/src/schemas/units.ts
@backend/src/schemas/readings.ts
@backend/src/schemas/alerts.ts
@src/lib/queryKeys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Ky HTTP client</name>
  <files>package.json</files>
  <action>
Install Ky as HTTP client for the frontend:

```bash
pnpm add ky
```

Verify installation by checking package.json includes ky dependency.

NOTE: Do not install zod-to-ts - we will manually define types based on backend schemas for simplicity and to avoid build tooling complexity. The backend Zod schemas export TypeScript types directly via `z.infer`.
  </action>
  <verify>Run `pnpm ls ky` to confirm installation</verify>
  <done>Ky is listed in dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create API types from backend schemas</name>
  <files>src/lib/api-types.ts</files>
  <action>
Create TypeScript types that mirror the backend Zod schema types. Since the backend already exports TypeScript types via `z.infer`, we can reference those patterns.

Create `src/lib/api-types.ts` with types for:

1. **Organization types:**
   - `OrganizationResponse` - matches backend OrganizationSchema
   - `UpdateOrganizationRequest` - matches backend UpdateOrganizationSchema
   - `MemberResponse` - matches backend MemberSchema

2. **Site types:**
   - `SiteResponse` - id, name, organizationId, address, city, state, zipCode, lat, lon, timezone, isActive, createdAt, updatedAt
   - `CreateSiteRequest` - name, address?, city?, state?, zipCode?, lat?, lon?, timezone?
   - `UpdateSiteRequest` - all CreateSite fields optional

3. **Area types:**
   - `AreaResponse` - id, name, siteId, description, isActive, createdAt, updatedAt
   - `CreateAreaRequest` - name, description?
   - `UpdateAreaRequest` - name?, description?

4. **Unit types:**
   - `UnitResponse` - id, name, areaId, unitType, tempMin, tempMax, tempUnit, status, lastReadingAt, lastTemperature, isActive, createdAt, updatedAt
   - `CreateUnitRequest` - name, unitType, tempMin, tempMax, tempUnit?
   - `UpdateUnitRequest` - all optional

5. **Reading types:**
   - `ReadingResponse` - id, unitId, temperature, humidity, recordedAt, receivedAt
   - `BulkReadingsRequest` - array of {deviceId, temperature, humidity?, recordedAt}
   - `ReadingsListResponse` - { data: ReadingResponse[], pagination: {...} }

6. **Alert types:**
   - `AlertResponse` - id, unitId, type, severity, status, triggeredAt, acknowledgedAt, resolvedAt, acknowledgedBy, resolvedBy
   - `AlertsListResponse` - { data: AlertResponse[], pagination: {...} }

7. **Common types:**
   - `PaginationParams` - { page?: number, limit?: number }
   - `PaginationMeta` - { page: number, limit: number, total: number, totalPages: number }
   - `ApiError` - discriminated union: network | validation | auth | server

Add header comment: `// API types matching backend Zod schemas - keep in sync with backend/src/schemas/`

Use strict TypeScript with proper enums for unitType, unitStatus, alertType, alertSeverity, alertStatus.
  </action>
  <verify>Run `pnpm tsc --noEmit src/lib/api-types.ts` (or full type check) to confirm no type errors</verify>
  <done>All API types defined with proper TypeScript types matching backend schema structure</done>
</task>

<task type="auto">
  <name>Task 3: Create Ky API client with auth interceptor</name>
  <files>src/lib/api-client.ts</files>
  <action>
Create the core API client with Ky that handles:

1. **Base configuration:**
   - Base URL from `import.meta.env.VITE_API_URL` with fallback to `http://localhost:3000`
   - 30 second timeout
   - JSON content type default

2. **Retry configuration:**
   - 3 retries for transient errors
   - Retry on: 408, 413, 429, 500, 502, 503, 504
   - Retry methods: GET, POST, PUT, PATCH, DELETE
   - Exponential backoff with max 30 second delay

3. **Error handling in afterResponse hook:**
   - Log ALL errors to console with format: `[API Error] {url} {status} {error body}`
   - Parse error response JSON if possible
   - Throw Error with message from response or status code
   - For 401: throw specific auth error
   - For 403: throw specific forbidden error
   - For 4xx: throw validation error with details
   - For 5xx: throw server error

4. **Factory function for authenticated client:**
   ```typescript
   export function createAuthenticatedClient(accessToken: string) {
     return apiClient.extend({
       headers: {
         'x-stack-access-token': accessToken
       }
     });
   }
   ```

5. **Export base client for unauthenticated requests:**
   ```typescript
   export const apiClient = ky.create({...});
   ```

IMPORTANT: The API client itself does NOT use React hooks. Token injection happens at the hook level using `createAuthenticatedClient()` with the token from Stack Auth's `useUser().getAuthJson()`.
  </action>
  <verify>Import the module and verify TypeScript compiles without errors</verify>
  <done>API client exports apiClient and createAuthenticatedClient, handles retries, logs errors to console</done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes with no type errors
2. `api-client.ts` exports apiClient and createAuthenticatedClient
3. `api-types.ts` exports all required types for orgs, sites, areas, units, readings, alerts
4. Error handling logs to console (visible in browser dev tools)
</verification>

<success_criteria>
- Ky installed as dependency
- API client configured with retry logic and error handling
- All TypeScript types defined matching backend schemas
- No type errors in new files
</success_criteria>

<output>
After completion, create `.planning/phases/05-frontend-migration/05-01-SUMMARY.md`
</output>
