---
phase: 42-admin-debug-components
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/unit/UnitSettingsSection.tsx
  - src/components/billing/InvoiceHistory.tsx
  - src/components/errors/MigrationErrorBoundary.tsx
  - src/components/errors/MigrationErrorFallback.tsx
  - src/lib/errorHandler.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "UnitSettingsSection saves settings via tRPC mutation"
    - "InvoiceHistory fetches invoices via tRPC"
    - "Error handling files no longer import from supabase-placeholder"
  artifacts:
    - path: "src/components/unit/UnitSettingsSection.tsx"
      provides: "Unit settings CRUD with tRPC"
    - path: "src/components/billing/InvoiceHistory.tsx"
      provides: "Invoice history with tRPC"
    - path: "src/components/errors/MigrationErrorBoundary.tsx"
      provides: "Error boundary without supabase import"
    - path: "src/components/errors/MigrationErrorFallback.tsx"
      provides: "Error fallback without supabase import"
    - path: "src/lib/errorHandler.ts"
      provides: "Error handler without supabase import"
  key_links:
    - from: "src/components/unit/UnitSettingsSection.tsx"
      to: "trpc.units.update"
      via: "useMutation"
      pattern: "trpc\\.units\\.update"
    - from: "src/components/billing/InvoiceHistory.tsx"
      to: "trpc.payments"
      via: "useQuery"
      pattern: "trpc\\.payments"
---

<objective>
Migrate remaining components and cleanup error handling utilities

Purpose: Complete COMP-04 requirements and remove all remaining supabase-placeholder imports
Output: UnitSettingsSection and InvoiceHistory use tRPC, error utilities cleaned up
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-pages-migration/41-01-SUMMARY.md
@backend/src/routers/units.router.ts
@backend/src/routers/payments.router.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate UnitSettingsSection to tRPC</name>
  <files>src/components/unit/UnitSettingsSection.tsx</files>
  <action>
**UnitSettingsSection.tsx:**
- Remove import of `supabase` from `@/lib/supabase-placeholder`
- Add: `import { useTRPC } from '@/lib/trpc'`
- Add: `import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'`

**Replace validateAndSave unit update (lines 154-253):**
- The units.router.ts has an `update` procedure that accepts unit updates
- Create mutation:
  ```typescript
  const trpc = useTRPC()
  const queryClient = useQueryClient()
  const updateUnitMutation = useMutation(
    trpc.units.update.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: ['units'] })
        toast({ title: "Unit settings updated" })
        setShowEditModal(false)
        onSettingsUpdated()
      },
      onError: (error) => {
        toast({
          title: "Failed to save settings",
          description: error.message,
          variant: "destructive"
        })
      }
    })
  )
  ```

**Updated validateAndSave:**
```typescript
const validateAndSave = async () => {
  // ... validation logic stays the same (lines 131-149) ...

  setIsSaving(true)
  setValidationError(null)

  if (!user) {
    toast({ title: "Not authenticated", variant: "destructive" })
    setIsSaving(false)
    return
  }

  // Check for changes
  const hasChanges = editUnitType !== unitType ||
    lowVal !== tempLimitLow ||
    highVal !== tempLimitHigh ||
    editDoorSensorEnabled !== doorSensorEnabled ||
    graceVal !== doorOpenGraceMinutes ||
    editNotes !== (notes || "")

  if (!hasChanges) {
    toast({ title: "No changes to save" })
    setShowEditModal(false)
    setIsSaving(false)
    return
  }

  try {
    await updateUnitMutation.mutateAsync({
      id: unitId,
      unitType: editUnitType as any,
      tempLimitLow: lowVal,
      tempLimitHigh: highVal,
      notes: editNotes || null,
      doorSensorEnabled: editDoorSensorEnabled,
      doorOpenGraceMinutes: graceVal
    })
  } catch (error) {
    // Error handled by mutation onError
  }

  setIsSaving(false)
}
```

**Replace loadHistory (lines 256-301):**
- Check if units.router has a settings history procedure
- If not, we need to add one OR simplify to remove history feature
- For now, add a simple procedure to fetch unit_settings_history

**Option A: Add procedure to units.router.ts:**
```typescript
getSettingsHistory: protectedProcedure
  .input(z.object({ unitId: z.string().uuid() }))
  .query(async ({ input }) => {
    const history = await db.select(...)
      .from(unitSettingsHistory)
      .where(eq(unitSettingsHistory.unitId, input.unitId))
      .orderBy(desc(unitSettingsHistory.changedAt))
      .limit(20)
    // Join with profiles for user info
    return history
  })
```

**Option B: Use useQuery for history:**
```typescript
const { data: historyData, isLoading: isLoadingHistory, refetch: loadHistory } = useQuery(
  trpc.units.getSettingsHistory.queryOptions(
    { unitId },
    { enabled: showHistoryModal }
  )
)

const history = useMemo(() => {
  if (!historyData) return []
  return historyData.map(h => ({
    id: h.id,
    changed_by: h.changedBy,
    changed_at: h.changedAt,
    changes: h.changes,
    note: h.note,
    profile: h.profile
  }))
}, [historyData])
```

**Remove:**
- The loadHistory useCallback that uses supabase
- Direct supabase queries for unit_settings_history and profiles
  </action>
  <verify>
    grep "supabase-placeholder" src/components/unit/UnitSettingsSection.tsx
    # Should return nothing
    npx tsc --noEmit
  </verify>
  <done>UnitSettingsSection uses tRPC for unit updates and settings history</done>
</task>

<task type="auto">
  <name>Task 2: Migrate InvoiceHistory to tRPC</name>
  <files>src/components/billing/InvoiceHistory.tsx</files>
  <action>
**InvoiceHistory.tsx:**
- Remove import of `supabase` from `@/lib/supabase-placeholder`
- Add: `import { useTRPC } from '@/lib/trpc'`
- Add: `import { useQuery } from '@tanstack/react-query'`

**Check payments.router.ts for invoice procedures:**
- The payments router has getSubscription, createCheckoutSession, createPortalSession
- Need to add a listInvoices procedure

**Add to payments.router.ts:**
```typescript
listInvoices: protectedProcedure
  .input(z.object({
    subscriptionId: z.string().uuid(),
    limit: z.number().int().min(1).max(50).optional()
  }))
  .output(z.array(z.object({
    id: z.string(),
    stripeInvoiceId: z.string().nullable(),
    amountDue: z.number(),
    amountPaid: z.number(),
    currency: z.string(),
    status: z.string(),
    paidAt: z.string().nullable(),
    periodStart: z.string(),
    periodEnd: z.string(),
    invoicePdfUrl: z.string().nullable()
  })))
  .query(async ({ input }) => {
    const { subscriptionId, limit = 10 } = input
    const invoices = await db.select()
      .from(invoicesTable)
      .where(eq(invoicesTable.subscriptionId, subscriptionId))
      .orderBy(desc(invoicesTable.createdAt))
      .limit(limit)
    return invoices.map(inv => ({
      id: inv.id,
      stripeInvoiceId: inv.stripeInvoiceId,
      amountDue: inv.amountDue,
      amountPaid: inv.amountPaid,
      currency: inv.currency,
      status: inv.status,
      paidAt: inv.paidAt?.toISOString() || null,
      periodStart: inv.periodStart.toISOString(),
      periodEnd: inv.periodEnd.toISOString(),
      invoicePdfUrl: inv.invoicePdfUrl
    }))
  })
```

**Replace loadInvoices in component:**
```typescript
const trpc = useTRPC()
const { data: invoicesData, isLoading } = useQuery(
  trpc.payments.listInvoices.queryOptions(
    { subscriptionId, limit: 10 },
    { enabled: !!subscriptionId }
  )
)

const invoices = useMemo(() => {
  if (!invoicesData) return []
  return invoicesData.map(inv => ({
    id: inv.id,
    stripe_invoice_id: inv.stripeInvoiceId,
    amount_due: inv.amountDue,
    amount_paid: inv.amountPaid,
    currency: inv.currency,
    status: inv.status,
    paid_at: inv.paidAt,
    period_start: inv.periodStart,
    period_end: inv.periodEnd,
    invoice_pdf_url: inv.invoicePdfUrl
  }))
}, [invoicesData])
```

**Remove:**
- The useState for invoices and isLoading (use query state)
- The loadInvoices useCallback
- The useEffect that calls loadInvoices
  </action>
  <verify>
    grep "supabase-placeholder" src/components/billing/InvoiceHistory.tsx
    # Should return nothing
    npx tsc --noEmit
  </verify>
  <done>InvoiceHistory uses tRPC payments.listInvoices for invoice data</done>
</task>

<task type="auto">
  <name>Task 3: Clean up error handling utilities</name>
  <files>
    src/components/errors/MigrationErrorBoundary.tsx
    src/components/errors/MigrationErrorFallback.tsx
    src/lib/errorHandler.ts
  </files>
  <action>
**These files import from supabase-placeholder for the `isSupabaseMigrationError` helper and `SupabaseMigrationError` type.**

Since we're removing supabase-placeholder entirely in phase 43, we have two options:
1. Remove these migration-specific error handling components (they won't be needed)
2. Keep them but remove the supabase imports (make them generic error handlers)

**Recommended: Simplify to generic error handling**

**MigrationErrorBoundary.tsx:**
- Remove import of `isSupabaseMigrationError` from `@/lib/supabase-placeholder`
- The boundary catches errors and shows fallback - make it a generic error boundary
- Remove the `isMigrationError` check - treat all errors the same way:
```typescript
// Remove the migration-specific logic
static getDerivedStateFromError(error: Error): MigrationErrorBoundaryState {
  return {
    hasError: true,
    error,
    isMigrationError: false // No longer checking for migration errors
  }
}

render() {
  if (this.state.hasError) {
    return (
      this.props.fallback || (
        <MigrationErrorFallback
          error={this.state.error}
          onRetry={this.handleRetry}
        />
      )
    )
  }
  return this.props.children
}
```

**MigrationErrorFallback.tsx:**
- Remove import of `SupabaseMigrationError` from `@/lib/supabase-placeholder`
- Simplify to show generic "Feature Temporarily Unavailable" message:
```typescript
interface MigrationErrorFallbackProps {
  error: Error | null
  onRetry?: () => void
}

export function MigrationErrorFallback({ error, onRetry }: MigrationErrorFallbackProps) {
  return (
    <Card className="border-warning/50 bg-warning/5">
      <CardHeader className="pb-3">
        <div className="flex items-center gap-2">
          <AlertTriangle className="h-5 w-5 text-warning" />
          <CardTitle className="text-lg">Something Went Wrong</CardTitle>
        </div>
        <CardDescription>
          {error?.message || "An unexpected error occurred. Please try again."}
        </CardDescription>
      </CardHeader>
      {onRetry && (
        <CardContent>
          <Button variant="outline" size="sm" onClick={onRetry}>
            <RefreshCw className="h-4 w-4 mr-2" />
            Try Again
          </Button>
        </CardContent>
      )}
    </Card>
  )
}
```

**errorHandler.ts:**
- Remove all imports from `@/lib/supabase-placeholder`
- Remove `isMigrationError` function (or make it always return false)
- Remove `getMigrationErrorMessage` function (or return generic message)
- Remove the migration error check in `handleError` function
- Keep the permission error handling logic (RLS error codes) as it may still be useful

```typescript
// Remove these imports:
// import { isSupabaseMigrationError, SupabaseMigrationError } from '@/lib/supabase-placeholder'

// Simplify isMigrationError to always return false (can be removed later)
export function isMigrationError(_error: unknown): boolean {
  return false // Migration complete
}

// Simplify getMigrationErrorMessage
export function getMigrationErrorMessage(_error: unknown): string {
  return 'An unexpected error occurred.'
}

// Update handleError to remove migration check:
export function handleError(
  error: unknown,
  action?: string,
  fallbackMessage?: string
): void {
  console.error('Operation failed:', error)

  // Permission error handling stays
  if (isPermissionError(error)) {
    toast.error(getPermissionErrorMessage(error, action))
    return
  }

  // Generic fallback
  const message = fallbackMessage || getPermissionErrorMessage(error, action)
  toast.error(message)
}
```
  </action>
  <verify>
    grep "supabase-placeholder" \
      src/components/errors/MigrationErrorBoundary.tsx \
      src/components/errors/MigrationErrorFallback.tsx \
      src/lib/errorHandler.ts
    # Should return nothing
    npx tsc --noEmit
  </verify>
  <done>Error handling utilities have no supabase imports, simplified to generic error handling</done>
</task>

</tasks>

<verification>
```bash
# Verify no supabase imports in migrated files
grep -l "supabase-placeholder" \
  src/components/unit/UnitSettingsSection.tsx \
  src/components/billing/InvoiceHistory.tsx \
  src/components/errors/MigrationErrorBoundary.tsx \
  src/components/errors/MigrationErrorFallback.tsx \
  src/lib/errorHandler.ts

# Should return nothing (empty output)

# Count remaining supabase-placeholder imports (should be minimal after this plan)
grep -r "supabase-placeholder" src/ --include="*.tsx" --include="*.ts" -l | wc -l

# TypeScript compilation
npx tsc --noEmit
```
</verification>

<success_criteria>
- All 5 files have zero imports from supabase-placeholder
- TypeScript compiles without errors
- UnitSettingsSection can save unit settings via tRPC
- InvoiceHistory displays invoices from tRPC
- Error handling works for generic errors (migration-specific handling removed)
</success_criteria>

<output>
After completion, create `.planning/phases/42-admin-debug-components/42-03-SUMMARY.md`
</output>
