---
phase: 22-foundation-pre-flight
plan: 03
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - scripts/lib/preflight-lib.sh
autonomous: true

must_haves:
  truths:
    - "Script can resume from failure point without re-running successful steps"
    - "Script automatically rolls back on critical failures"
    - "Script prompts user for recovery on recoverable failures"
    - "Checkpoint files track deployment progress"
  artifacts:
    - path: "scripts/lib/preflight-lib.sh"
      provides: "Checkpoint-based resume and rollback system"
      exports: ["checkpoint_done", "checkpoint_set", "checkpoint_clear", "run_step", "save_error_state", "handle_recovery"]
      contains: ["/var/lib/freshtrack-deploy", ".checkpoint-"]
  key_links:
    - from: "scripts/lib/preflight-lib.sh"
      to: "checkpoint files"
      via: "STATE_DIR variable"
      pattern: "STATE_DIR.*freshtrack-deploy"
---

<objective>
Add checkpoint-based resume and rollback capabilities to preflight-lib.sh.

Purpose: Enable deployment scripts to track progress, skip completed steps on resume, and handle failures appropriately based on error category.

Output: Checkpoint functions added to `scripts/lib/preflight-lib.sh` that support idempotent resume.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-foundation-pre-flight/22-RESEARCH.md
@.planning/phases/22-foundation-pre-flight/22-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add checkpoint functions for state tracking</name>
  <files>scripts/lib/preflight-lib.sh</files>
  <action>
Add checkpoint functions to `scripts/lib/preflight-lib.sh` AFTER the color helpers and BEFORE the validation functions:

**1. State directory configuration:**
```bash
# ===========================================
# Checkpoint State Management
# ===========================================
# STATE_DIR can be overridden for testing
STATE_DIR="${STATE_DIR:-/var/lib/freshtrack-deploy}"

# Ensure state directory exists (called during checkpoint operations)
ensure_state_dir() {
    if [[ ! -d "$STATE_DIR" ]]; then
        mkdir -p "$STATE_DIR" 2>/dev/null || {
            # If can't create in /var/lib, fall back to local directory
            STATE_DIR="${SCRIPT_DIR:-.}/.deploy-state"
            mkdir -p "$STATE_DIR"
        }
    fi
}
```

**2. Checkpoint query functions:**
```bash
# Check if a checkpoint has been completed
# Args: $1 = checkpoint name
# Returns: 0 if done, 1 if not done
checkpoint_done() {
    local checkpoint="$1"
    [[ -f "${STATE_DIR}/.checkpoint-${checkpoint}" ]]
}

# Get timestamp of when checkpoint was completed
# Args: $1 = checkpoint name
# Returns: timestamp or empty string
checkpoint_time() {
    local checkpoint="$1"
    local file="${STATE_DIR}/.checkpoint-${checkpoint}"
    if [[ -f "$file" ]]; then
        cat "$file"
    fi
}
```

**3. Checkpoint mutation functions:**
```bash
# Mark a checkpoint as complete
# Args: $1 = checkpoint name
checkpoint_set() {
    local checkpoint="$1"
    ensure_state_dir
    date -Iseconds > "${STATE_DIR}/.checkpoint-${checkpoint}"
}

# Clear a checkpoint (mark as incomplete)
# Args: $1 = checkpoint name
checkpoint_clear() {
    local checkpoint="$1"
    rm -f "${STATE_DIR}/.checkpoint-${checkpoint}"
}

# Clear all checkpoints (full reset)
checkpoint_clear_all() {
    ensure_state_dir
    rm -f "${STATE_DIR}"/.checkpoint-*
    rm -f "${STATE_DIR}"/.last-error-*
    success "All checkpoints cleared"
}
```

**4. Step runner with checkpoint support:**
```bash
# Run a deployment step with checkpoint tracking
# Args: $1 = step name (used as checkpoint)
#       $2 = function to run
#       $3+ = arguments to function
# Returns: 0 on success (including skip), function's exit code on failure
run_step() {
    local step_name="$1"
    local step_func="$2"
    shift 2

    if checkpoint_done "$step_name"; then
        local completed_at
        completed_at=$(checkpoint_time "$step_name")
        echo "[SKIP] $step_name (completed at: $completed_at)"
        return 0
    fi

    step "[RUN] $step_name"

    # Run the function
    if "$step_func" "$@"; then
        checkpoint_set "$step_name"
        success "$step_name completed"
        return 0
    else
        local exit_code=$?
        error "$step_name failed (exit code: $exit_code)"
        return $exit_code
    fi
}
```
  </action>
  <verify>
Test checkpoint functions:
```bash
source scripts/lib/preflight-lib.sh

# Test with temp state dir
export STATE_DIR=$(mktemp -d)

# Should not be done
if checkpoint_done "test-step"; then echo "FAIL"; exit 1; fi

# Set checkpoint
checkpoint_set "test-step"

# Should be done now
if ! checkpoint_done "test-step"; then echo "FAIL"; exit 1; fi

# Clear checkpoint
checkpoint_clear "test-step"

# Should not be done again
if checkpoint_done "test-step"; then echo "FAIL"; exit 1; fi

# Cleanup
rm -rf "$STATE_DIR"

echo "Checkpoint tests passed"
```
  </verify>
  <done>
- STATE_DIR defaults to /var/lib/freshtrack-deploy
- ensure_state_dir falls back to local dir if no write permission
- checkpoint_done checks file existence
- checkpoint_set writes timestamp
- checkpoint_clear removes checkpoint file
- checkpoint_clear_all removes all checkpoints
- run_step skips completed steps and sets checkpoint on success
  </done>
</task>

<task type="auto">
  <name>Task 2: Add error state persistence and recovery handling</name>
  <files>scripts/lib/preflight-lib.sh</files>
  <action>
Add error state and recovery functions to `scripts/lib/preflight-lib.sh`:

**1. Error state persistence:**
```bash
# Save error state for diagnostic purposes
# Args: $1 = script name
#       $2 = line number
#       $3 = exit code
save_error_state() {
    local script="$1"
    local line="$2"
    local exit_code="$3"

    ensure_state_dir

    {
        echo "timestamp=$(date -Iseconds)"
        echo "script=$script"
        echo "line=$line"
        echo "exit_code=$exit_code"
        echo "category=$(categorize_error "$exit_code")"
    } > "${STATE_DIR}/.last-error"
}

# Load last error state
# Returns: 0 if error state exists, 1 if not
load_error_state() {
    local file="${STATE_DIR}/.last-error"
    if [[ -f "$file" ]]; then
        # shellcheck source=/dev/null
        source "$file"
        return 0
    fi
    return 1
}
```

**2. Recovery handler based on error category:**
```bash
# Handle recovery based on error category
# Called by error_handler after displaying diagnostics
# Args: $1 = error category
# Returns: 0 if user chooses to retry, 1 to abort
handle_recovery() {
    local category="$1"

    case "$category" in
        transient:*)
            echo ""
            echo "This appears to be a temporary issue."
            echo "You can safely re-run the script to resume from the last checkpoint."
            echo ""
            read -rp "Retry now? [Y/n]: " retry
            if [[ "${retry,,}" != "n" ]]; then
                return 0  # Retry
            fi
            return 1  # Abort
            ;;

        recoverable:permission)
            echo ""
            echo "Permission issue detected."
            echo ""
            echo "Suggestions:"
            echo "  1. Ensure you're running with sudo: sudo ./deploy.sh"
            echo "  2. Check file ownership: ls -la /opt/freshtrack-pro/"
            echo "  3. Verify docker group membership: groups \$USER"
            echo ""
            read -rp "Fix the issue and retry? [Y/n]: " retry
            if [[ "${retry,,}" != "n" ]]; then
                return 0  # Retry
            fi
            return 1  # Abort
            ;;

        recoverable:resource)
            echo ""
            echo "Resource exhaustion detected (memory or disk)."
            echo ""
            echo "Quick fixes:"
            echo "  1. Free Docker resources: docker system prune -af"
            echo "  2. Check memory: free -h"
            echo "  3. Check disk: df -h"
            echo ""
            read -rp "Fix the issue and retry? [Y/n]: " retry
            if [[ "${retry,,}" != "n" ]]; then
                return 0  # Retry
            fi
            return 1  # Abort
            ;;

        critical:*)
            echo ""
            warning "CRITICAL FAILURE - Automatic rollback may be needed"
            echo ""
            echo "The deployment encountered a critical error."
            echo "Data has been preserved, but services may be in an inconsistent state."
            echo ""
            echo "Options:"
            echo "  1. Review logs: docker compose logs"
            echo "  2. Check system: journalctl -xe"
            echo "  3. Rollback: ./scripts/rollback.sh"
            echo ""
            return 1  # Always abort on critical
            ;;

        fatal:*)
            echo ""
            error "FATAL ERROR - Manual intervention required"
            echo ""
            echo "The deployment was interrupted by a signal."
            echo "This usually means:"
            echo "  - Process was killed (OOM, admin, etc.)"
            echo "  - User pressed Ctrl+C"
            echo ""
            echo "Check system status before retrying."
            return 1  # Always abort on fatal
            ;;

        *)
            echo ""
            warning "Unknown error category: $category"
            echo ""
            echo "Review the error above and determine if it's safe to retry."
            read -rp "Retry? [y/N]: " retry
            if [[ "${retry,,}" == "y" ]]; then
                return 0  # Retry only if explicit yes
            fi
            return 1  # Default to abort
            ;;
    esac
}
```

**3. Update error_handler to use save_error_state:**

Find the existing error_handler function and add this line after the diagnostics output, before the exit:
```bash
    # Save error state for resume
    save_error_state "${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}" "$line_number" "$exit_code"
```
  </action>
  <verify>
Test error state functions:
```bash
source scripts/lib/preflight-lib.sh

# Test with temp state dir
export STATE_DIR=$(mktemp -d)

# Save error state
save_error_state "test.sh" "42" "127"

# Load error state
if load_error_state; then
    echo "Script: $script"
    echo "Line: $line"
    echo "Exit code: $exit_code"
    echo "Category: $category"
else
    echo "FAIL: Could not load error state"
    exit 1
fi

# Verify values
if [[ "$script" != "test.sh" ]]; then echo "FAIL: script mismatch"; exit 1; fi
if [[ "$line" != "42" ]]; then echo "FAIL: line mismatch"; exit 1; fi
if [[ "$exit_code" != "127" ]]; then echo "FAIL: exit_code mismatch"; exit 1; fi

# Cleanup
rm -rf "$STATE_DIR"

echo "Error state tests passed"
```
  </verify>
  <done>
- save_error_state writes error details to STATE_DIR/.last-error
- load_error_state sources the error file
- handle_recovery prompts user based on error category
- Transient errors offer automatic retry
- Recoverable errors show specific fix suggestions
- Critical errors abort and suggest rollback
- Fatal errors abort and suggest system check
- error_handler calls save_error_state before exit
  </done>
</task>

<task type="auto">
  <name>Task 3: Update self-tests to cover checkpoint functions</name>
  <files>scripts/lib/preflight-lib.sh</files>
  <action>
Add checkpoint function tests to the self-test block:

After the validation function tests, add:
```bash
    # Test checkpoint functions
    echo "4. Testing checkpoint functions..."

    # Use temp state dir for tests
    local original_state_dir="$STATE_DIR"
    export STATE_DIR=$(mktemp -d)

    # Test checkpoint_done (should be false initially)
    if checkpoint_done "test-checkpoint"; then
        echo "FAIL: checkpoint_done should return false for non-existent checkpoint"
        rm -rf "$STATE_DIR"
        exit 1
    fi

    # Test checkpoint_set
    checkpoint_set "test-checkpoint"

    # Test checkpoint_done (should be true after set)
    if ! checkpoint_done "test-checkpoint"; then
        echo "FAIL: checkpoint_done should return true after checkpoint_set"
        rm -rf "$STATE_DIR"
        exit 1
    fi

    # Test checkpoint_time
    local ts
    ts=$(checkpoint_time "test-checkpoint")
    if [[ -z "$ts" ]]; then
        echo "FAIL: checkpoint_time should return timestamp"
        rm -rf "$STATE_DIR"
        exit 1
    fi

    # Test checkpoint_clear
    checkpoint_clear "test-checkpoint"
    if checkpoint_done "test-checkpoint"; then
        echo "FAIL: checkpoint_done should return false after checkpoint_clear"
        rm -rf "$STATE_DIR"
        exit 1
    fi

    echo "PASS: Checkpoint functions working"
    echo ""

    # Test error state functions
    echo "5. Testing error state functions..."

    save_error_state "test-script.sh" "99" "42"

    if ! load_error_state; then
        echo "FAIL: load_error_state should succeed after save_error_state"
        rm -rf "$STATE_DIR"
        exit 1
    fi

    if [[ "$script" != "test-script.sh" ]]; then
        echo "FAIL: script should be 'test-script.sh', got '$script'"
        rm -rf "$STATE_DIR"
        exit 1
    fi

    if [[ "$line" != "99" ]]; then
        echo "FAIL: line should be '99', got '$line'"
        rm -rf "$STATE_DIR"
        exit 1
    fi

    echo "PASS: Error state functions working"
    echo ""

    # Cleanup
    rm -rf "$STATE_DIR"
    export STATE_DIR="$original_state_dir"
```

Make sure the final "All tests passed!" message comes after all tests.
  </action>
  <verify>
Run self-tests:
```bash
bash scripts/lib/preflight-lib.sh
```

Should show:
- PASS: Credential sanitization working
- PASS: Error categorization working
- PASS: validate_* functions working
- PASS: Checkpoint functions working
- PASS: Error state functions working
- All tests passed!
  </verify>
  <done>
- Self-test block includes checkpoint tests
- Uses temp directory for isolation
- Tests checkpoint_done, checkpoint_set, checkpoint_clear, checkpoint_time
- Tests save_error_state and load_error_state
- Cleans up temp directory after tests
- All tests pass
  </done>
</task>

</tasks>

<verification>
1. Functions exist: `source scripts/lib/preflight-lib.sh && type checkpoint_done checkpoint_set checkpoint_clear run_step save_error_state handle_recovery`
2. Shellcheck passes: `shellcheck scripts/lib/preflight-lib.sh`
3. Self-tests pass: `bash scripts/lib/preflight-lib.sh`
4. Run_step skips completed: Test by setting checkpoint then running run_step
5. Error state persists: Check that .last-error file contains correct values
</verification>

<success_criteria>
- ERROR-04: Critical failures trigger rollback guidance (via handle_recovery)
- ERROR-05: Recoverable failures prompt user with fix suggestions
- Checkpoint files created in STATE_DIR with timestamps
- run_step skips already-completed steps on re-run
- save_error_state captures line, script, exit code, category
</success_criteria>

<output>
After completion, create `.planning/phases/22-foundation-pre-flight/22-03-SUMMARY.md`
</output>
