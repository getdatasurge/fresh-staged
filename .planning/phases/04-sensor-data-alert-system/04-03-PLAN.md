---
phase: 04-sensor-data-alert-system
plan: 03
type: execute
wave: 2
depends_on: ['04-01', '04-02']
files_modified:
  - backend/src/routes/readings.ts
  - backend/src/services/readings.service.ts
  - backend/src/app.ts
autonomous: true

must_haves:
  truths:
    - 'POST /api/ingest/readings accepts bulk readings with API key auth'
    - 'GET /api/orgs/:orgId/.../readings returns paginated readings'
    - 'Readings ingestion triggers alert evaluation'
    - 'Invalid units in payload return 403'
  artifacts:
    - path: 'backend/src/routes/readings.ts'
      provides: 'Readings REST endpoints'
      exports: ['default']
    - path: 'backend/src/app.ts'
      provides: 'App with readings routes registered'
      contains: 'readingsRoutes'
  key_links:
    - from: 'backend/src/routes/readings.ts'
      to: 'backend/src/services/readings.service.ts'
      via: 'service function calls'
      pattern: "readingsService\\."
    - from: 'backend/src/routes/readings.ts'
      to: 'backend/src/services/alert-evaluator.service.ts'
      via: 'alert evaluation after insert'
      pattern: "alertEvaluator\\."
---

<objective>
Create readings REST endpoints for bulk sensor data ingestion and reading queries, integrating the alert evaluator for real-time threshold monitoring.

Purpose: Enable TTN webhooks and external systems to push sensor data, and provide querying capabilities for the frontend dashboard.

Output:

- POST /api/ingest/readings (bulk ingestion with API key auth)
- GET /api/orgs/:orgId/sites/:siteId/areas/:areaId/units/:unitId/readings (query)
- Alert evaluation integrated into ingestion flow
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-sensor-data-alert-system/04-RESEARCH.md

# From 04-01 (will exist after execution)

@backend/src/middleware/api-key-auth.ts
@backend/src/schemas/readings.ts
@backend/src/services/readings.service.ts

# From 04-02 (will exist after execution)

@backend/src/services/alert-evaluator.service.ts

# Existing patterns

@backend/src/routes/units.ts
@backend/src/app.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create readings routes</name>
  <files>backend/src/routes/readings.ts</files>
  <action>
Create `readings.ts` route handler with two endpoints:

**1. POST /api/ingest/readings (bulk ingestion)**

```typescript
app.post(
  '/ingest/readings',
  {
    preHandler: [requireApiKey],
    schema: {
      body: BulkReadingsSchema,
      response: {
        200: BulkIngestResponseSchema,
        401: ErrorResponseSchema,
        403: ErrorResponseSchema,
      },
    },
  },
  async (request, reply) => {
    const { readings } = request.body;
    const orgId = request.orgContext!.organizationId;

    // 1. Validate all units belong to this organization
    const unitIds = [...new Set(readings.map((r) => r.unitId))];
    const validUnits = await readingsService.validateUnitsInOrg(unitIds, orgId);

    if (validUnits.length !== unitIds.length) {
      return reply.code(403).send({
        error: { code: 'FORBIDDEN', message: 'One or more units not accessible' },
      });
    }

    // 2. Insert readings
    const result = await readingsService.ingestBulkReadings(readings, orgId);

    // 3. Evaluate alerts for each unique unit
    let alertsTriggered = 0;
    for (const unitId of unitIds) {
      const unitReadings = readings.filter((r) => r.unitId === unitId);
      const latestReading = unitReadings[unitReadings.length - 1];
      const evalResult = await alertEvaluator.evaluateUnitAfterReading(
        unitId,
        latestReading.temperature,
        new Date(latestReading.recordedAt),
      );
      if (evalResult.alertCreated) alertsTriggered++;
    }

    return {
      success: true,
      insertedCount: result.insertedCount,
      readingIds: result.readingIds,
      alertsTriggered,
    };
  },
);
```

**2. GET /api/orgs/:orgId/sites/:siteId/areas/:areaId/units/:unitId/readings (query)**

```typescript
app.get(
  '/',
  {
    preHandler: [requireAuth, requireOrgContext],
    schema: {
      params: UnitParamsSchema,
      querystring: ReadingQuerySchema,
      response: {
        200: z.array(ReadingResponseSchema),
        404: ErrorResponseSchema,
      },
    },
  },
  async (request, reply) => {
    // Verify unit hierarchy access first
    const unit = await unitService.getUnit(
      request.params.unitId,
      request.params.areaId,
      request.params.siteId,
      request.user!.organizationId!,
    );

    if (!unit) {
      return notFound(reply, 'Unit not found');
    }

    // Query readings with pagination
    const readings = await readingsService.queryReadings({
      unitId: request.params.unitId,
      start: request.query.start,
      end: request.query.end,
      limit: request.query.limit,
      offset: request.query.offset,
    });

    return readings;
  },
);
```

Export default async function that registers both route prefixes.
</action>
<verify>
TypeScript compiles: `cd backend && pnpm tsc --noEmit`
</verify>
<done>

- POST /ingest/readings accepts bulk payload with API key auth
- GET readings endpoint under unit hierarchy with pagination
- Alert evaluation runs after successful ingestion
- Proper error responses for auth and validation failures
  </done>
  </task>

<task type="auto">
  <name>Task 2: Wire alert evaluation into readings service</name>
  <files>backend/src/services/readings.service.ts</files>
  <action>
Update `readings.service.ts` to integrate with alert evaluator:

1. Modify `ingestBulkReadings` to accept an optional callback or return data needed for evaluation:
   - Return unitId -> latestReading mapping for alert evaluation
   - Or accept evaluator function as parameter

2. Add helper function `getLatestReadingPerUnit(readings)`:

   ```typescript
   function getLatestReadingPerUnit(readings: SingleReading[]): Map<string, SingleReading> {
     const result = new Map<string, SingleReading>();
     for (const reading of readings) {
       const existing = result.get(reading.unitId);
       if (!existing || new Date(reading.recordedAt) > new Date(existing.recordedAt)) {
         result.set(reading.unitId, reading);
       }
     }
     return result;
   }
   ```

3. Export helper for route to use in alert evaluation loop.

Note: Keep alert evaluation in route handler (not service) for better separation - services shouldn't depend on each other cyclically.
</action>
<verify>
TypeScript compiles: `cd backend && pnpm tsc --noEmit`
</verify>
<done>

- readings service returns data needed for alert evaluation
- Helper function identifies latest reading per unit
- No cyclic dependencies between services
  </done>
  </task>

<task type="auto">
  <name>Task 3: Register readings routes in app.ts</name>
  <files>backend/src/app.ts</files>
  <action>
Update `app.ts` to register readings routes:

1. Import readings routes:

   ```typescript
   import readingsRoutes from './routes/readings.js';
   ```

2. Register with appropriate prefixes:

   ```typescript
   // Ingestion endpoint (API key auth, no org context in path)
   app.register(readingsRoutes, { prefix: '/api' });

   // Unit-scoped readings query (under existing unit hierarchy)
   // Already handled within readingsRoutes with separate route registration
   ```

3. The readings routes file should export a function that registers:
   - POST `/ingest/readings` at `/api/ingest/readings`
   - GET at `/api/orgs/:organizationId/sites/:siteId/areas/:areaId/units/:unitId/readings`

**Note:** You may need to structure the routes file to handle both prefixes, or create two separate route files. Choose the cleaner approach - likely a single file with two route groups registered separately in app.ts.
</action>
<verify>

1. TypeScript compiles: `cd backend && pnpm tsc --noEmit`
2. Route registration visible in app.ts
   </verify>
   <done>

- Readings routes imported in app.ts
- POST /api/ingest/readings registered with API key auth
- GET /api/orgs/.../units/:unitId/readings registered with JWT auth
- App compiles and routes are accessible
  </done>
  </task>

</tasks>

<verification>
1. TypeScript compilation: `cd backend && pnpm tsc --noEmit`
2. Route paths match expected patterns
3. Alert evaluation integrated into ingestion flow
</verification>

<success_criteria>

- POST /api/ingest/readings accepts bulk readings with X-API-Key header
- Invalid API key returns 401
- Units not in org return 403
- GET readings endpoint supports pagination and time range
- Alert evaluator called after each successful ingestion
- All routes registered in app.ts
  </success_criteria>

<output>
After completion, create `.planning/phases/04-sensor-data-alert-system/04-03-SUMMARY.md`
</output>
