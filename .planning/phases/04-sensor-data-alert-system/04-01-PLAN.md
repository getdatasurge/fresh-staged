---
phase: 04-sensor-data-alert-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/middleware/api-key-auth.ts
  - backend/src/middleware/index.ts
  - backend/src/schemas/readings.ts
  - backend/src/services/readings.service.ts
  - backend/src/services/index.ts
autonomous: true

must_haves:
  truths:
    - 'API key header validates against stored org key'
    - 'Invalid API key returns 401'
    - 'Bulk readings can be inserted atomically'
    - 'Readings query returns paginated results'
  artifacts:
    - path: 'backend/src/middleware/api-key-auth.ts'
      provides: 'API key validation middleware'
      exports: ['requireApiKey']
    - path: 'backend/src/schemas/readings.ts'
      provides: 'Zod validation schemas for readings'
      exports: ['BulkReadingsSchema', 'ReadingQuerySchema', 'ReadingSchema']
    - path: 'backend/src/services/readings.service.ts'
      provides: 'Readings CRUD and bulk operations'
      exports: ['ingestBulkReadings', 'queryReadings', 'validateUnitsInOrg']
  key_links:
    - from: 'backend/src/middleware/api-key-auth.ts'
      to: 'backend/src/db/schema/tenancy.ts'
      via: 'ttnConnections table lookup'
      pattern: 'ttnConnections'
    - from: 'backend/src/services/readings.service.ts'
      to: 'backend/src/db/schema/telemetry.ts'
      via: 'sensorReadings insert'
      pattern: 'sensorReadings'
---

<objective>
Create API key authentication middleware and readings service foundation for sensor data ingestion.

Purpose: Enable external systems (TTN, sensors) to push readings securely using per-org API keys, and provide the core service layer for reading storage and retrieval.

Output:

- API key auth middleware using ttnConnections table
- Readings Zod schemas for validation
- Readings service with bulk insert and query operations
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-sensor-data-alert-system/04-RESEARCH.md

# Existing patterns to follow

@backend/src/middleware/index.ts
@backend/src/services/site.service.ts
@backend/src/schemas/common.ts
@backend/src/db/schema/telemetry.ts
@backend/src/db/schema/tenancy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API key authentication middleware</name>
  <files>backend/src/middleware/api-key-auth.ts, backend/src/middleware/index.ts</files>
  <action>
Create `api-key-auth.ts` middleware that:

1. Extracts API key from `X-API-Key` or `X-Webhook-Secret` header
2. Queries `ttnConnections` table to find matching org by webhook_secret (use constant-time comparison via `crypto.timingSafeEqual`)
3. On match: attaches `request.orgContext = { organizationId, connectionId }` to request
4. On no match: returns 401 with `{ error: { code: 'UNAUTHORIZED', message: 'Invalid API key' } }`

Implementation notes:

- Use `crypto.timingSafeEqual` from `node:crypto` for secure comparison
- The ttnConnections table stores `webhookSecret` column - query by this
- Create a type augmentation for FastifyRequest to include `orgContext`
- Export as `requireApiKey` preHandler

Update `middleware/index.ts` to export `requireApiKey`.

Reference existing ttn-webhook pattern from research doc:

```typescript
import { timingSafeEqual } from 'node:crypto';

function secureCompare(a: string, b: string): boolean {
  if (a.length !== b.length) return false;
  const bufA = Buffer.from(a);
  const bufB = Buffer.from(b);
  return timingSafeEqual(bufA, bufB);
}
```

  </action>
  <verify>
TypeScript compiles without errors: `cd backend && pnpm tsc --noEmit`
  </verify>
  <done>
- api-key-auth.ts exports requireApiKey middleware
- Middleware looks up ttnConnections by webhookSecret
- Uses timingSafeEqual for secure comparison
- Returns 401 for invalid/missing keys
- Attaches orgContext on success
  </done>
</task>

<task type="auto">
  <name>Task 2: Create readings Zod schemas</name>
  <files>backend/src/schemas/readings.ts</files>
  <action>
Create `readings.ts` Zod schemas following existing patterns:

1. `ReadingSourceSchema` - enum: ['ttn', 'manual', 'api', 'import']

2. `SingleReadingSchema` - single reading in bulk payload:
   - unitId: UuidSchema (required)
   - deviceId: UuidSchema (optional)
   - temperature: z.number() - NOT integer, numeric in DB
   - humidity: z.number().optional()
   - battery: z.number().int().min(0).max(100).optional()
   - signalStrength: z.number().int().optional()
   - recordedAt: z.string().datetime() - ISO 8601 string
   - source: ReadingSourceSchema.default('api')
   - rawPayload: z.string().optional()

3. `BulkReadingsSchema` - request body for bulk ingestion:
   - readings: z.array(SingleReadingSchema).min(1).max(1000)

4. `ReadingQuerySchema` - query params for reading retrieval:
   - unitId: UuidSchema.optional()
   - start: z.string().datetime().optional()
   - end: z.string().datetime().optional()
   - limit: z.coerce.number().int().min(1).max(1000).default(100)
   - offset: z.coerce.number().int().min(0).default(0)

5. `ReadingResponseSchema` - full reading response (matches DB schema):
   - id, unitId, deviceId, temperature, humidity, battery, signalStrength
   - rawPayload, recordedAt, receivedAt, source, createdAt

6. `BulkIngestResponseSchema`:
   - success: z.boolean()
   - insertedCount: z.number().int()
   - readingIds: z.array(UuidSchema)
   - alertsTriggered: z.number().int()

Export all schemas and inferred types.
</action>
<verify>
TypeScript compiles: `cd backend && pnpm tsc --noEmit`
</verify>
<done>

- All Zod schemas defined with proper validation
- Temperature is numeric (not integer) to match DB precision
- Query schema supports pagination (limit, offset) and time range (start, end)
- Types exported for service layer use
  </done>
  </task>

<task type="auto">
  <name>Task 3: Create readings service</name>
  <files>backend/src/services/readings.service.ts, backend/src/services/index.ts</files>
  <action>
Create `readings.service.ts` with these functions:

1. `validateUnitsInOrg(unitIds: string[], organizationId: string): Promise<string[]>`
   - Verifies units exist and belong to organization via hierarchy (unit -> area -> site -> org)
   - Returns array of valid unitIds (silent filtering for invalid ones)
   - Use innerJoin pattern from unit.service.ts verifyAreaAccess

2. `ingestBulkReadings(readings: SingleReading[], organizationId: string): Promise<BulkIngestResult>`
   - Insert readings in batches of 500 (PostgreSQL parameter limit safety)
   - Use Drizzle transaction for atomicity
   - Update unit.lastReadingAt and unit.lastTemperature for each affected unit
   - Return { insertedCount, readingIds, alertsTriggered: 0 } (alert triggering added in 04-02)

3. `queryReadings(params: ReadingQuery): Promise<ReadingResponse[]>`
   - Query sensorReadings with optional filters: unitId, start/end time range
   - Apply limit/offset pagination
   - Order by recordedAt descending (newest first)
   - Validate unit hierarchy access (must verify org ownership)

Implementation notes:

- Temperature stored as numeric(7,2) in DB - pass through as number
- recordedAt comes as ISO string, convert to Date for insert
- receivedAt defaults to NOW() in DB, don't set it
- Batch size constant: `const BATCH_SIZE = 500;`

Update `services/index.ts` to export readings service.
</action>
<verify>
TypeScript compiles: `cd backend && pnpm tsc --noEmit`
</verify>
<done>

- validateUnitsInOrg verifies hierarchy with joins
- ingestBulkReadings handles batching and unit updates
- queryReadings supports pagination and time range filtering
- Service exported from index.ts
  </done>
  </task>

</tasks>

<verification>
1. TypeScript compilation: `cd backend && pnpm tsc --noEmit`
2. All exports accessible: Check index.ts barrel exports
3. Schema validation: Manually verify Zod schemas parse expected inputs
</verification>

<success_criteria>

- API key middleware authenticates against ttnConnections table
- Readings schemas validate bulk payloads with 1-1000 readings
- Readings service can insert bulk readings with batching
- Unit hierarchy validation prevents cross-org data insertion
- All code compiles without TypeScript errors
  </success_criteria>

<output>
After completion, create `.planning/phases/04-sensor-data-alert-system/04-01-SUMMARY.md`
</output>
