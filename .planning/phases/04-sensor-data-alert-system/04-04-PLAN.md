---
phase: 04-sensor-data-alert-system
plan: 04
type: execute
wave: 2
depends_on: ['04-02']
files_modified:
  - backend/src/schemas/alerts.ts
  - backend/src/services/alert.service.ts
  - backend/src/services/index.ts
  - backend/src/routes/alerts.ts
  - backend/src/app.ts
autonomous: true

must_haves:
  truths:
    - 'GET alerts returns paginated list filtered by status'
    - 'POST acknowledge changes alert status to acknowledged'
    - 'POST resolve changes alert status to resolved'
    - 'Staff role required for acknowledge and resolve'
    - 'Alert hierarchy validation prevents cross-org access'
  artifacts:
    - path: 'backend/src/schemas/alerts.ts'
      provides: 'Alert Zod validation schemas'
      exports: ['AlertSchema', 'AlertAcknowledgeSchema', 'AlertResolveSchema']
    - path: 'backend/src/services/alert.service.ts'
      provides: 'Alert CRUD operations'
      exports: ['listAlerts', 'getAlert', 'acknowledgeAlert', 'resolveAlert']
    - path: 'backend/src/routes/alerts.ts'
      provides: 'Alert REST endpoints'
      exports: ['default']
  key_links:
    - from: 'backend/src/routes/alerts.ts'
      to: 'backend/src/services/alert.service.ts'
      via: 'service function calls'
      pattern: "alertService\\."
    - from: 'backend/src/services/alert.service.ts'
      to: 'backend/src/db/schema/alerts.ts'
      via: 'alerts table queries'
      pattern: 'alerts'
---

<objective>
Create alert service and REST endpoints for viewing, acknowledging, and resolving alerts with proper RBAC enforcement.

Purpose: Enable staff to manage alert lifecycle - view active alerts, acknowledge to indicate awareness, and resolve when the issue is addressed.

Output:

- Alert Zod schemas for validation
- Alert service with list, acknowledge, resolve operations
- Alert REST endpoints with staff+ role requirement
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-sensor-data-alert-system/04-RESEARCH.md

# Database schemas

@backend/src/db/schema/alerts.ts
@backend/src/db/schema/hierarchy.ts

# Existing patterns

@backend/src/routes/units.ts
@backend/src/services/unit.service.ts
@backend/src/schemas/units.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create alert Zod schemas</name>
  <files>backend/src/schemas/alerts.ts</files>
  <action>
Create `alerts.ts` Zod schemas following existing patterns:

1. **Enum schemas (match database enums):**

   ```typescript
   export const AlertTypeSchema = z.enum([
     'alarm_active',
     'monitoring_interrupted',
     'low_battery',
     'offline',
     'manual_required',
   ]);

   export const AlertSeveritySchema = z.enum(['info', 'warning', 'critical']);

   export const AlertStatusSchema = z.enum(['active', 'acknowledged', 'resolved', 'expired']);
   ```

2. **AlertSchema (response):**
   - id, unitId, alertRuleId (nullable), alertType, severity, status
   - message (nullable), triggerTemperature (nullable), thresholdViolated (nullable)
   - triggeredAt, acknowledgedAt (nullable), acknowledgedBy (nullable)
   - resolvedAt (nullable), resolvedBy (nullable)
   - escalatedAt (nullable), escalationLevel
   - metadata (nullable), createdAt, updatedAt

3. **AlertAcknowledgeSchema (request body):**
   - notes: z.string().max(1000).optional()

4. **AlertResolveSchema (request body):**
   - resolution: z.string().min(1).max(2000)
   - correctiveAction: z.string().max(2000).optional()

5. **AlertQuerySchema (query params):**
   - unitId: UuidSchema.optional()
   - status: AlertStatusSchema.optional() or z.array for multiple
   - severity: AlertSeveritySchema.optional()
   - start: z.string().datetime().optional()
   - end: z.string().datetime().optional()
   - limit: z.coerce.number().int().min(1).max(100).default(50)
   - offset: z.coerce.number().int().min(0).default(0)

6. **AlertParamsSchema:**
   - organizationId: UuidSchema
   - alertId: UuidSchema

Export all schemas and inferred types.
</action>
<verify>
TypeScript compiles: `cd backend && pnpm tsc --noEmit`
</verify>
<done>

- All alert enums match database definitions
- AlertSchema matches database columns
- Request body schemas have proper validation
- Query schema supports filtering and pagination
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create alert service</name>
  <files>backend/src/services/alert.service.ts, backend/src/services/index.ts</files>
  <action>
Create `alert.service.ts` with these functions:

1. **verifyAlertAccess(alertId: string, organizationId: string): Promise<Alert | null>**
   - Verify alert belongs to org via unit -> area -> site -> org hierarchy
   - Return alert if accessible, null otherwise
   - Use innerJoin pattern similar to verifyAreaAccess

2. **listAlerts(organizationId: string, params: AlertQuery): Promise<Alert[]>**
   - Query alerts for units within the organization
   - Filter by status, severity, unitId, time range as provided
   - Apply pagination (limit, offset)
   - Order by triggeredAt descending (newest first)
   - Join through hierarchy to enforce org isolation

3. **getAlert(alertId: string, organizationId: string): Promise<Alert | null>**
   - Get single alert with hierarchy validation
   - Return null if not found or not in org

4. **acknowledgeAlert(alertId: string, organizationId: string, profileId: string, notes?: string): Promise<Alert | 'already_acknowledged' | null>**
   - Verify alert access
   - Check if already acknowledged -> return 'already_acknowledged'
   - Update status to 'acknowledged', set acknowledgedAt and acknowledgedBy
   - Return updated alert

5. **resolveAlert(alertId: string, organizationId: string, profileId: string, resolution: string, correctiveAction?: string): Promise<Alert | null>**
   - Verify alert access
   - Update status to 'resolved', set resolvedAt, resolvedBy
   - If correctiveAction provided, create correctiveActions record
   - Update unit status to 'ok' if currently in alarm state
   - Return updated alert

Update `services/index.ts` to export alert service.
</action>
<verify>
TypeScript compiles: `cd backend && pnpm tsc --noEmit`
</verify>
<done>

- verifyAlertAccess validates hierarchy
- listAlerts enforces org isolation with joins
- acknowledgeAlert handles already-acknowledged case
- resolveAlert updates unit status and creates corrective action
- Service exported from index.ts
  </done>
  </task>

<task type="auto">
  <name>Task 3: Create alert routes and register in app</name>
  <files>backend/src/routes/alerts.ts, backend/src/app.ts</files>
  <action>
Create `alerts.ts` routes:

**1. GET /api/orgs/:organizationId/alerts**

- preHandler: [requireAuth, requireOrgContext]
- Query params: AlertQuerySchema
- Returns paginated alerts for organization

**2. GET /api/orgs/:organizationId/alerts/:alertId**

- preHandler: [requireAuth, requireOrgContext]
- Returns single alert or 404

**3. POST /api/orgs/:organizationId/alerts/:alertId/acknowledge**

- preHandler: [requireAuth, requireOrgContext, requireRole('staff')]
- Body: AlertAcknowledgeSchema
- Returns updated alert, 404 if not found, 409 if already acknowledged

**4. POST /api/orgs/:organizationId/alerts/:alertId/resolve**

- preHandler: [requireAuth, requireOrgContext, requireRole('staff')]
- Body: AlertResolveSchema
- Returns updated alert or 404

Implementation notes:

- Use existing patterns from units.ts
- Staff role required for acknowledge/resolve (not manager/admin)
- 409 Conflict for already-acknowledged case

Update `app.ts`:

```typescript
import alertRoutes from './routes/alerts.js';

// In buildApp:
app.register(alertRoutes, { prefix: '/api/orgs/:organizationId/alerts' });
```

  </action>
  <verify>
1. TypeScript compiles: `cd backend && pnpm tsc --noEmit`
2. Routes registered in app.ts
  </verify>
  <done>
- GET alerts list with filtering and pagination
- GET single alert with hierarchy validation
- POST acknowledge requires staff role
- POST resolve requires staff role and creates corrective action
- Routes registered in app.ts
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd backend && pnpm tsc --noEmit`
2. All routes enforce org context and RBAC
3. Alert status transitions validated
</verification>

<success_criteria>

- GET /api/orgs/:orgId/alerts returns alerts filtered by org hierarchy
- GET /api/orgs/:orgId/alerts/:alertId returns single alert or 404
- POST acknowledge changes status, requires staff+ role
- POST resolve changes status and optionally creates corrective action
- Already-acknowledged returns 409 Conflict
- All operations validate org hierarchy
  </success_criteria>

<output>
After completion, create `.planning/phases/04-sensor-data-alert-system/04-04-SUMMARY.md`
</output>
