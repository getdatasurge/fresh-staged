---
phase: 04-sensor-data-alert-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/alert-evaluator.service.ts
  - backend/src/services/index.ts
autonomous: true

must_haves:
  truths:
    - "Temperature above max triggers excursion state"
    - "Temperature below min triggers excursion state"
    - "Existing active alert prevents duplicate creation"
    - "Temperature returning to range transitions to restoring"
    - "Unit status is updated atomically with alert creation"
  artifacts:
    - path: "backend/src/services/alert-evaluator.service.ts"
      provides: "Alert evaluation and state machine logic"
      exports: ["evaluateUnitAfterReading", "createAlertIfNotExists", "resolveEffectiveThresholds"]
  key_links:
    - from: "backend/src/services/alert-evaluator.service.ts"
      to: "backend/src/db/schema/alerts.ts"
      via: "alerts table insert/update"
      pattern: "alerts"
    - from: "backend/src/services/alert-evaluator.service.ts"
      to: "backend/src/db/schema/hierarchy.ts"
      via: "units table status update"
      pattern: "units.*status"
---

<objective>
Create the alert evaluator service that implements temperature threshold evaluation, unit state machine transitions, and alert deduplication.

Purpose: The core business logic that determines when temperature excursions become alerts, prevents duplicate alerts for ongoing excursions, and manages unit status throughout the alert lifecycle.

Output:
- Alert evaluator service with state machine logic
- Rule hierarchy resolution (unit -> site -> org fallback)
- Alert deduplication via status-based idempotency
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-sensor-data-alert-system/04-RESEARCH.md

# Database schemas
@backend/src/db/schema/alerts.ts
@backend/src/db/schema/hierarchy.ts

# Existing service patterns
@backend/src/services/unit.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create alert evaluator service with state machine</name>
  <files>backend/src/services/alert-evaluator.service.ts</files>
  <action>
Create `alert-evaluator.service.ts` implementing the unit status state machine:

**State Machine (from research doc):**
```
ok -> excursion -> alarm_active -> restoring -> ok
     (immediate)  (after confirm)  (temp returns)  (N good readings)
```

**Core Types:**
```typescript
interface EvaluationResult {
  stateChange: { from: string; to: string; reason: string } | null;
  alertCreated: Alert | null;
  alertResolved: Alert | null;
}

interface EffectiveThresholds {
  tempMin: number;
  tempMax: number;
  hysteresis: number;
  confirmTimeSeconds: number;
}
```

**Functions to implement:**

1. `resolveEffectiveThresholds(unitId: string): Promise<EffectiveThresholds>`
   - First check unit's tempMin/tempMax columns
   - If unit-level alert rule exists with thresholds, use those
   - Fallback to site-level rule, then org-level rule
   - Default hysteresis: 5 (0.5 degrees in integer format)
   - Default confirmTime: 600 seconds (10 min)

2. `createAlertIfNotExists(tx: DrizzleTransaction, data: InsertAlert): Promise<Alert | null>`
   - Check for existing alert with same unitId and alertType where status IN ('active', 'acknowledged')
   - If exists, return null (no duplicate)
   - If not exists, insert and return new alert

3. `evaluateUnitAfterReading(unitId: string, latestTemp: number, recordedAt: Date): Promise<EvaluationResult>`
   - Use db.transaction for atomic state changes
   - Fetch unit with current status
   - Get effective thresholds via resolveEffectiveThresholds
   - Evaluate temperature against thresholds:
     * `isAboveLimit = latestTemp > tempMax`
     * `isBelowLimit = latestTemp < tempMin`
     * `isOutOfRange = isAboveLimit || isBelowLimit`
   - Apply state transitions:
     * ok + outOfRange -> excursion (create alert with severity: 'warning')
     * excursion + outOfRange + confirmTime elapsed -> alarm_active (escalate to severity: 'critical')
     * (excursion | alarm_active) + inRange with hysteresis -> restoring (resolve alert)
   - Update unit status and lastStatusChange timestamp
   - Return EvaluationResult with any state change and alert mutations

**Key implementation details:**
- Use Drizzle `inArray(alerts.status, ['active', 'acknowledged'])` for deduplication check
- Temperature comparison uses integers (32.0F = 320)
- Hysteresis: temp must be `<= (tempMax - hysteresis)` AND `>= (tempMin + hysteresis)` to recover
- Store `lastStatusChange` on unit for confirmation delay calculation
  </action>
  <verify>
TypeScript compiles: `cd backend && pnpm tsc --noEmit`
  </verify>
  <done>
- State machine implements ok -> excursion -> alarm_active -> restoring -> ok
- resolveEffectiveThresholds checks unit -> site -> org hierarchy
- createAlertIfNotExists prevents duplicates
- evaluateUnitAfterReading uses transactions for atomicity
- Hysteresis prevents oscillation between states
  </done>
</task>

<task type="auto">
  <name>Task 2: Add rule hierarchy resolution with caching</name>
  <files>backend/src/services/alert-evaluator.service.ts</files>
  <action>
Enhance `resolveEffectiveThresholds` to properly resolve alertRules hierarchy:

1. **Query alert rules for unit:**
   ```typescript
   const rules = await db
     .select()
     .from(alertRules)
     .where(and(
       eq(alertRules.isEnabled, true),
       or(
         eq(alertRules.unitId, unitId),
         eq(alertRules.siteId, unit.area.site.id),
         eq(alertRules.organizationId, orgId)
       )
     ))
     .orderBy(/* most specific first */);
   ```

2. **Priority order (most specific wins):**
   - Unit-level rule (alertRules.unitId = unitId)
   - Site-level rule (alertRules.siteId = siteId, unitId is null)
   - Org-level rule (alertRules.organizationId = orgId, siteId and unitId are null)

3. **Threshold resolution logic:**
   - Start with unit's tempMin/tempMax as base
   - If rule exists at any level, use rule's thresholds if defined
   - Rule's delayMinutes * 60 = confirmTimeSeconds

4. **Handle missing thresholds gracefully:**
   - If no rule and no unit thresholds, throw error (misconfiguration)
   - Log warning if falling back to org-level defaults

Note: For this phase, focus on correctness over performance. Caching can be added later if needed.
  </action>
  <verify>
TypeScript compiles: `cd backend && pnpm tsc --noEmit`
  </verify>
  <done>
- Rule hierarchy resolves unit -> site -> org correctly
- Most specific rule wins (unit overrides site overrides org)
- delayMinutes from rule converts to confirmTimeSeconds
- Missing configuration handled with appropriate errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Update services barrel export</name>
  <files>backend/src/services/index.ts</files>
  <action>
Update `services/index.ts` to export the alert-evaluator service:

```typescript
export * as alertEvaluator from './alert-evaluator.service.js';
```

Follow the namespace export pattern used by existing services (site, unit, etc.).
  </action>
  <verify>
Import from services/index.ts works: `cd backend && pnpm tsc --noEmit`
  </verify>
  <done>
- alertEvaluator namespace exported from services/index.ts
- All functions accessible via `services.alertEvaluator.*`
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd backend && pnpm tsc --noEmit`
2. State machine transitions documented in code comments
3. Alert deduplication query correctly filters by status
</verification>

<success_criteria>
- State machine correctly transitions through all states
- Rule hierarchy resolves unit -> site -> org with proper precedence
- Duplicate alerts prevented via status-based deduplication
- Unit status updated atomically within transaction
- Hysteresis prevents rapid state oscillation
</success_criteria>

<output>
After completion, create `.planning/phases/04-sensor-data-alert-system/04-02-SUMMARY.md`
</output>
