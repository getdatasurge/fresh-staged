---
phase: 04-sensor-data-alert-system
plan: 05
type: execute
wave: 3
depends_on: ['04-03', '04-04']
files_modified:
  - backend/tests/api/readings.test.ts
  - backend/tests/api/alerts.test.ts
  - backend/tests/helpers/fixtures.ts
autonomous: true

must_haves:
  truths:
    - 'Bulk readings insert returns correct count'
    - 'Temperature above threshold creates alert'
    - 'Duplicate alerts not created for ongoing excursion'
    - 'Alert acknowledge changes status'
    - 'Alert resolve changes status and unit state'
    - 'Cross-org access returns 403 or 404'
  artifacts:
    - path: 'backend/tests/api/readings.test.ts'
      provides: 'Readings API tests'
      min_lines: 100
    - path: 'backend/tests/api/alerts.test.ts'
      provides: 'Alerts API tests'
      min_lines: 100
  key_links:
    - from: 'backend/tests/api/readings.test.ts'
      to: 'backend/src/routes/readings.ts'
      via: 'Fastify inject'
      pattern: "app\\.inject"
    - from: 'backend/tests/api/alerts.test.ts'
      to: 'backend/src/routes/alerts.ts'
      via: 'Fastify inject'
      pattern: "app\\.inject"
---

<objective>
Create comprehensive integration tests for the readings and alerts APIs, covering threshold scenarios, alert lifecycle, and security boundaries.

Purpose: Verify that the sensor data ingestion and alert system works correctly end-to-end, including threshold violations, duplicate prevention, and RBAC enforcement.

Output:

- Readings API tests (bulk ingestion, query, validation)
- Alerts API tests (list, acknowledge, resolve, lifecycle)
- Extended test fixtures for sensor/alert data
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-sensor-data-alert-system/04-RESEARCH.md

# Existing test patterns

@backend/tests/api/sites.test.ts
@backend/tests/api/units.test.ts
@backend/tests/helpers/fixtures.ts

# Routes under test (will exist after 04-03, 04-04)

@backend/src/routes/readings.ts
@backend/src/routes/alerts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend test fixtures for sensor data</name>
  <files>backend/tests/helpers/fixtures.ts</files>
  <action>
Add new fixture helpers to support sensor/alert testing:

1. **createTestApiKey(organizationId: string): Promise<string>**
   - Insert a ttnConnections record with a test webhook secret
   - Return the webhook secret for use in X-API-Key header
   - Use a predictable format: `test-api-key-${randomSuffix}`

2. **createTestAlertRule(options): Promise<AlertRule>**
   - Create alertRule with specified org/site/unit scope
   - Default tempMin: 320, tempMax: 400 (32-40F)
   - Default delayMinutes: 0 (immediate for testing)

3. **createTestReading(unitId, overrides): InsertSensorReading**
   - Factory for creating test reading objects
   - Default temperature: 350 (35F - in range)
   - Default recordedAt: now
   - Default source: 'api'

4. **cleanupTestApiKeys(orgIds: string[]): Promise<void>**
   - Delete test ttnConnections records

Mock patterns for service mocking (if needed for isolated tests):

```typescript
vi.mock('../../src/services/readings.service.js', () => ({
  validateUnitsInOrg: vi.fn().mockResolvedValue(['test-unit-id']),
  ingestBulkReadings: vi.fn().mockResolvedValue({
    insertedCount: 1,
    readingIds: ['test-reading-id'],
  }),
}));
```

  </action>
  <verify>
TypeScript compiles: `cd backend && pnpm tsc --noEmit`
  </verify>
  <done>
- createTestApiKey creates ttnConnections record
- createTestAlertRule supports org/site/unit scope
- createTestReading factory generates valid readings
- Cleanup functions added for test isolation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create readings API tests</name>
  <files>backend/tests/api/readings.test.ts</files>
  <action>
Create comprehensive readings tests:

**describe('POST /api/ingest/readings')**

1. **Authentication tests:**
   - Returns 401 without API key header
   - Returns 401 with invalid API key
   - Returns 200 with valid API key

2. **Validation tests:**
   - Returns 400 for empty readings array
   - Returns 400 for readings > 1000
   - Returns 400 for invalid unitId format
   - Returns 400 for missing required fields (temperature, recordedAt)

3. **Authorization tests:**
   - Returns 403 when unit doesn't belong to API key's org
   - Returns 200 when all units belong to org

4. **Bulk insert tests:**
   - Single reading inserts successfully
   - Multiple readings (10) insert successfully
   - Returns correct insertedCount and readingIds
   - Unit lastReadingAt updated after insert

5. **Alert triggering tests:**
   - Temperature above threshold (420 > 400) triggers alert
   - alertsTriggered count > 0 when threshold violated
   - Temperature in range (350) does NOT trigger alert

**describe('GET /api/orgs/:orgId/.../units/:unitId/readings')**

1. **Authentication tests:**
   - Returns 401 without JWT
   - Returns 200 with valid JWT

2. **Pagination tests:**
   - Returns readings with default limit (100)
   - Respects custom limit parameter
   - Respects offset parameter
   - Returns empty array when offset > total

3. **Filtering tests:**
   - Filters by start time (returns only readings after)
   - Filters by end time (returns only readings before)
   - Combines start and end for range query

4. **Authorization tests:**
   - Returns 404 for unit in different org
   - Returns readings for unit in user's org

Use service mocking pattern from existing tests (mock at service layer, not database).
</action>
<verify>
Run tests: `cd backend && pnpm test readings`
</verify>
<done>

- All authentication tests pass (401 for invalid/missing)
- Validation tests catch malformed payloads
- Authorization tests verify org isolation
- Bulk insert tests confirm correct operation
- Alert triggering tests verify threshold logic
- Pagination and filtering tests work correctly
  </done>
  </task>

<task type="auto">
  <name>Task 3: Create alerts API tests</name>
  <files>backend/tests/api/alerts.test.ts</files>
  <action>
Create comprehensive alerts tests:

**describe('GET /api/orgs/:orgId/alerts')**

1. **Authentication tests:**
   - Returns 401 without JWT
   - Returns 200 with valid JWT

2. **Listing tests:**
   - Returns alerts for organization
   - Filters by status (active, acknowledged, resolved)
   - Filters by severity
   - Filters by unitId
   - Pagination works correctly

3. **Authorization tests:**
   - Only returns alerts for user's organization
   - Empty result for org with no alerts

**describe('GET /api/orgs/:orgId/alerts/:alertId')**

1. Returns alert details with valid alertId
2. Returns 404 for non-existent alertId
3. Returns 404 for alertId in different org (security)

**describe('POST /api/orgs/:orgId/alerts/:alertId/acknowledge')**

1. **Role tests:**
   - Returns 403 for viewer role
   - Returns 200 for staff role
   - Returns 200 for manager/admin/owner

2. **Status transition tests:**
   - Changes status from 'active' to 'acknowledged'
   - Sets acknowledgedAt timestamp
   - Sets acknowledgedBy to current user's profileId
   - Notes are saved if provided

3. **Idempotency tests:**
   - Returns 409 Conflict if already acknowledged
   - Returns 404 for non-existent alert

**describe('POST /api/orgs/:orgId/alerts/:alertId/resolve')**

1. **Role tests:**
   - Returns 403 for viewer role
   - Returns 200 for staff role

2. **Status transition tests:**
   - Changes status to 'resolved'
   - Sets resolvedAt timestamp
   - Sets resolvedBy to current user's profileId
   - Resolution text is saved

3. **Corrective action tests:**
   - Creates correctiveAction record when provided
   - Works without correctiveAction

4. **Unit state tests:**
   - Unit status changes to 'ok' after resolve (if in alarm state)

**describe('Alert Lifecycle Integration')**

1. Full lifecycle test:
   - Create alert via threshold violation
   - List shows alert as 'active'
   - Acknowledge changes to 'acknowledged'
   - Resolve changes to 'resolved'
   - Unit status back to 'ok'

2. Duplicate prevention test:
   - Trigger alert with first out-of-range reading
   - Submit second out-of-range reading
   - Verify no new alert created (alertsTriggered = 0)
     </action>
     <verify>
     Run tests: `cd backend && pnpm test alerts`
     </verify>
     <done>

- Authentication and RBAC tests pass
- Alert listing with filters works
- Acknowledge transitions status correctly
- Resolve transitions status and creates corrective action
- Full lifecycle test passes
- Duplicate prevention verified
  </done>
  </task>

</tasks>

<verification>
1. All tests pass: `cd backend && pnpm test`
2. Test coverage for key scenarios
3. No flaky tests (run multiple times)
</verification>

<success_criteria>

- All readings tests pass (bulk insert, query, validation, auth)
- All alerts tests pass (list, acknowledge, resolve, lifecycle)
- Threshold violation creates alert (verified in test)
- Duplicate alerts prevented (verified in test)
- RBAC enforced (viewer cannot acknowledge/resolve)
- Cross-org access blocked (404 response)
- Full alert lifecycle works end-to-end
  </success_criteria>

<output>
After completion, create `.planning/phases/04-sensor-data-alert-system/04-05-SUMMARY.md`
</output>
