---
phase: 33-error-handling-ui-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/errorHandler.ts
  - src/components/errors/MigrationErrorBoundary.tsx
  - src/components/errors/MigrationErrorFallback.tsx
autonomous: true

must_haves:
  truths:
    - "Migration errors show specific toast message with feature name"
    - "Migration errors caught by boundary show fallback UI card"
    - "Non-migration errors pass through unchanged"
  artifacts:
    - path: "src/lib/errorHandler.ts"
      provides: "Migration-aware error handling"
      contains: "isSupabaseMigrationError"
    - path: "src/components/errors/MigrationErrorBoundary.tsx"
      provides: "React error boundary for migration errors"
      exports: ["MigrationErrorBoundary"]
    - path: "src/components/errors/MigrationErrorFallback.tsx"
      provides: "Fallback UI for migration errors"
      exports: ["MigrationErrorFallback"]
  key_links:
    - from: "src/lib/errorHandler.ts"
      to: "src/lib/supabase-placeholder.ts"
      via: "import isSupabaseMigrationError"
      pattern: "import.*isSupabaseMigrationError.*from.*supabase-placeholder"
    - from: "src/components/errors/MigrationErrorBoundary.tsx"
      to: "src/lib/supabase-placeholder.ts"
      via: "import isSupabaseMigrationError"
      pattern: "import.*isSupabaseMigrationError.*from.*supabase-placeholder"
---

<objective>
Create the error handling infrastructure for SupabaseMigrationError integration.

Purpose: Enable user-friendly error messages for deprecated Supabase functionality instead of generic errors.
Output: Extended errorHandler.ts with migration detection, MigrationErrorBoundary and MigrationErrorFallback components.
</objective>

<execution_context>
@/home/swoop/.claude/get-shit-done/workflows/execute-plan.md
@/home/swoop/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-error-handling-ui-integration/33-RESEARCH.md
@src/lib/supabase-placeholder.ts
@src/lib/errorHandler.ts
@src/features/dashboard-layout/components/DashboardErrorBoundary.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend errorHandler.ts with migration error detection</name>
  <files>src/lib/errorHandler.ts</files>
  <action>
Update errorHandler.ts to detect and handle SupabaseMigrationError:

1. Add imports at top:
   ```typescript
   import { isSupabaseMigrationError, SupabaseMigrationError } from '@/lib/supabase-placeholder';
   ```

2. Add new helper function after isPermissionError:
   ```typescript
   /**
    * Check if an error is a Supabase migration error
    */
   export function isMigrationError(error: unknown): boolean {
     return isSupabaseMigrationError(error);
   }

   /**
    * Get user-friendly message for migration errors
    */
   export function getMigrationErrorMessage(error: unknown): string {
     if (isSupabaseMigrationError(error)) {
       const migrationError = error as SupabaseMigrationError;
       if (migrationError.featureName) {
         return `The "${migrationError.featureName}" feature is temporarily unavailable while being migrated.`;
       }
       return 'This feature is temporarily unavailable while being migrated to the new backend.';
     }
     return 'An unexpected error occurred.';
   }
   ```

3. Update handleError function to check for migration errors FIRST (before permission errors):
   ```typescript
   export function handleError(
     error: unknown,
     action?: string,
     fallbackMessage?: string
   ): void {
     console.error('Operation failed:', error);

     // Check for migration error FIRST
     if (isSupabaseMigrationError(error)) {
       const migrationError = error as SupabaseMigrationError;
       const featureMsg = migrationError.featureName
         ? ` (${migrationError.featureName})`
         : '';
       toast.error(`This feature is temporarily unavailable${featureMsg}`, {
         description: 'It is being migrated to the new backend. Please try again later.',
         duration: 5000,
       });
       return;
     }

     if (isPermissionError(error)) {
       toast.error(getPermissionErrorMessage(error, action));
       return;
     }

     // Use fallback or generic message
     const message = fallbackMessage || getPermissionErrorMessage(error, action);
     toast.error(message);
   }
   ```

Keep existing isPermissionError, getPermissionErrorMessage, handleMutationResult, and getRequiredRoleMessage functions unchanged.
  </action>
  <verify>
1. Run TypeScript check: `npx tsc --noEmit src/lib/errorHandler.ts`
2. Verify imports resolve: grep for "isSupabaseMigrationError" in errorHandler.ts
3. Run existing tests if any: `npm test -- errorHandler`
  </verify>
  <done>
- errorHandler.ts exports isMigrationError and getMigrationErrorMessage
- handleError() checks migration errors before permission errors
- Migration errors show toast with feature name when available
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MigrationErrorBoundary and MigrationErrorFallback components</name>
  <files>
src/components/errors/MigrationErrorBoundary.tsx
src/components/errors/MigrationErrorFallback.tsx
  </files>
  <action>
Create src/components/errors/ directory and two new components.

**MigrationErrorFallback.tsx:**
```typescript
/**
 * Migration Error Fallback
 *
 * Displays a user-friendly card when a feature is unavailable due to
 * Supabase migration. Matches DashboardErrorBoundary styling.
 */

import { AlertTriangle, RefreshCw } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { SupabaseMigrationError } from "@/lib/supabase-placeholder";

interface MigrationErrorFallbackProps {
  error: Error | null;
  onRetry?: () => void;
}

export function MigrationErrorFallback({ error, onRetry }: MigrationErrorFallbackProps) {
  const migrationError = error as SupabaseMigrationError | null;
  const featureName = migrationError?.featureName;

  return (
    <Card className="border-warning/50 bg-warning/5">
      <CardHeader className="pb-3">
        <div className="flex items-center gap-2">
          <AlertTriangle className="h-5 w-5 text-warning" />
          <CardTitle className="text-lg">Feature Temporarily Unavailable</CardTitle>
        </div>
        <CardDescription>
          {featureName
            ? `The "${featureName}" feature is being migrated to our new backend.`
            : "This feature is being migrated to our new backend."}
          {" "}It will be available again soon.
        </CardDescription>
      </CardHeader>
      {onRetry && (
        <CardContent>
          <Button variant="outline" size="sm" onClick={onRetry}>
            <RefreshCw className="h-4 w-4 mr-2" />
            Try Again
          </Button>
        </CardContent>
      )}
    </Card>
  );
}
```

**MigrationErrorBoundary.tsx:**
```typescript
/**
 * Migration Error Boundary
 *
 * Catches render-time errors from Supabase placeholder calls and displays
 * a user-friendly fallback. Non-migration errors are re-thrown to parent
 * error boundaries.
 */

import React, { Component, ReactNode } from "react";
import { isSupabaseMigrationError } from "@/lib/supabase-placeholder";
import { MigrationErrorFallback } from "./MigrationErrorFallback";

interface MigrationErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

interface MigrationErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  isMigrationError: boolean;
}

export class MigrationErrorBoundary extends Component<
  MigrationErrorBoundaryProps,
  MigrationErrorBoundaryState
> {
  constructor(props: MigrationErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null, isMigrationError: false };
  }

  static getDerivedStateFromError(error: Error): MigrationErrorBoundaryState {
    return {
      hasError: true,
      error,
      isMigrationError: isSupabaseMigrationError(error),
    };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("[MigrationErrorBoundary]", {
      error: error.message,
      isMigration: isSupabaseMigrationError(error),
      componentStack: errorInfo.componentStack,
    });
  }

  handleRetry = () => {
    this.setState({ hasError: false, error: null, isMigrationError: false });
  };

  render() {
    if (this.state.hasError && this.state.isMigrationError) {
      return (
        this.props.fallback || (
          <MigrationErrorFallback
            error={this.state.error}
            onRetry={this.handleRetry}
          />
        )
      );
    }

    // Re-throw non-migration errors to parent boundaries
    if (this.state.hasError) {
      throw this.state.error;
    }

    return this.props.children;
  }
}
```

Ensure both files use consistent formatting with the DashboardErrorBoundary reference.
  </action>
  <verify>
1. Run TypeScript check: `npx tsc --noEmit src/components/errors/*.tsx`
2. Verify directory created: `ls -la src/components/errors/`
3. Verify exports: grep for "export" in both files
  </verify>
  <done>
- src/components/errors/ directory exists with two files
- MigrationErrorBoundary catches errors, checks isSupabaseMigrationError
- Non-migration errors re-thrown to parent boundaries
- MigrationErrorFallback shows warning card with feature name when available
- Retry button resets error state
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. No circular imports: Check that supabase-placeholder does not import from errorHandler or error components
3. Exports available: Both new components and errorHandler functions are exported
</verification>

<success_criteria>
- [ ] errorHandler.ts detects SupabaseMigrationError before other errors
- [ ] Migration errors show toast with feature name
- [ ] MigrationErrorBoundary catches and displays migration errors
- [ ] Non-migration errors pass through to parent boundaries
- [ ] All files type-check with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/33-error-handling-ui-integration/33-01-SUMMARY.md`
</output>
