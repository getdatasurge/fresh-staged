---
phase: 01-local-development-environment
plan: 04
type: execute
wave: 2
depends_on: ['01-02']
files_modified:
  - backend/src/db/schema/alerts.ts
  - backend/src/db/schema/notifications.ts
  - backend/src/db/schema/audit.ts
autonomous: true

must_haves:
  truths:
    - 'alert_rules supports hierarchical inheritance (org > site > unit)'
    - 'alerts table tracks full lifecycle (active > acknowledged > resolved)'
    - 'corrective_actions links to alerts and profiles for compliance documentation'
    - 'notification_deliveries tracks delivery status per channel'
    - 'event_logs provides tamper-evident audit trail with hash chain'
  artifacts:
    - path: 'backend/src/db/schema/alerts.ts'
      provides: 'Alert rules and alerts tables'
      contains: 'alertRules'
      exports: ['alertRules', 'alertRulesHistory', 'alerts', 'correctiveActions']
    - path: 'backend/src/db/schema/notifications.ts'
      provides: 'Notification delivery tracking'
      contains: 'notificationDeliveries'
      exports: ['notificationDeliveries']
    - path: 'backend/src/db/schema/audit.ts'
      provides: 'Event logging for compliance'
      contains: 'eventLogs'
      exports: ['eventLogs']
  key_links:
    - from: 'backend/src/db/schema/alerts.ts'
      to: 'hierarchy.ts'
      via: 'alertRules references organizations, sites, units'
      pattern: 'references.*(organizations|sites|units)'
    - from: 'backend/src/db/schema/alerts.ts'
      to: 'users.ts'
      via: 'correctiveActions references profiles'
      pattern: 'references.*profiles'
    - from: 'backend/src/db/schema/notifications.ts'
      to: 'alerts.ts'
      via: 'notificationDeliveries references alerts'
      pattern: 'references.*alerts'
---

<objective>
Define alerts, notifications, and audit schemas to complete the database schema.

Purpose: These tables handle the alert lifecycle (rules > triggered alerts > corrective actions), notification delivery tracking, and compliance audit logging. They complete the 17+ table requirement from the Supabase schema inventory.

Output: Three schema files with 6 tables covering alert rules, alerts, corrective actions, notification deliveries, and event logs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-local-development-environment/01-RESEARCH.md
@docs/SUPABASE_SCHEMA_INVENTORY.md

Key patterns:

- alert_rules has hierarchical inheritance: org-level > site-level > unit-level
- alerts track full lifecycle with status enum
- corrective_actions document resolution for HACCP compliance
- event_logs use hash chain for tamper evidence
- Use JSON columns (text type) for flexible payload storage
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Create alerts schemas (alert_rules, alert_rules_history, alerts, corrective_actions)</name>
  <files>backend/src/db/schema/alerts.ts</files>
  <action>
Create the alerting system tables:

**backend/src/db/schema/alerts.ts:**

```typescript
import {
  pgTable,
  uuid,
  varchar,
  text,
  integer,
  boolean,
  timestamp,
  index,
} from 'drizzle-orm/pg-core';
import { alertTypeEnum, alertSeverityEnum, alertStatusEnum } from './enums.js';
import { organizations } from './tenancy.js';
import { sites, units } from './hierarchy.js';
import { profiles } from './users.js';

// Reusable timestamp columns
const timestamps = {
  createdAt: timestamp('created_at', {
    mode: 'date',
    precision: 3,
    withTimezone: true,
  })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp('updated_at', {
    mode: 'date',
    precision: 3,
    withTimezone: true,
  })
    .defaultNow()
    .notNull()
    .$onUpdateFn(() => new Date()),
};

// Alert Rules - threshold configuration with hierarchical inheritance
export const alertRules = pgTable(
  'alert_rules',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    // Hierarchical scope: org > site > unit (only one should be set)
    organizationId: uuid('organization_id')
      .references(() => organizations.id, { onDelete: 'cascade' })
      .notNull(),
    siteId: uuid('site_id').references(() => sites.id, { onDelete: 'cascade' }),
    unitId: uuid('unit_id').references(() => units.id, { onDelete: 'cascade' }),
    // Rule name for display
    name: varchar('name', { length: 256 }).notNull(),
    // Temperature thresholds (in device units)
    tempMin: integer('temp_min'),
    tempMax: integer('temp_max'),
    // Delay before triggering alert (minutes)
    delayMinutes: integer('delay_minutes').notNull().default(5),
    // Alert configuration
    alertType: alertTypeEnum('alert_type').notNull().default('alarm_active'),
    severity: alertSeverityEnum('severity').notNull().default('warning'),
    // Whether rule is active
    isEnabled: boolean('is_enabled').notNull().default(true),
    // Optional schedule (JSON: { days: [0-6], startHour, endHour })
    schedule: text('schedule'),
    ...timestamps,
  },
  (table) => [
    index('alert_rules_org_idx').on(table.organizationId),
    index('alert_rules_site_idx').on(table.siteId),
    index('alert_rules_unit_idx').on(table.unitId),
    index('alert_rules_enabled_idx').on(table.organizationId, table.isEnabled),
  ],
);

// Alert Rules History - audit trail for rule changes
export const alertRulesHistory = pgTable(
  'alert_rules_history',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    alertRuleId: uuid('alert_rule_id')
      .references(() => alertRules.id, { onDelete: 'cascade' })
      .notNull(),
    changedBy: uuid('changed_by').references(() => profiles.id, {
      onDelete: 'set null',
    }),
    changeType: varchar('change_type', { length: 32 }).notNull(), // 'created', 'updated', 'deleted'
    oldValues: text('old_values'), // JSON of previous values
    newValues: text('new_values'), // JSON of new values
    changedAt: timestamp('changed_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    })
      .defaultNow()
      .notNull(),
  },
  (table) => [
    index('alert_rules_history_rule_idx').on(table.alertRuleId),
    index('alert_rules_history_date_idx').on(table.changedAt),
  ],
);

// Alerts - active and historical alerts
export const alerts = pgTable(
  'alerts',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    unitId: uuid('unit_id')
      .references(() => units.id, { onDelete: 'cascade' })
      .notNull(),
    alertRuleId: uuid('alert_rule_id').references(() => alertRules.id, {
      onDelete: 'set null',
    }),
    // Alert classification
    alertType: alertTypeEnum('alert_type').notNull(),
    severity: alertSeverityEnum('severity').notNull(),
    status: alertStatusEnum('status').notNull().default('active'),
    // Alert details
    message: text('message'),
    // Temperature at time of alert (if applicable)
    triggerTemperature: integer('trigger_temperature'),
    thresholdViolated: varchar('threshold_violated', { length: 16 }), // 'min' or 'max'
    // Lifecycle timestamps
    triggeredAt: timestamp('triggered_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    })
      .defaultNow()
      .notNull(),
    acknowledgedAt: timestamp('acknowledged_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    acknowledgedBy: uuid('acknowledged_by').references(() => profiles.id, {
      onDelete: 'set null',
    }),
    resolvedAt: timestamp('resolved_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    resolvedBy: uuid('resolved_by').references(() => profiles.id, {
      onDelete: 'set null',
    }),
    escalatedAt: timestamp('escalated_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    // Escalation level (0 = initial, 1+ = escalated)
    escalationLevel: integer('escalation_level').notNull().default(0),
    // Metadata for additional context
    metadata: text('metadata'), // JSON
    ...timestamps,
  },
  (table) => [
    index('alerts_unit_idx').on(table.unitId),
    index('alerts_status_idx').on(table.status),
    index('alerts_type_idx').on(table.alertType),
    index('alerts_triggered_idx').on(table.triggeredAt),
    // Composite for finding active alerts per unit
    index('alerts_unit_status_idx').on(table.unitId, table.status),
  ],
);

// Corrective Actions - resolution documentation for compliance
export const correctiveActions = pgTable(
  'corrective_actions',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    alertId: uuid('alert_id')
      .references(() => alerts.id, { onDelete: 'cascade' })
      .notNull(),
    unitId: uuid('unit_id')
      .references(() => units.id, { onDelete: 'cascade' })
      .notNull(),
    profileId: uuid('profile_id').references(() => profiles.id, {
      onDelete: 'set null',
    }),
    // Action documentation
    description: text('description').notNull(),
    actionTaken: text('action_taken'),
    // Evidence for compliance
    photoUrl: text('photo_url'),
    // Whether this resolved the alert
    resolvedAlert: boolean('resolved_alert').notNull().default(false),
    // When action was taken
    actionAt: timestamp('action_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    })
      .defaultNow()
      .notNull(),
  },
  (table) => [
    index('corrective_actions_alert_idx').on(table.alertId),
    index('corrective_actions_unit_idx').on(table.unitId),
    index('corrective_actions_profile_idx').on(table.profileId),
    index('corrective_actions_date_idx').on(table.actionAt),
  ],
);

// Type exports
export type AlertRule = typeof alertRules.$inferSelect;
export type InsertAlertRule = typeof alertRules.$inferInsert;
export type AlertRuleHistory = typeof alertRulesHistory.$inferSelect;
export type InsertAlertRuleHistory = typeof alertRulesHistory.$inferInsert;
export type Alert = typeof alerts.$inferSelect;
export type InsertAlert = typeof alerts.$inferInsert;
export type CorrectiveAction = typeof correctiveActions.$inferSelect;
export type InsertCorrectiveAction = typeof correctiveActions.$inferInsert;
```

  </action>
  <verify>
```bash
cd backend && grep -E "export (const|type)" src/db/schema/alerts.ts | wc -l
```
Output should be 12 (4 tables + 8 types).
  </verify>
  <done>alertRules, alertRulesHistory, alerts, correctiveActions tables with hierarchical rules and lifecycle tracking</done>
</task>

<task type="auto">
  <name>Task 2: Create notifications schema (notification_deliveries)</name>
  <files>backend/src/db/schema/notifications.ts</files>
  <action>
Create the notification delivery tracking table:

**backend/src/db/schema/notifications.ts:**

```typescript
import { pgTable, uuid, varchar, text, timestamp, index } from 'drizzle-orm/pg-core';
import { notificationChannelEnum, notificationStatusEnum } from './enums.js';
import { alerts } from './alerts.js';
import { profiles } from './users.js';

// Notification Deliveries - tracks delivery status per channel
export const notificationDeliveries = pgTable(
  'notification_deliveries',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    alertId: uuid('alert_id')
      .references(() => alerts.id, { onDelete: 'cascade' })
      .notNull(),
    profileId: uuid('profile_id').references(() => profiles.id, {
      onDelete: 'set null',
    }),
    // Delivery channel
    channel: notificationChannelEnum('channel').notNull(),
    // Recipient address (phone, email, or device token)
    recipient: varchar('recipient', { length: 256 }).notNull(),
    // Delivery status
    status: notificationStatusEnum('status').notNull().default('pending'),
    // External provider reference (Telnyx message ID, etc.)
    externalId: varchar('external_id', { length: 256 }),
    // Error message if failed
    errorMessage: text('error_message'),
    // Timestamps
    scheduledAt: timestamp('scheduled_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    })
      .defaultNow()
      .notNull(),
    sentAt: timestamp('sent_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    deliveredAt: timestamp('delivered_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    failedAt: timestamp('failed_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    // Retry tracking
    retryCount: varchar('retry_count', { length: 10 }).default('0'),
    lastRetryAt: timestamp('last_retry_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    createdAt: timestamp('created_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    })
      .defaultNow()
      .notNull(),
  },
  (table) => [
    index('notification_deliveries_alert_idx').on(table.alertId),
    index('notification_deliveries_profile_idx').on(table.profileId),
    index('notification_deliveries_status_idx').on(table.status),
    index('notification_deliveries_channel_idx').on(table.channel),
    index('notification_deliveries_scheduled_idx').on(table.scheduledAt),
    // For finding pending deliveries to retry
    index('notification_deliveries_pending_idx').on(table.status, table.scheduledAt),
  ],
);

// Type exports
export type NotificationDelivery = typeof notificationDeliveries.$inferSelect;
export type InsertNotificationDelivery = typeof notificationDeliveries.$inferInsert;
```

  </action>
  <verify>
```bash
cd backend && grep -E "export (const|type)" src/db/schema/notifications.ts | wc -l
```
Output should be 3 (1 table + 2 types).
  </verify>
  <done>notificationDeliveries table with channel tracking and retry support</done>
</task>

<task type="auto">
  <name>Task 3: Create audit schema (event_logs)</name>
  <files>backend/src/db/schema/audit.ts</files>
  <action>
Create the tamper-evident audit log table:

**backend/src/db/schema/audit.ts:**

```typescript
import { pgTable, uuid, varchar, text, timestamp, index } from 'drizzle-orm/pg-core';
import { organizations } from './tenancy.js';
import { profiles } from './users.js';

// Event Logs - tamper-evident audit trail
export const eventLogs = pgTable(
  'event_logs',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    organizationId: uuid('organization_id')
      .references(() => organizations.id, { onDelete: 'cascade' })
      .notNull(),
    // Actor who triggered the event
    actorId: uuid('actor_id').references(() => profiles.id, {
      onDelete: 'set null',
    }),
    actorType: varchar('actor_type', { length: 32 }).notNull(), // 'user', 'system', 'api'
    // Event classification
    eventType: varchar('event_type', { length: 64 }).notNull(), // 'create', 'update', 'delete', 'login', etc.
    eventCategory: varchar('event_category', { length: 64 }), // 'auth', 'data', 'config', 'alert'
    // Entity affected
    entityType: varchar('entity_type', { length: 64 }).notNull(), // 'unit', 'site', 'alert_rule', etc.
    entityId: uuid('entity_id'),
    // Event details
    description: text('description'),
    payload: text('payload'), // JSON with event-specific data
    // Change tracking (for update events)
    oldValues: text('old_values'), // JSON of previous values
    newValues: text('new_values'), // JSON of new values
    // Request context
    ipAddress: varchar('ip_address', { length: 45 }), // IPv6 compatible
    userAgent: text('user_agent'),
    // Hash chain for tamper evidence
    previousHash: varchar('previous_hash', { length: 64 }),
    hash: varchar('hash', { length: 64 }).notNull(),
    // Timestamp
    occurredAt: timestamp('occurred_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    })
      .defaultNow()
      .notNull(),
  },
  (table) => [
    index('event_logs_org_idx').on(table.organizationId),
    index('event_logs_actor_idx').on(table.actorId),
    index('event_logs_type_idx').on(table.eventType),
    index('event_logs_entity_idx').on(table.entityType, table.entityId),
    index('event_logs_occurred_idx').on(table.occurredAt),
    // Composite for audit queries
    index('event_logs_org_date_idx').on(table.organizationId, table.occurredAt),
    // For hash chain verification
    index('event_logs_hash_idx').on(table.hash),
  ],
);

// Type exports
export type EventLog = typeof eventLogs.$inferSelect;
export type InsertEventLog = typeof eventLogs.$inferInsert;
```

  </action>
  <verify>
```bash
cd backend && grep -E "export (const|type)" src/db/schema/audit.ts | wc -l
```
Output should be 3 (1 table + 2 types).
  </verify>
  <done>eventLogs table with hash chain for tamper evidence</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Table count:**

```bash
grep -c "pgTable" backend/src/db/schema/alerts.ts backend/src/db/schema/notifications.ts backend/src/db/schema/audit.ts
```

Expected: alerts.ts: 4, notifications.ts: 1, audit.ts: 1

2. **Enum usage:**

```bash
grep -E "alertTypeEnum|alertSeverityEnum|alertStatusEnum|notificationChannelEnum|notificationStatusEnum" backend/src/db/schema/alerts.ts backend/src/db/schema/notifications.ts
```

Expected: Multiple matches showing enums are imported and used

3. **Foreign key relationships:**

```bash
grep "references" backend/src/db/schema/alerts.ts backend/src/db/schema/notifications.ts backend/src/db/schema/audit.ts | wc -l
```

Expected: Multiple references to organizations, sites, units, profiles, alerts

4. **Index coverage:**

```bash
grep -c "index(" backend/src/db/schema/alerts.ts backend/src/db/schema/notifications.ts backend/src/db/schema/audit.ts
```

Expected: Substantial index coverage for all tables
</verification>

<success_criteria>

- alertRules supports org/site/unit hierarchy
- alertRulesHistory tracks all rule changes
- alerts table has full lifecycle (triggered > acknowledged > resolved)
- correctiveActions links alerts to profiles with evidence
- notificationDeliveries tracks per-channel delivery status
- eventLogs provides hash-chained audit trail
- All tables have appropriate indexes
  </success_criteria>

<output>
After completion, create `.planning/phases/01-local-development-environment/01-04-SUMMARY.md`
</output>
