---
phase: 01-local-development-environment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/schema/enums.ts
  - backend/src/db/schema/tenancy.ts
  - backend/src/db/schema/users.ts
  - backend/src/db/schema/hierarchy.ts
autonomous: true

must_haves:
  truths:
    - "All 8 core enums are defined as pgEnum"
    - "organizations and subscriptions tables have foreign key relationship"
    - "profiles references auth user IDs via user_id column"
    - "sites, areas, units, hubs form a proper hierarchy with cascade deletes"
  artifacts:
    - path: "backend/src/db/schema/enums.ts"
      provides: "PostgreSQL enum definitions"
      contains: "pgEnum"
      exports: ["unitTypeEnum", "unitStatusEnum", "alertTypeEnum", "alertSeverityEnum", "alertStatusEnum", "appRoleEnum", "subscriptionPlanEnum", "subscriptionStatusEnum"]
    - path: "backend/src/db/schema/tenancy.ts"
      provides: "Organization and subscription tables"
      contains: "organizations"
      exports: ["organizations", "subscriptions"]
    - path: "backend/src/db/schema/users.ts"
      provides: "User profile and role tables"
      contains: "profiles"
      exports: ["profiles", "userRoles", "escalationContacts"]
    - path: "backend/src/db/schema/hierarchy.ts"
      provides: "Physical location hierarchy"
      contains: "sites"
      exports: ["sites", "areas", "units", "hubs"]
  key_links:
    - from: "backend/src/db/schema/tenancy.ts"
      to: "enums.ts"
      via: "import subscriptionPlanEnum, subscriptionStatusEnum"
      pattern: "from.*enums"
    - from: "backend/src/db/schema/hierarchy.ts"
      to: "enums.ts"
      via: "import unitTypeEnum, unitStatusEnum"
      pattern: "from.*enums"
    - from: "backend/src/db/schema/hierarchy.ts"
      to: "tenancy.ts"
      via: "sites references organizations"
      pattern: "references.*organizations"
---

<objective>
Define all PostgreSQL enums and foundation schemas (tenancy, users, hierarchy).

Purpose: These are the base tables that all other schemas depend on. Organizations own everything, users belong to organizations, and the physical hierarchy (sites > areas > units) forms the core monitoring structure.

Output: Four schema files with 8 enums and 9 tables that compile and can be imported by dependent schemas.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-local-development-environment/01-RESEARCH.md
@docs/SUPABASE_SCHEMA_INVENTORY.md

Key patterns from research:
- Use timestamp({ withTimezone: true, mode: 'date', precision: 3 }) for all timestamps
- Use uuid().primaryKey().defaultRandom() for IDs
- Use references() with { onDelete: 'cascade' } for parent-child relationships
- Define indexes on all foreign key columns
- Use $inferSelect and $inferInsert for type exports
- Create a reusable timestamps object for consistency
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create enum definitions</name>
  <files>backend/src/db/schema/enums.ts</files>
  <action>
Create all PostgreSQL enum definitions in a single file:

**backend/src/db/schema/enums.ts:**
```typescript
import { pgEnum } from 'drizzle-orm/pg-core';

// Unit Management
export const unitTypeEnum = pgEnum('unit_type', [
  'fridge',
  'freezer',
  'display_case',
  'walk_in_cooler',
  'walk_in_freezer',
  'blast_chiller',
]);

export const unitStatusEnum = pgEnum('unit_status', [
  'ok',
  'excursion',
  'alarm_active',
  'monitoring_interrupted',
  'manual_required',
  'restoring',
  'offline',
]);

// Alerting
export const alertTypeEnum = pgEnum('alert_type', [
  'alarm_active',
  'monitoring_interrupted',
  'missed_manual_entry',
  'low_battery',
  'sensor_fault',
  'door_open',
  'calibration_due',
]);

export const alertSeverityEnum = pgEnum('alert_severity', [
  'info',
  'warning',
  'critical',
]);

export const alertStatusEnum = pgEnum('alert_status', [
  'active',
  'acknowledged',
  'resolved',
  'escalated',
]);

// User Management
export const appRoleEnum = pgEnum('app_role', [
  'owner',
  'admin',
  'manager',
  'staff',
  'viewer',
]);

// Subscription/Billing
export const subscriptionPlanEnum = pgEnum('subscription_plan', [
  'starter',
  'pro',
  'haccp',
  'enterprise',
]);

export const subscriptionStatusEnum = pgEnum('subscription_status', [
  'trial',
  'active',
  'past_due',
  'canceled',
  'paused',
]);

// Notifications
export const notificationChannelEnum = pgEnum('notification_channel', [
  'push',
  'email',
  'sms',
]);

export const notificationStatusEnum = pgEnum('notification_status', [
  'pending',
  'sent',
  'delivered',
  'failed',
]);

// Device Management
export const deviceStatusEnum = pgEnum('device_status', [
  'active',
  'inactive',
  'pairing',
  'error',
]);

// Organization
export const complianceModeEnum = pgEnum('compliance_mode', [
  'standard',
  'haccp',
]);

// Pairing
export const pairingStatusEnum = pgEnum('pairing_status', [
  'pending',
  'completed',
  'failed',
  'expired',
]);
```
  </action>
  <verify>
```bash
cd backend && grep -c "pgEnum" src/db/schema/enums.ts
```
Output should be 13 (one pgEnum call per enum type).
  </verify>
  <done>All 13 enum types defined with correct values</done>
</task>

<task type="auto">
  <name>Task 2: Create tenancy schemas (organizations, subscriptions)</name>
  <files>backend/src/db/schema/tenancy.ts</files>
  <action>
Create the organization and subscription tables:

**backend/src/db/schema/tenancy.ts:**
```typescript
import {
  pgTable,
  uuid,
  varchar,
  text,
  integer,
  boolean,
  timestamp,
  index,
  uniqueIndex,
} from 'drizzle-orm/pg-core';
import {
  subscriptionPlanEnum,
  subscriptionStatusEnum,
  complianceModeEnum,
} from './enums.js';

// Reusable timestamp columns
const timestamps = {
  createdAt: timestamp('created_at', {
    mode: 'date',
    precision: 3,
    withTimezone: true,
  })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp('updated_at', {
    mode: 'date',
    precision: 3,
    withTimezone: true,
  })
    .defaultNow()
    .notNull()
    .$onUpdateFn(() => new Date()),
};

// Organizations - primary tenant boundary
export const organizations = pgTable(
  'organizations',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    name: varchar('name', { length: 256 }).notNull(),
    slug: varchar('slug', { length: 256 }).notNull(),
    timezone: varchar('timezone', { length: 100 }).notNull().default('UTC'),
    complianceMode: complianceModeEnum('compliance_mode')
      .notNull()
      .default('standard'),
    sensorLimit: integer('sensor_limit').notNull().default(10),
    logoUrl: text('logo_url'),
    ...timestamps,
  },
  (table) => [
    uniqueIndex('organizations_slug_idx').on(table.slug),
  ]
);

// Subscriptions - billing/plan management
export const subscriptions = pgTable(
  'subscriptions',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    organizationId: uuid('organization_id')
      .references(() => organizations.id, { onDelete: 'cascade' })
      .notNull(),
    plan: subscriptionPlanEnum('plan').notNull().default('starter'),
    status: subscriptionStatusEnum('status').notNull().default('trial'),
    stripeCustomerId: varchar('stripe_customer_id', { length: 256 }),
    stripeSubscriptionId: varchar('stripe_subscription_id', { length: 256 }),
    currentPeriodStart: timestamp('current_period_start', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    currentPeriodEnd: timestamp('current_period_end', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    trialEndsAt: timestamp('trial_ends_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    canceledAt: timestamp('canceled_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    ...timestamps,
  },
  (table) => [
    index('subscriptions_org_idx').on(table.organizationId),
    index('subscriptions_stripe_customer_idx').on(table.stripeCustomerId),
  ]
);

// Type exports
export type Organization = typeof organizations.$inferSelect;
export type InsertOrganization = typeof organizations.$inferInsert;
export type Subscription = typeof subscriptions.$inferSelect;
export type InsertSubscription = typeof subscriptions.$inferInsert;
```
  </action>
  <verify>
```bash
cd backend && grep -E "export (const|type)" src/db/schema/tenancy.ts | wc -l
```
Output should be 6 (2 tables + 4 types).
  </verify>
  <done>organizations and subscriptions tables with proper types and indexes</done>
</task>

<task type="auto">
  <name>Task 3: Create user schemas (profiles, user_roles, escalation_contacts)</name>
  <files>backend/src/db/schema/users.ts</files>
  <action>
Create the user management tables:

**backend/src/db/schema/users.ts:**
```typescript
import {
  pgTable,
  uuid,
  varchar,
  text,
  integer,
  boolean,
  timestamp,
  index,
  uniqueIndex,
} from 'drizzle-orm/pg-core';
import { appRoleEnum } from './enums.js';
import { organizations } from './tenancy.js';

// Reusable timestamp columns
const timestamps = {
  createdAt: timestamp('created_at', {
    mode: 'date',
    precision: 3,
    withTimezone: true,
  })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp('updated_at', {
    mode: 'date',
    precision: 3,
    withTimezone: true,
  })
    .defaultNow()
    .notNull()
    .$onUpdateFn(() => new Date()),
};

// Profiles - user profile data linked to auth.users
export const profiles = pgTable(
  'profiles',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    // References external auth provider (Stack Auth user ID)
    userId: uuid('user_id').notNull(),
    organizationId: uuid('organization_id')
      .references(() => organizations.id, { onDelete: 'cascade' })
      .notNull(),
    email: varchar('email', { length: 256 }).notNull(),
    fullName: varchar('full_name', { length: 256 }),
    avatarUrl: text('avatar_url'),
    phone: varchar('phone', { length: 50 }),
    phoneVerified: boolean('phone_verified').notNull().default(false),
    pushEnabled: boolean('push_enabled').notNull().default(true),
    emailEnabled: boolean('email_enabled').notNull().default(true),
    smsEnabled: boolean('sms_enabled').notNull().default(false),
    ...timestamps,
  },
  (table) => [
    uniqueIndex('profiles_user_id_idx').on(table.userId),
    index('profiles_org_idx').on(table.organizationId),
    index('profiles_email_idx').on(table.email),
  ]
);

// User Roles - role assignments per organization
export const userRoles = pgTable(
  'user_roles',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    userId: uuid('user_id').notNull(),
    organizationId: uuid('organization_id')
      .references(() => organizations.id, { onDelete: 'cascade' })
      .notNull(),
    role: appRoleEnum('role').notNull().default('viewer'),
    ...timestamps,
  },
  (table) => [
    // Unique constraint: one role per user per org
    uniqueIndex('user_roles_user_org_idx').on(table.userId, table.organizationId),
    index('user_roles_org_idx').on(table.organizationId),
  ]
);

// Escalation Contacts - alert notification recipients
export const escalationContacts = pgTable(
  'escalation_contacts',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    organizationId: uuid('organization_id')
      .references(() => organizations.id, { onDelete: 'cascade' })
      .notNull(),
    profileId: uuid('profile_id')
      .references(() => profiles.id, { onDelete: 'cascade' }),
    name: varchar('name', { length: 256 }).notNull(),
    phone: varchar('phone', { length: 50 }).notNull(),
    email: varchar('email', { length: 256 }),
    priority: integer('priority').notNull().default(0),
    isActive: boolean('is_active').notNull().default(true),
    ...timestamps,
  },
  (table) => [
    index('escalation_contacts_org_idx').on(table.organizationId),
    index('escalation_contacts_profile_idx').on(table.profileId),
    index('escalation_contacts_priority_idx').on(
      table.organizationId,
      table.priority
    ),
  ]
);

// Type exports
export type Profile = typeof profiles.$inferSelect;
export type InsertProfile = typeof profiles.$inferInsert;
export type UserRole = typeof userRoles.$inferSelect;
export type InsertUserRole = typeof userRoles.$inferInsert;
export type EscalationContact = typeof escalationContacts.$inferSelect;
export type InsertEscalationContact = typeof escalationContacts.$inferInsert;
```
  </action>
  <verify>
```bash
cd backend && grep -E "export (const|type)" src/db/schema/users.ts | wc -l
```
Output should be 9 (3 tables + 6 types).
  </verify>
  <done>profiles, userRoles, escalationContacts tables with proper relationships</done>
</task>

<task type="auto">
  <name>Task 4: Create hierarchy schemas (sites, areas, units, hubs)</name>
  <files>backend/src/db/schema/hierarchy.ts</files>
  <action>
Create the physical location hierarchy tables:

**backend/src/db/schema/hierarchy.ts:**
```typescript
import {
  pgTable,
  uuid,
  varchar,
  text,
  integer,
  boolean,
  timestamp,
  index,
  uniqueIndex,
} from 'drizzle-orm/pg-core';
import { unitTypeEnum, unitStatusEnum } from './enums.js';
import { organizations } from './tenancy.js';

// Reusable timestamp columns
const timestamps = {
  createdAt: timestamp('created_at', {
    mode: 'date',
    precision: 3,
    withTimezone: true,
  })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp('updated_at', {
    mode: 'date',
    precision: 3,
    withTimezone: true,
  })
    .defaultNow()
    .notNull()
    .$onUpdateFn(() => new Date()),
};

// Sites - physical locations (top of hierarchy)
export const sites = pgTable(
  'sites',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    organizationId: uuid('organization_id')
      .references(() => organizations.id, { onDelete: 'cascade' })
      .notNull(),
    name: varchar('name', { length: 256 }).notNull(),
    address: text('address'),
    city: varchar('city', { length: 128 }),
    state: varchar('state', { length: 64 }),
    postalCode: varchar('postal_code', { length: 20 }),
    country: varchar('country', { length: 64 }),
    timezone: varchar('timezone', { length: 100 }).notNull().default('UTC'),
    latitude: varchar('latitude', { length: 32 }),
    longitude: varchar('longitude', { length: 32 }),
    isActive: boolean('is_active').notNull().default(true),
    ...timestamps,
  },
  (table) => [
    index('sites_org_idx').on(table.organizationId),
    index('sites_active_idx').on(table.organizationId, table.isActive),
  ]
);

// Areas - subdivisions within a site
export const areas = pgTable(
  'areas',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    siteId: uuid('site_id')
      .references(() => sites.id, { onDelete: 'cascade' })
      .notNull(),
    name: varchar('name', { length: 256 }).notNull(),
    description: text('description'),
    sortOrder: integer('sort_order').notNull().default(0),
    isActive: boolean('is_active').notNull().default(true),
    ...timestamps,
  },
  (table) => [
    index('areas_site_idx').on(table.siteId),
    index('areas_sort_idx').on(table.siteId, table.sortOrder),
  ]
);

// Units - refrigeration equipment (core monitoring entity)
export const units = pgTable(
  'units',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    areaId: uuid('area_id')
      .references(() => areas.id, { onDelete: 'cascade' })
      .notNull(),
    name: varchar('name', { length: 256 }).notNull(),
    unitType: unitTypeEnum('unit_type').notNull(),
    status: unitStatusEnum('status').notNull().default('ok'),
    tempMin: integer('temp_min').notNull(),
    tempMax: integer('temp_max').notNull(),
    tempUnit: varchar('temp_unit', { length: 1 }).notNull().default('F'),
    manualMonitoringRequired: boolean('manual_monitoring_required')
      .notNull()
      .default(false),
    manualMonitoringInterval: integer('manual_monitoring_interval'), // minutes
    lastReadingAt: timestamp('last_reading_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    lastTemperature: integer('last_temperature'),
    isActive: boolean('is_active').notNull().default(true),
    sortOrder: integer('sort_order').notNull().default(0),
    ...timestamps,
  },
  (table) => [
    index('units_area_idx').on(table.areaId),
    index('units_status_idx').on(table.status),
    index('units_type_idx').on(table.unitType),
    index('units_active_idx').on(table.areaId, table.isActive),
  ]
);

// Hubs - network aggregators for BLE sensors
export const hubs = pgTable(
  'hubs',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    siteId: uuid('site_id')
      .references(() => sites.id, { onDelete: 'cascade' })
      .notNull(),
    name: varchar('name', { length: 256 }).notNull(),
    macAddress: varchar('mac_address', { length: 17 }), // XX:XX:XX:XX:XX:XX
    firmwareVersion: varchar('firmware_version', { length: 32 }),
    lastSeenAt: timestamp('last_seen_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    isOnline: boolean('is_online').notNull().default(false),
    isActive: boolean('is_active').notNull().default(true),
    ...timestamps,
  },
  (table) => [
    index('hubs_site_idx').on(table.siteId),
    uniqueIndex('hubs_mac_idx').on(table.macAddress),
  ]
);

// Type exports
export type Site = typeof sites.$inferSelect;
export type InsertSite = typeof sites.$inferInsert;
export type Area = typeof areas.$inferSelect;
export type InsertArea = typeof areas.$inferInsert;
export type Unit = typeof units.$inferSelect;
export type InsertUnit = typeof units.$inferInsert;
export type Hub = typeof hubs.$inferSelect;
export type InsertHub = typeof hubs.$inferInsert;
```
  </action>
  <verify>
```bash
cd backend && grep -E "export (const|type)" src/db/schema/hierarchy.ts | wc -l
```
Output should be 12 (4 tables + 8 types).
  </verify>
  <done>sites, areas, units, hubs tables with cascade relationships and indexes</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **File structure check:**
```bash
ls -la backend/src/db/schema/
```
Expected: enums.ts, tenancy.ts, users.ts, hierarchy.ts, index.ts

2. **Enum count:**
```bash
grep -c "pgEnum" backend/src/db/schema/enums.ts
```
Expected: 13

3. **Table count:**
```bash
grep -c "pgTable" backend/src/db/schema/*.ts
```
Expected: 9 (2 tenancy + 3 users + 4 hierarchy)

4. **Import chain verification:**
```bash
grep "from.*enums" backend/src/db/schema/tenancy.ts backend/src/db/schema/hierarchy.ts
```
Expected: Both files import from enums.ts
</verification>

<success_criteria>
- All 13 enum types defined in enums.ts
- organizations and subscriptions tables created with FK relationship
- profiles, userRoles, escalationContacts tables created
- sites > areas > units hierarchy with cascade deletes
- hubs table with site relationship
- All foreign keys have indexes
- Type exports for all tables ($inferSelect and $inferInsert)
</success_criteria>

<output>
After completion, create `.planning/phases/01-local-development-environment/01-02-SUMMARY.md`
</output>
