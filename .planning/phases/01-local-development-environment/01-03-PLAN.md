---
phase: 01-local-development-environment
plan: 03
type: execute
wave: 2
depends_on: ['01-02']
files_modified:
  - backend/src/db/schema/devices.ts
  - backend/src/db/schema/telemetry.ts
autonomous: true

must_haves:
  truths:
    - 'devices table references units and hubs'
    - 'lora_sensors table references devices'
    - 'sensor_readings is indexed for time-series queries (unit + timestamp)'
    - 'manual_temperature_logs links readings to users'
  artifacts:
    - path: 'backend/src/db/schema/devices.ts'
      provides: 'Device and sensor tables'
      contains: 'devices'
      exports: ['devices', 'loraSensors', 'calibrationRecords']
    - path: 'backend/src/db/schema/telemetry.ts'
      provides: 'Time-series data tables'
      contains: 'sensorReadings'
      exports: ['sensorReadings', 'manualTemperatureLogs', 'doorEvents']
  key_links:
    - from: 'backend/src/db/schema/devices.ts'
      to: 'hierarchy.ts'
      via: 'devices references units and hubs'
      pattern: 'references.*units|hubs'
    - from: 'backend/src/db/schema/telemetry.ts'
      to: 'hierarchy.ts'
      via: 'sensorReadings references units'
      pattern: 'references.*units'
    - from: 'backend/src/db/schema/telemetry.ts'
      to: 'devices.ts'
      via: 'sensorReadings references devices'
      pattern: 'references.*devices'
---

<objective>
Define device management and telemetry schemas.

Purpose: These tables store sensor hardware information and the high-volume time-series temperature data that is the core of the monitoring system.

Output: Two schema files with 6 tables covering devices, sensors, calibration, readings, manual logs, and door events.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-local-development-environment/01-RESEARCH.md
@docs/SUPABASE_SCHEMA_INVENTORY.md

Key patterns:

- sensor_readings is high volume (~100K rows) - optimize indexes for time-series queries
- Use numeric for temperature/humidity (precision: 5, scale: 2)
- recordedAt is the critical timestamp for telemetry
- Composite index on (unitId, recordedAt DESC) for efficient range queries
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Create device schemas (devices, lora_sensors, calibration_records)</name>
  <files>backend/src/db/schema/devices.ts</files>
  <action>
Create the device management tables:

**backend/src/db/schema/devices.ts:**

```typescript
import {
  pgTable,
  uuid,
  varchar,
  text,
  integer,
  boolean,
  timestamp,
  index,
  uniqueIndex,
} from 'drizzle-orm/pg-core';
import { deviceStatusEnum, pairingStatusEnum } from './enums.js';
import { units, hubs } from './hierarchy.js';

// Reusable timestamp columns
const timestamps = {
  createdAt: timestamp('created_at', {
    mode: 'date',
    precision: 3,
    withTimezone: true,
  })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp('updated_at', {
    mode: 'date',
    precision: 3,
    withTimezone: true,
  })
    .defaultNow()
    .notNull()
    .$onUpdateFn(() => new Date()),
};

// Devices - physical sensors
export const devices = pgTable(
  'devices',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    unitId: uuid('unit_id').references(() => units.id, { onDelete: 'set null' }),
    hubId: uuid('hub_id').references(() => hubs.id, { onDelete: 'set null' }),
    deviceEui: varchar('device_eui', { length: 32 }).notNull(),
    name: varchar('name', { length: 256 }),
    deviceType: varchar('device_type', { length: 64 }), // e.g., 'lora', 'ble', 'wifi'
    status: deviceStatusEnum('status').notNull().default('inactive'),
    battery: integer('battery'), // percentage 0-100
    signalStrength: integer('signal_strength'), // RSSI or similar
    firmwareVersion: varchar('firmware_version', { length: 32 }),
    lastSeenAt: timestamp('last_seen_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    isActive: boolean('is_active').notNull().default(true),
    ...timestamps,
  },
  (table) => [
    uniqueIndex('devices_eui_idx').on(table.deviceEui),
    index('devices_unit_idx').on(table.unitId),
    index('devices_hub_idx').on(table.hubId),
    index('devices_status_idx').on(table.status),
  ],
);

// LoRa Sensors - LoRaWAN-specific configuration
export const loraSensors = pgTable(
  'lora_sensors',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    deviceId: uuid('device_id')
      .references(() => devices.id, { onDelete: 'cascade' })
      .notNull(),
    appEui: varchar('app_eui', { length: 32 }).notNull(),
    devEui: varchar('dev_eui', { length: 32 }).notNull(),
    appKey: varchar('app_key', { length: 64 }), // encrypted in production
    joinEui: varchar('join_eui', { length: 32 }),
    networkServerId: varchar('network_server_id', { length: 128 }), // TTN app ID
    activationType: varchar('activation_type', { length: 16 }).default('OTAA'), // OTAA or ABP
    lastJoinAt: timestamp('last_join_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    ...timestamps,
  },
  (table) => [
    uniqueIndex('lora_sensors_device_idx').on(table.deviceId),
    uniqueIndex('lora_sensors_dev_eui_idx').on(table.devEui),
    index('lora_sensors_app_eui_idx').on(table.appEui),
  ],
);

// Calibration Records - calibration history for compliance
export const calibrationRecords = pgTable(
  'calibration_records',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    deviceId: uuid('device_id')
      .references(() => devices.id, { onDelete: 'cascade' })
      .notNull(),
    calibratedAt: timestamp('calibrated_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }).notNull(),
    calibratedBy: uuid('calibrated_by'), // profile_id of person who calibrated
    temperatureOffset: integer('temperature_offset'), // offset in 0.01 degrees
    humidityOffset: integer('humidity_offset'), // offset in 0.01 percent
    referenceTemperature: integer('reference_temperature'), // calibration reference
    certificateUrl: text('certificate_url'),
    notes: text('notes'),
    expiresAt: timestamp('expires_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    ...timestamps,
  },
  (table) => [
    index('calibration_records_device_idx').on(table.deviceId),
    index('calibration_records_date_idx').on(table.deviceId, table.calibratedAt),
    index('calibration_records_expires_idx').on(table.expiresAt),
  ],
);

// Pairing Sessions - temporary device pairing state
export const pairingSessions = pgTable(
  'pairing_sessions',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    deviceId: uuid('device_id').references(() => devices.id, {
      onDelete: 'cascade',
    }),
    status: pairingStatusEnum('status').notNull().default('pending'),
    pairingCode: varchar('pairing_code', { length: 16 }),
    startedAt: timestamp('started_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    })
      .defaultNow()
      .notNull(),
    completedAt: timestamp('completed_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }),
    expiresAt: timestamp('expires_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }).notNull(),
    metadata: text('metadata'), // JSON for additional pairing data
    ...timestamps,
  },
  (table) => [
    index('pairing_sessions_device_idx').on(table.deviceId),
    index('pairing_sessions_status_idx').on(table.status),
    index('pairing_sessions_code_idx').on(table.pairingCode),
  ],
);

// Type exports
export type Device = typeof devices.$inferSelect;
export type InsertDevice = typeof devices.$inferInsert;
export type LoraSensor = typeof loraSensors.$inferSelect;
export type InsertLoraSensor = typeof loraSensors.$inferInsert;
export type CalibrationRecord = typeof calibrationRecords.$inferSelect;
export type InsertCalibrationRecord = typeof calibrationRecords.$inferInsert;
export type PairingSession = typeof pairingSessions.$inferSelect;
export type InsertPairingSession = typeof pairingSessions.$inferInsert;
```

  </action>
  <verify>
```bash
cd backend && grep -E "export (const|type)" src/db/schema/devices.ts | wc -l
```
Output should be 12 (4 tables + 8 types).
  </verify>
  <done>devices, loraSensors, calibrationRecords, pairingSessions tables created</done>
</task>

<task type="auto">
  <name>Task 2: Create telemetry schemas (sensor_readings, manual_temperature_logs, door_events)</name>
  <files>backend/src/db/schema/telemetry.ts</files>
  <action>
Create the time-series telemetry tables:

**backend/src/db/schema/telemetry.ts:**

```typescript
import {
  pgTable,
  uuid,
  varchar,
  text,
  integer,
  boolean,
  timestamp,
  numeric,
  index,
} from 'drizzle-orm/pg-core';
import { units } from './hierarchy.js';
import { devices } from './devices.js';
import { profiles } from './users.js';

// Sensor Readings - high-volume time-series temperature data
export const sensorReadings = pgTable(
  'sensor_readings',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    unitId: uuid('unit_id')
      .references(() => units.id, { onDelete: 'cascade' })
      .notNull(),
    deviceId: uuid('device_id').references(() => devices.id, {
      onDelete: 'set null',
    }),
    // Temperature in device units (typically Celsius * 100 for precision)
    temperature: numeric('temperature', { precision: 7, scale: 2 }).notNull(),
    humidity: numeric('humidity', { precision: 5, scale: 2 }),
    battery: integer('battery'), // percentage 0-100 at time of reading
    signalStrength: integer('signal_strength'), // RSSI at time of reading
    // Raw payload for debugging/audit
    rawPayload: text('raw_payload'),
    // Timestamp from device (may differ from received time)
    recordedAt: timestamp('recorded_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }).notNull(),
    // Timestamp when server received the reading
    receivedAt: timestamp('received_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    })
      .defaultNow()
      .notNull(),
    // Source of reading for troubleshooting
    source: varchar('source', { length: 32 }), // 'ttn', 'manual', 'api', etc.
  },
  (table) => [
    // Primary index for time-series queries: readings for a unit in time order
    index('sensor_readings_unit_time_idx').on(table.unitId, table.recordedAt),
    // Index for device-specific queries
    index('sensor_readings_device_idx').on(table.deviceId),
    // Index for recent readings queries (last 24h, 7d, etc.)
    index('sensor_readings_recorded_idx').on(table.recordedAt),
  ],
);

// Manual Temperature Logs - user-entered readings
export const manualTemperatureLogs = pgTable(
  'manual_temperature_logs',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    unitId: uuid('unit_id')
      .references(() => units.id, { onDelete: 'cascade' })
      .notNull(),
    profileId: uuid('profile_id').references(() => profiles.id, { onDelete: 'set null' }),
    temperature: numeric('temperature', { precision: 7, scale: 2 }).notNull(),
    humidity: numeric('humidity', { precision: 5, scale: 2 }),
    notes: text('notes'),
    photoUrl: text('photo_url'), // evidence photo for compliance
    // When the reading was taken (user-reported time)
    recordedAt: timestamp('recorded_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }).notNull(),
    // When the log was submitted
    createdAt: timestamp('created_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    })
      .defaultNow()
      .notNull(),
  },
  (table) => [
    index('manual_logs_unit_time_idx').on(table.unitId, table.recordedAt),
    index('manual_logs_profile_idx').on(table.profileId),
    index('manual_logs_recorded_idx').on(table.recordedAt),
  ],
);

// Door Events - door sensor history
export const doorEvents = pgTable(
  'door_events',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    unitId: uuid('unit_id')
      .references(() => units.id, { onDelete: 'cascade' })
      .notNull(),
    deviceId: uuid('device_id').references(() => devices.id, {
      onDelete: 'set null',
    }),
    state: varchar('state', { length: 16 }).notNull(), // 'open', 'closed'
    // Timestamp of state change
    timestamp: timestamp('timestamp', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    }).notNull(),
    // Duration door was in previous state (computed on close)
    durationSeconds: integer('duration_seconds'),
    // When record was created
    createdAt: timestamp('created_at', {
      mode: 'date',
      precision: 3,
      withTimezone: true,
    })
      .defaultNow()
      .notNull(),
  },
  (table) => [
    index('door_events_unit_time_idx').on(table.unitId, table.timestamp),
    index('door_events_device_idx').on(table.deviceId),
    index('door_events_timestamp_idx').on(table.timestamp),
  ],
);

// Type exports
export type SensorReading = typeof sensorReadings.$inferSelect;
export type InsertSensorReading = typeof sensorReadings.$inferInsert;
export type ManualTemperatureLog = typeof manualTemperatureLogs.$inferSelect;
export type InsertManualTemperatureLog = typeof manualTemperatureLogs.$inferInsert;
export type DoorEvent = typeof doorEvents.$inferSelect;
export type InsertDoorEvent = typeof doorEvents.$inferInsert;
```

  </action>
  <verify>
```bash
cd backend && grep -E "export (const|type)" src/db/schema/telemetry.ts | wc -l
```
Output should be 9 (3 tables + 6 types).
  </verify>
  <done>sensorReadings, manualTemperatureLogs, doorEvents tables with time-series indexes</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Table count:**

```bash
grep -c "pgTable" backend/src/db/schema/devices.ts backend/src/db/schema/telemetry.ts
```

Expected: devices.ts: 4, telemetry.ts: 3

2. **Index verification (time-series critical):**

```bash
grep "unit_time_idx" backend/src/db/schema/telemetry.ts
```

Expected: Found in both sensorReadings and manualTemperatureLogs

3. **Foreign key relationships:**

```bash
grep "references" backend/src/db/schema/devices.ts backend/src/db/schema/telemetry.ts | wc -l
```

Expected: Multiple references to units, hubs, devices, profiles

4. **Numeric precision for temperature:**

```bash
grep "precision.*7.*scale.*2" backend/src/db/schema/telemetry.ts
```

Expected: Found for temperature columns
</verification>

<success_criteria>

- devices table links to units and hubs
- loraSensors table has unique device reference
- calibrationRecords tracks calibration history
- pairingSessions handles device pairing workflow
- sensorReadings has composite index on (unitId, recordedAt)
- manualTemperatureLogs links to profiles for attribution
- doorEvents tracks door state changes
- All tables use numeric type for temperature/humidity precision
  </success_criteria>

<output>
After completion, create `.planning/phases/01-local-development-environment/01-03-SUMMARY.md`
</output>
