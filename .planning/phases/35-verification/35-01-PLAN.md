---
phase: 35-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/lib/verify-lib.sh
autonomous: true

must_haves:
  truths:
    - "verify_endpoint_health can check worker health endpoint"
    - "verify_monitoring_stack validates Prometheus and Grafana accessibility"
    - "verify_all_services checks backend, frontend, and worker in one call"
  artifacts:
    - path: "scripts/lib/verify-lib.sh"
      provides: "Extended verification functions"
      contains: "verify_monitoring_stack"
  key_links:
    - from: "scripts/lib/verify-lib.sh"
      to: "verify-deployment.sh"
      via: "source import"
      pattern: "source.*verify-lib.sh"
---

<objective>
Extend verify-lib.sh with functions to validate all service endpoints including workers and monitoring stack.

Purpose: VERIFY-01 requires checking ALL service health endpoints (backend, frontend, workers). VERIFY-05 requires Prometheus/Grafana validation. Currently verify-lib.sh only checks backend and frontend.

Output: Extended verify-lib.sh with verify_monitoring_stack() and verify_all_services() functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@scripts/lib/verify-lib.sh
@scripts/lib/deploy-lib.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add verify_monitoring_stack function</name>
  <files>scripts/lib/verify-lib.sh</files>
  <action>
Add verify_monitoring_stack() function to verify-lib.sh that checks:
1. Prometheus endpoint (https://{domain}/prometheus/-/healthy) returns 200
2. Grafana endpoint (https://{domain}/grafana/api/health) returns 200

Use existing verify_endpoint_health() for each check. Return 0 only if both pass.

Pattern:
```bash
verify_monitoring_stack() {
    local domain="$1"
    local failed=0

    step "Verifying monitoring stack..."

    # Prometheus health check
    if ! verify_endpoint_health "Prometheus" "https://${domain}/prometheus/-/healthy"; then
        failed=1
    fi

    # Grafana health check
    if ! verify_endpoint_health "Grafana" "https://${domain}/grafana/api/health"; then
        failed=1
    fi

    if [[ $failed -eq 0 ]]; then
        success "Monitoring stack healthy"
        return 0
    else
        return 1
    fi
}
```

Add after verify_ssl_cert() function (around line 120).
  </action>
  <verify>grep -q "verify_monitoring_stack" scripts/lib/verify-lib.sh && echo "Function exists"</verify>
  <done>verify_monitoring_stack() function exists in verify-lib.sh and checks both Prometheus and Grafana</done>
</task>

<task type="auto">
  <name>Task 2: Add verify_all_services function</name>
  <files>scripts/lib/verify-lib.sh</files>
  <action>
Add verify_all_services() function that performs comprehensive service verification:
1. Backend API health (https://{domain}/api/health)
2. Frontend accessibility (https://{domain})
3. Worker health (https://{domain}/api/worker/health) - new endpoint check

Also add verify_worker_health() as a standalone function for the worker check.

Pattern:
```bash
# VERIFY-01: Validate worker health endpoint
verify_worker_health() {
    local domain="$1"
    verify_endpoint_health "Worker" "https://${domain}/api/worker/health"
}

# VERIFY-01: Validate all service health endpoints
verify_all_services() {
    local domain="$1"
    local failed=0

    step "Verifying all service endpoints..."

    # Backend health
    if ! verify_endpoint_health "Backend API" "https://${domain}/api/health"; then
        failed=1
    fi

    # Frontend accessibility
    if ! verify_endpoint_health "Frontend" "https://${domain}"; then
        failed=1
    fi

    # Worker health (optional - may not exist in all deployments)
    if ! verify_endpoint_health "Worker" "https://${domain}/api/worker/health"; then
        warning "Worker health check failed (may not be exposed externally)"
        # Don't fail on worker - it may be internal only
    fi

    if [[ $failed -eq 0 ]]; then
        success "All core services healthy"
        return 0
    else
        error "One or more core services unhealthy"
        return 1
    fi
}
```

Note: Worker endpoint may return 404 if not exposed via Caddy. Make this a warning, not failure.
  </action>
  <verify>grep -q "verify_all_services" scripts/lib/verify-lib.sh && grep -q "verify_worker_health" scripts/lib/verify-lib.sh && echo "Functions exist"</verify>
  <done>verify_all_services() and verify_worker_health() functions exist in verify-lib.sh</done>
</task>

<task type="auto">
  <name>Task 3: Add verify_consecutive_health function</name>
  <files>scripts/lib/verify-lib.sh</files>
  <action>
Add verify_consecutive_health() function that wraps verify_endpoint_health with 3-consecutive-pass requirement. This imports the pattern from deploy-lib.sh but adapts it for verification context (external URLs, not localhost).

Pattern:
```bash
# VERIFY-06: Wait for 3 consecutive health check passes
# Args: $1 = name, $2 = URL
# Uses verify_endpoint_health but requires VERIFY_CONSECUTIVE_REQUIRED consecutive passes
VERIFY_CONSECUTIVE_REQUIRED="${VERIFY_CONSECUTIVE_REQUIRED:-3}"
VERIFY_CHECK_INTERVAL="${VERIFY_CHECK_INTERVAL:-5}"
VERIFY_MAX_ATTEMPTS="${VERIFY_MAX_ATTEMPTS:-12}"

verify_consecutive_health() {
    local name="$1"
    local url="$2"
    local consecutive_passes=0
    local total_attempts=0

    step "Verifying $name with ${VERIFY_CONSECUTIVE_REQUIRED} consecutive passes..."

    while [[ $total_attempts -lt $VERIFY_MAX_ATTEMPTS ]]; do
        total_attempts=$((total_attempts + 1))

        local http_code
        http_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 "$url" 2>/dev/null || echo "000")

        if [[ "$http_code" == "200" ]]; then
            consecutive_passes=$((consecutive_passes + 1))
            echo -e "  [${GREEN}PASS${NC}] Attempt $total_attempts: consecutive $consecutive_passes/$VERIFY_CONSECUTIVE_REQUIRED"

            if [[ $consecutive_passes -ge $VERIFY_CONSECUTIVE_REQUIRED ]]; then
                success "$name verified ($consecutive_passes consecutive passes)"
                return 0
            fi
        else
            if [[ $consecutive_passes -gt 0 ]]; then
                warning "Streak reset (was $consecutive_passes)"
            fi
            consecutive_passes=0
            echo -e "  [${RED}FAIL${NC}] Attempt $total_attempts: HTTP $http_code"
        fi

        sleep "$VERIFY_CHECK_INTERVAL"
    done

    error "$name failed to achieve $VERIFY_CONSECUTIVE_REQUIRED consecutive passes"
    return 1
}
```

Add configuration variables at the top of the file (after color definitions).
  </action>
  <verify>grep -q "verify_consecutive_health" scripts/lib/verify-lib.sh && grep -q "VERIFY_CONSECUTIVE_REQUIRED" scripts/lib/verify-lib.sh && echo "Function and config exist"</verify>
  <done>verify_consecutive_health() function exists with configurable consecutive pass requirement</done>
</task>

</tasks>

<verification>
Run library self-test to confirm new functions:
```bash
# Check all functions exist
grep -E "^(verify_monitoring_stack|verify_all_services|verify_worker_health|verify_consecutive_health)\(\)" scripts/lib/verify-lib.sh

# Source and verify functions are callable
source scripts/lib/verify-lib.sh && type verify_monitoring_stack && type verify_all_services && type verify_consecutive_health
```
</verification>

<success_criteria>
1. verify_monitoring_stack() function checks Prometheus and Grafana
2. verify_all_services() function checks backend, frontend, and worker
3. verify_consecutive_health() function implements 3-consecutive-pass pattern
4. All functions use existing verify_endpoint_health() for consistency
5. Library sources without errors
</success_criteria>

<output>
After completion, create `.planning/phases/35-verification/35-01-SUMMARY.md`
</output>
