---
phase: 39-dashboard-widgets
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/routers/readings.router.ts
  - src/features/dashboard-layout/widgets/AnnotationsWidget.tsx
  - src/features/dashboard-layout/widgets/EventTimelineWidget.tsx
autonomous: true

must_haves:
  truths:
    - 'AnnotationsWidget renders annotations from tRPC without supabase'
    - 'AnnotationsWidget can create and delete annotations via tRPC mutations'
    - 'EventTimelineWidget renders timeline events from tRPC without supabase'
    - 'Dashboard loads showing both widgets without errors'
  artifacts:
    - path: 'backend/src/routers/readings.router.ts'
      provides: 'eventLogs procedures for annotations'
      contains: 'listEventLogs|createEventLog|deleteEventLog'
    - path: 'src/features/dashboard-layout/widgets/AnnotationsWidget.tsx'
      provides: 'Annotations widget using tRPC'
      contains: 'useTRPC'
    - path: 'src/features/dashboard-layout/widgets/EventTimelineWidget.tsx'
      provides: 'Event timeline using tRPC'
      contains: 'useTRPC'
  key_links:
    - from: 'src/features/dashboard-layout/widgets/AnnotationsWidget.tsx'
      to: 'trpc.readings.listEventLogs'
      via: 'queryOptions'
      pattern: "trpc\\.readings\\.(listEventLogs|createEventLog|deleteEventLog)"
    - from: 'src/features/dashboard-layout/widgets/EventTimelineWidget.tsx'
      to: 'trpc.alerts.list'
      via: 'queryOptions'
      pattern: "trpc\\.(alerts|readings)\\.list"
---

<objective>
Migrate 2 complex dashboard widgets from supabase to tRPC, adding backend procedures as needed.

Purpose: AnnotationsWidget has mutations (create/delete), EventTimelineWidget combines multiple entity types. These require new backend procedures for event_logs.

Output: 2 widgets using tRPC hooks, plus new backend procedures for event logs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-test-infrastructure/38-01-SUMMARY.md (tRPC mock patterns)
@src/hooks/useSites.ts (tRPC hook pattern reference)
@backend/src/routers/readings.router.ts (add event log procedures here)
@backend/src/routers/alerts.router.ts (available alert procedures)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add event log tRPC procedures to backend</name>
  <files>backend/src/routers/readings.router.ts</files>
  <action>
Add procedures for event_logs needed by AnnotationsWidget. Add to the existing readings router since it already handles manual logs and door events.

Add 3 new procedures:

```typescript
/**
 * List event logs (annotations) for a unit
 */
listEventLogs: orgProcedure
  .input(z.object({
    organizationId: z.string().uuid(),
    unitId: z.string().uuid(),
    eventTypes: z.array(z.string()).optional(),
    limit: z.number().int().min(1).max(100).optional(),
  }))
  .query(async ({ ctx, input }) => {
    const limit = input.limit ?? 20;
    const eventTypes = input.eventTypes ?? ['note_added', 'comment', 'shift_handoff', 'annotation'];

    // Query event_logs with optional profile join
    const logs = await ctx.db
      .select({
        id: eventLogs.id,
        title: eventLogs.title,
        eventData: eventLogs.eventData,
        recordedAt: eventLogs.recordedAt,
        actorId: eventLogs.actorId,
        authorName: profiles.fullName,
        authorEmail: profiles.email,
      })
      .from(eventLogs)
      .leftJoin(profiles, eq(eventLogs.actorId, profiles.userId))
      .where(
        and(
          eq(eventLogs.unitId, input.unitId),
          eq(eventLogs.organizationId, ctx.user.organizationId),
          inArray(eventLogs.eventType, eventTypes)
        )
      )
      .orderBy(desc(eventLogs.recordedAt))
      .limit(limit);

    return logs;
  }),

/**
 * Create an event log (annotation)
 */
createEventLog: orgProcedure
  .input(z.object({
    organizationId: z.string().uuid(),
    unitId: z.string().uuid(),
    eventType: z.string(),
    eventData: z.record(z.any()),
    title: z.string().optional(),
  }))
  .mutation(async ({ ctx, input }) => {
    const [log] = await ctx.db
      .insert(eventLogs)
      .values({
        organizationId: ctx.user.organizationId,
        unitId: input.unitId,
        eventType: input.eventType,
        eventData: input.eventData,
        title: input.title,
        actorId: ctx.user.profileId,
        recordedAt: new Date(),
      })
      .returning();

    return log;
  }),

/**
 * Delete an event log (annotation)
 */
deleteEventLog: orgProcedure
  .input(z.object({
    organizationId: z.string().uuid(),
    eventLogId: z.string().uuid(),
  }))
  .mutation(async ({ ctx, input }) => {
    // Role check - only managers and above can delete
    if (!['manager', 'admin', 'owner'].includes(ctx.user.role)) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: 'Only managers, admins, and owners can delete annotations',
      });
    }

    await ctx.db
      .delete(eventLogs)
      .where(
        and(
          eq(eventLogs.id, input.eventLogId),
          eq(eventLogs.organizationId, ctx.user.organizationId)
        )
      );

    return { success: true };
  }),
```

Add necessary imports at top of file:

```typescript
import { eventLogs } from '../db/schema/event-logs.js';
import { profiles } from '../db/schema/profiles.js';
import { and, eq, inArray, desc } from 'drizzle-orm';
```

Note: Verify the exact schema table names and import paths by checking existing imports in the file.
</action>
<verify>
`grep -c "listEventLogs" backend/src/routers/readings.router.ts` returns 1+
`grep -c "createEventLog" backend/src/routers/readings.router.ts` returns 1+
`grep -c "deleteEventLog" backend/src/routers/readings.router.ts` returns 1+
`npx tsc --noEmit` passes for backend
</verify>
<done>Backend has listEventLogs, createEventLog, deleteEventLog procedures</done>
</task>

<task type="auto">
  <name>Task 2: Migrate AnnotationsWidget to tRPC</name>
  <files>src/features/dashboard-layout/widgets/AnnotationsWidget.tsx</files>
  <action>
Replace supabase queries and mutations with tRPC.

1. Remove import: `import { supabase } from "@/lib/supabase-placeholder";`
2. Add imports: `import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"; import { useTRPC, useTRPCClient } from "@/lib/trpc";`
3. Replace data fetching and mutations:

**Replace fetchAnnotations:**

```tsx
const trpc = useTRPC();
const queryClient = useQueryClient();

const queryOptions = trpc.readings.listEventLogs.queryOptions({
  organizationId: organizationId!,
  unitId: entityId!,
  eventTypes: ['note_added', 'comment', 'shift_handoff', 'annotation'],
  limit: 20,
});

const {
  data: annotations,
  isLoading,
  refetch,
} = useQuery({
  ...queryOptions,
  enabled: !!entityId && !!organizationId,
});
```

**Replace handleSaveNote:**

```tsx
const client = useTRPCClient();

const createMutation = useMutation({
  mutationFn: async (noteText: string) => {
    return client.readings.createEventLog.mutate({
      organizationId: organizationId!,
      unitId: entityId!,
      eventType: 'note_added',
      eventData: { note: noteText },
    });
  },
  onSuccess: () => {
    toast.success('Note added');
    setNoteText('');
    setIsAddingNote(false);
    queryClient.invalidateQueries({ queryKey: queryOptions.queryKey });
  },
  onError: () => {
    toast.error('Failed to add note');
  },
});

const handleSaveNote = () => {
  if (!noteText.trim()) return;
  createMutation.mutate(noteText.trim());
};
```

**Replace handleDeleteAnnotation:**

```tsx
const deleteMutation = useMutation({
  mutationFn: async (eventLogId: string) => {
    return client.readings.deleteEventLog.mutate({
      organizationId: organizationId!,
      eventLogId,
    });
  },
  onSuccess: () => {
    toast.success('Annotation deleted');
    setAnnotationToDelete(null);
    queryClient.invalidateQueries({ queryKey: queryOptions.queryKey });
  },
  onError: () => {
    toast.error('Failed to delete annotation');
  },
});

const handleDeleteAnnotation = () => {
  if (!annotationToDelete) return;
  deleteMutation.mutate(annotationToDelete.id);
};
```

Update the component state:

- Replace `isSaving` with `createMutation.isPending`
- Replace `isDeleting` with `deleteMutation.isPending`

Transform tRPC response to match expected Annotation interface:

```tsx
const transformedAnnotations = useMemo(() => {
  if (!annotations) return [];
  return annotations.map((a) => ({
    id: a.id,
    title: a.title,
    event_data: a.eventData as { note?: string; message?: string },
    recorded_at: a.recordedAt,
    actor_id: a.actorId,
    author_name: a.authorName,
    author_email: a.authorEmail,
  }));
}, [annotations]);
```

  </action>
  <verify>
`grep -c "supabase-placeholder" src/features/dashboard-layout/widgets/AnnotationsWidget.tsx` returns 0
`grep -c "useTRPC" src/features/dashboard-layout/widgets/AnnotationsWidget.tsx` returns 1+
`grep -c "useMutation" src/features/dashboard-layout/widgets/AnnotationsWidget.tsx` returns 1+
`npx tsc --noEmit` passes
  </verify>
  <done>AnnotationsWidget uses tRPC for queries and mutations, no supabase imports remain</done>
</task>

<task type="auto">
  <name>Task 3: Migrate EventTimelineWidget to tRPC</name>
  <files>src/features/dashboard-layout/widgets/EventTimelineWidget.tsx</files>
  <action>
Replace supabase queries with tRPC. This widget combines alerts, manual logs, and door events.

1. Remove import: `import { supabase } from "@/lib/supabase-placeholder";`
2. Add imports: `import { useQuery } from "@tanstack/react-query"; import { useTRPC } from "@/lib/trpc";`
3. Replace fetchEvents with multiple useQuery hooks:

```tsx
const trpc = useTRPC();

// Query alerts
const alertsQuery = useQuery({
  ...trpc.alerts.list.queryOptions({
    organizationId: organizationId!,
    unitId: entityId,
    limit: EVENTS_PER_PAGE,
  }),
  enabled: !!entityId && !!organizationId && filters.alert,
});

// Query manual logs
const logsQuery = useQuery({
  ...trpc.readings.listManual.queryOptions({
    organizationId: organizationId!,
    unitId: entityId,
    limit: EVENTS_PER_PAGE,
  }),
  enabled: !!entityId && !!organizationId && filters.manual_log,
});

// Query door events
const doorEventsQuery = useQuery({
  ...trpc.readings.listDoorEvents.queryOptions({
    organizationId: organizationId!,
    unitId: entityId,
    limit: EVENTS_PER_PAGE,
  }),
  enabled: !!entityId && !!organizationId && filters.door,
});

const isLoading = alertsQuery.isLoading || logsQuery.isLoading || doorEventsQuery.isLoading;

// Combine and transform events
const events = useMemo(() => {
  const allEvents: TimelineEvent[] = [];

  // Add alerts
  if (filters.alert && alertsQuery.data) {
    alertsQuery.data.forEach((a) => {
      allEvents.push({
        id: `alert-${a.id}`,
        type: 'alert',
        title: a.title,
        description: `${a.severity} alert`,
        timestamp: a.triggeredAt || a.createdAt,
      });
    });
  }

  // Add manual logs
  if (filters.manual_log && logsQuery.data) {
    logsQuery.data.forEach((l) => {
      allEvents.push({
        id: `log-${l.id}`,
        type: 'manual_log',
        title: `Manual log: ${l.temperature}Â°`,
        description: l.notes || undefined,
        timestamp: l.loggedAt,
      });
    });
  }

  // Add door events
  if (filters.door && doorEventsQuery.data) {
    doorEventsQuery.data.forEach((d) => {
      allEvents.push({
        id: `door-${d.id}`,
        type: 'door',
        title: `Door ${d.state}`,
        timestamp: d.occurredAt,
      });
    });
  }

  // Sort by timestamp descending
  allEvents.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

  return allEvents.slice(0, EVENTS_PER_PAGE);
}, [filters, alertsQuery.data, logsQuery.data, doorEventsQuery.data]);
```

Note: tRPC responses use camelCase (triggeredAt, createdAt, loggedAt, occurredAt).

Remove the append/loadMore logic since we're now using react-query caching. If pagination is needed, implement with offset/page parameters in a future iteration. For now, show first page only.

Set `hasMore = false` or implement proper pagination later.
</action>
<verify>
`grep -c "supabase-placeholder" src/features/dashboard-layout/widgets/EventTimelineWidget.tsx` returns 0
`grep -c "useTRPC" src/features/dashboard-layout/widgets/EventTimelineWidget.tsx` returns 1+
`npx tsc --noEmit` passes
</verify>
<done>EventTimelineWidget uses tRPC for all queries, no supabase imports remain</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Check no supabase imports remain in migrated widgets:

```bash
grep -l "supabase-placeholder" src/features/dashboard-layout/widgets/AnnotationsWidget.tsx src/features/dashboard-layout/widgets/EventTimelineWidget.tsx
```

Should return empty.

2. Check backend procedures exist:

```bash
grep -E "(listEventLogs|createEventLog|deleteEventLog)" backend/src/routers/readings.router.ts
```

Should show 3 procedure definitions.

3. TypeScript compilation:

```bash
npx tsc --noEmit
```

4. Verify tRPC usage:

```bash
grep -c "useTRPC" src/features/dashboard-layout/widgets/AnnotationsWidget.tsx
grep -c "useTRPC" src/features/dashboard-layout/widgets/EventTimelineWidget.tsx
```

Each should return 1+.
</verification>

<success_criteria>

- Backend has 3 new event log procedures (listEventLogs, createEventLog, deleteEventLog)
- AnnotationsWidget uses tRPC for queries and mutations
- EventTimelineWidget uses tRPC for all entity queries
- Zero supabase-placeholder imports in migrated files
- TypeScript compiles without errors
  </success_criteria>

<output>
After completion, create `.planning/phases/39-dashboard-widgets/39-03-SUMMARY.md`
</output>
