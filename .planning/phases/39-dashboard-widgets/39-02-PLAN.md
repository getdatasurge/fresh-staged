---
phase: 39-dashboard-widgets
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/features/dashboard-layout/widgets/UnitComparisonWidget.tsx
  - src/features/dashboard-layout/widgets/UnitComplianceScoreWidget.tsx
  - src/features/dashboard-layout/widgets/SiteActivityGraphWidget.tsx
  - src/features/dashboard-layout/widgets/DowntimeTrackerWidget.tsx
autonomous: true

must_haves:
  truths:
    - "UnitComparisonWidget renders unit comparison data from tRPC without supabase"
    - "UnitComplianceScoreWidget renders compliance metrics from tRPC without supabase"
    - "SiteActivityGraphWidget renders activity sparklines from tRPC without supabase"
    - "DowntimeTrackerWidget renders downtime data from tRPC without supabase"
    - "Dashboard loads showing all four widgets without errors"
  artifacts:
    - path: "src/features/dashboard-layout/widgets/UnitComparisonWidget.tsx"
      provides: "Unit comparison display using tRPC"
      contains: "useTRPC"
    - path: "src/features/dashboard-layout/widgets/UnitComplianceScoreWidget.tsx"
      provides: "Compliance score display using tRPC"
      contains: "useTRPC"
    - path: "src/features/dashboard-layout/widgets/SiteActivityGraphWidget.tsx"
      provides: "Site activity graph using tRPC"
      contains: "useTRPC"
    - path: "src/features/dashboard-layout/widgets/DowntimeTrackerWidget.tsx"
      provides: "Downtime tracker using tRPC"
      contains: "useTRPC"
  key_links:
    - from: "src/features/dashboard-layout/widgets/UnitComparisonWidget.tsx"
      to: "trpc.units.listByOrg"
      via: "queryOptions"
      pattern: "trpc\\.units\\.listByOrg"
    - from: "src/features/dashboard-layout/widgets/UnitComplianceScoreWidget.tsx"
      to: "trpc.readings"
      via: "queryOptions"
      pattern: "trpc\\.readings"
    - from: "src/features/dashboard-layout/widgets/SiteActivityGraphWidget.tsx"
      to: "trpc.units.listByOrg"
      via: "queryOptions"
      pattern: "trpc\\.units\\.listByOrg"
    - from: "src/features/dashboard-layout/widgets/DowntimeTrackerWidget.tsx"
      to: "trpc.readings.list"
      via: "queryOptions"
      pattern: "trpc\\.readings\\.list"
---

<objective>
Migrate 4 medium-complexity dashboard widgets from supabase to tRPC data fetching.

Purpose: These widgets have multiple queries or more complex data fetching that requires combining existing tRPC procedures.

Output: 4 widgets using tRPC hooks instead of supabase-placeholder imports.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-test-infrastructure/38-01-SUMMARY.md (tRPC mock patterns)
@src/hooks/useSites.ts (tRPC hook pattern reference)
@src/hooks/useUnits.ts (tRPC hook pattern reference)
@backend/src/routers/readings.router.ts (available procedures)
@backend/src/routers/units.router.ts (available procedures)
@backend/src/routers/areas.router.ts (available procedures)
@backend/src/routers/alerts.router.ts (available procedures)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate UnitComparisonWidget to tRPC</name>
  <files>src/features/dashboard-layout/widgets/UnitComparisonWidget.tsx</files>
  <action>
Replace supabase queries with tRPC. This widget already uses useQuery but with supabase inside queryFn.

1. Remove import: `import { supabase } from "@/lib/supabase-placeholder";`
2. Add import: `import { useTRPC } from "@/lib/trpc";`
3. Replace the queryFn that uses supabase with tRPC queryOptions:

Current pattern:
```tsx
const { data: allUnits, isLoading: unitsLoading } = useQuery({
  queryKey: ["site-units-comparison", site?.id],
  queryFn: async () => {
    // supabase calls for areas and units
  },
  enabled: !!site?.id,
});
```

New pattern using tRPC:
```tsx
const trpc = useTRPC();
const queryOptions = trpc.units.listByOrg.queryOptions({
  organizationId: organizationId!,
});
const { data: allUnitsRaw, isLoading: unitsLoading } = useQuery({
  ...queryOptions,
  enabled: !!organizationId && !!site?.id,
  staleTime: 60_000,
});

// Filter and transform to match expected shape
const allUnits = useMemo(() => {
  if (!allUnitsRaw || !site?.id) return [];
  return allUnitsRaw
    .filter(u => u.site?.id === site.id && !u.deletedAt)
    .map(u => ({
      id: u.id,
      name: u.name,
      area_id: u.area?.id,
      area_name: u.area?.name || '',
      last_temp_reading: u.lastTempReading,
      temp_limit_high: u.tempLimitHigh,
      temp_limit_low: u.tempLimitLow,
      last_reading_at: u.lastReadingAt,
    }));
}, [allUnitsRaw, site?.id]);
```

Note: The widget needs organizationId - get from props.organizationId.
Field mapping: tRPC uses camelCase (lastTempReading, tempLimitHigh, tempLimitLow, lastReadingAt).
  </action>
  <verify>
`grep -c "supabase-placeholder" src/features/dashboard-layout/widgets/UnitComparisonWidget.tsx` returns 0
`grep -c "useTRPC" src/features/dashboard-layout/widgets/UnitComparisonWidget.tsx` returns 1+
`npx tsc --noEmit` passes
  </verify>
  <done>UnitComparisonWidget fetches data via tRPC, no supabase imports remain</done>
</task>

<task type="auto">
  <name>Task 2: Migrate UnitComplianceScoreWidget to tRPC</name>
  <files>src/features/dashboard-layout/widgets/UnitComplianceScoreWidget.tsx</files>
  <action>
Replace supabase queries with tRPC. This widget has 3 queries for compliance calculation.

1. Remove import: `import { supabase } from "@/lib/supabase-placeholder";`
2. Add imports: `import { useQuery } from "@tanstack/react-query"; import { useTRPC } from "@/lib/trpc";`
3. Replace the useEffect with multiple useQuery hooks:

Current supabase queries:
- `sensor_readings.select("*", { count: "exact", head: true }).eq("unit_id", entityId).gte("recorded_at", dayAgo)` - for reading count
- `manual_temperature_logs.select("*", { count: "exact", head: true }).eq("unit_id", entityId).gte("logged_at", dayAgo)` - for log count
- `alerts.select("resolved_at").eq("unit_id", entityId).gte("created_at", dayAgo)` - for alert response

New pattern with tRPC:
```tsx
const trpc = useTRPC();
const dayAgo = useMemo(() => new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(), []);

// Query readings
const readingsQuery = useQuery({
  ...trpc.readings.list.queryOptions({
    organizationId: organizationId!,
    unitId: entityId!,
    start: dayAgo,
    limit: 200,
  }),
  enabled: !!entityId && !!organizationId,
});

// Query manual logs
const logsQuery = useQuery({
  ...trpc.readings.listManual.queryOptions({
    organizationId: organizationId!,
    unitId: entityId,
    start: dayAgo,
  }),
  enabled: !!entityId && !!organizationId,
});

// Query alerts
const alertsQuery = useQuery({
  ...trpc.alerts.list.queryOptions({
    organizationId: organizationId!,
    unitId: entityId,
    start: dayAgo,
  }),
  enabled: !!entityId && !!organizationId,
});

const isLoading = readingsQuery.isLoading || logsQuery.isLoading || alertsQuery.isLoading;

// Compute metrics
const metrics = useMemo(() => {
  if (!readingsQuery.data && !logsQuery.data && !alertsQuery.data) return null;

  const readingCount = readingsQuery.data?.length ?? 0;
  const logCount = logsQuery.data?.length ?? 0;
  const alerts = alertsQuery.data ?? [];

  // ... same calculation logic
}, [readingsQuery.data, logsQuery.data, alertsQuery.data]);
```

Note: Get organizationId from props.
  </action>
  <verify>
`grep -c "supabase-placeholder" src/features/dashboard-layout/widgets/UnitComplianceScoreWidget.tsx` returns 0
`grep -c "useTRPC" src/features/dashboard-layout/widgets/UnitComplianceScoreWidget.tsx` returns 1+
`npx tsc --noEmit` passes
  </verify>
  <done>UnitComplianceScoreWidget fetches data via tRPC, no supabase imports remain</done>
</task>

<task type="auto">
  <name>Task 3: Migrate SiteActivityGraphWidget and DowntimeTrackerWidget to tRPC</name>
  <files>
src/features/dashboard-layout/widgets/SiteActivityGraphWidget.tsx
src/features/dashboard-layout/widgets/DowntimeTrackerWidget.tsx
  </files>
  <action>
Both widgets need similar migration: replace multiple supabase queries with tRPC.

**SiteActivityGraphWidget:**

1. Remove import: `import { supabase } from "@/lib/supabase-placeholder";`
2. Add import: `import { useTRPC } from "@/lib/trpc";`
3. Replace queryFn with tRPC:

Current queries fetch: areas, units, sensors, readings.
Use existing tRPC procedures:
- `trpc.units.listByOrg` to get units with area info
- `trpc.readings.list` to get readings per unit

New pattern:
```tsx
const trpc = useTRPC();

// Get all units for org (already has area info)
const unitsQueryOptions = trpc.units.listByOrg.queryOptions({
  organizationId: organizationId!,
});
const { data: allUnits } = useQuery({
  ...unitsQueryOptions,
  enabled: !!organizationId && !!site?.id,
});

// Filter units for this site
const siteUnits = useMemo(() =>
  allUnits?.filter(u => u.site?.id === site?.id) ?? [],
  [allUnits, site?.id]
);

// For each unit, get readings (can combine into single query if needed)
// Use react-query's useQueries for parallel fetching or compute activity from lastReadingAt
```

Simplification: Since listByOrg returns lastReadingAt, we can derive activity status without fetching all readings. For detailed hourly activity, consider adding a dedicated backend procedure later (out of scope for this phase - use available data).

**DowntimeTrackerWidget:**

1. Remove import: `import { supabase } from "@/lib/supabase-placeholder";`
2. Add import: `import { useTRPC } from "@/lib/trpc";`
3. Replace queryFn with tRPC:

Current queries: sensors, readings for downtime calculation.
Use `trpc.readings.list` with date range to get readings, then run gap detection.

```tsx
const trpc = useTRPC();

const readingsQueryOptions = trpc.readings.list.queryOptions({
  organizationId: organizationId!,
  unitId: entityId!,
  start: timeRange.start.toISOString(),
  end: timeRange.end.toISOString(),
  limit: 1000,
});

const { data: readings, isLoading } = useQuery({
  ...readingsQueryOptions,
  enabled: !!entityId && !!organizationId,
  staleTime: 5 * 60 * 1000,
});

// Transform readings for gap detection
const readingsForGapDetection = useMemo(() =>
  readings?.map(r => ({ recorded_at: r.recordedAt })) ?? [],
  [readings]
);

const downtimeSummary = useMemo(() =>
  findDowntimeIntervals(readingsForGapDetection, DEFAULT_OFFLINE_THRESHOLD_MS, timeRange),
  [readingsForGapDetection, timeRange]
);
```

For site-level, fetch all units first then aggregate readings.
  </action>
  <verify>
`grep -c "supabase-placeholder" src/features/dashboard-layout/widgets/SiteActivityGraphWidget.tsx` returns 0
`grep -c "supabase-placeholder" src/features/dashboard-layout/widgets/DowntimeTrackerWidget.tsx` returns 0
`grep -c "useTRPC" src/features/dashboard-layout/widgets/SiteActivityGraphWidget.tsx` returns 1+
`grep -c "useTRPC" src/features/dashboard-layout/widgets/DowntimeTrackerWidget.tsx` returns 1+
`npx tsc --noEmit` passes
  </verify>
  <done>SiteActivityGraphWidget and DowntimeTrackerWidget fetch data via tRPC, no supabase imports remain</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Check no supabase imports remain in migrated widgets:
```bash
grep -l "supabase-placeholder" src/features/dashboard-layout/widgets/UnitComparisonWidget.tsx src/features/dashboard-layout/widgets/UnitComplianceScoreWidget.tsx src/features/dashboard-layout/widgets/SiteActivityGraphWidget.tsx src/features/dashboard-layout/widgets/DowntimeTrackerWidget.tsx
```
Should return empty.

2. TypeScript compilation:
```bash
npx tsc --noEmit
```

3. Verify tRPC usage:
```bash
grep -c "useTRPC" src/features/dashboard-layout/widgets/UnitComparisonWidget.tsx
grep -c "useTRPC" src/features/dashboard-layout/widgets/UnitComplianceScoreWidget.tsx
grep -c "useTRPC" src/features/dashboard-layout/widgets/SiteActivityGraphWidget.tsx
grep -c "useTRPC" src/features/dashboard-layout/widgets/DowntimeTrackerWidget.tsx
```
Each should return 1+.
</verification>

<success_criteria>
- 4 widgets migrated from supabase to tRPC
- Zero supabase-placeholder imports in migrated files
- TypeScript compiles without errors
- Each widget uses useTRPC() pattern with queryOptions
</success_criteria>

<output>
After completion, create `.planning/phases/39-dashboard-widgets/39-02-SUMMARY.md`
</output>
