---
phase: 12-digitalocean-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/deploy.config.example
  - scripts/lib/doctl-helpers.sh
autonomous: true

must_haves:
  truths:
    - "doctl CLI authentication is validated before any DigitalOcean API calls"
    - "SSH key fingerprint is retrieved and validated for Droplet access"
    - "DigitalOcean-specific configuration options are documented in config template"
  artifacts:
    - path: "scripts/deploy.config.example"
      provides: "DigitalOcean configuration options section"
      contains: "DIGITALOCEAN_TOKEN"
    - path: "scripts/lib/doctl-helpers.sh"
      provides: "doctl CLI wrapper functions"
      exports: ["validate_doctl_auth", "get_ssh_key_fingerprint", "create_cloud_init"]
  key_links:
    - from: "scripts/deploy.config.example"
      to: "scripts/lib/doctl-helpers.sh"
      via: "environment variable references"
      pattern: "DIGITALOCEAN_TOKEN|DO_SSH_KEY_NAME|DO_REGION"
---

<objective>
Add DigitalOcean-specific configuration options to the deployment config template and create helper functions for doctl CLI authentication and SSH key validation.

Purpose: Establish the foundation for automated DigitalOcean deployments by providing configuration options and reusable helper functions that deploy-digitalocean.sh will use.

Output: Enhanced deploy.config.example with DO section, and scripts/lib/doctl-helpers.sh with authentication/validation functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-digitalocean-deployment/12-RESEARCH.md
@scripts/deploy.config.example
@scripts/deploy-selfhosted.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DigitalOcean configuration section to deploy.config.example</name>
  <files>scripts/deploy.config.example</files>
  <action>
Add a new section for DigitalOcean-specific configuration options after the existing "Git Repository" section:

```bash
# ===========================================
# DigitalOcean Configuration (Optional)
# ===========================================
# Only required when deploying to DigitalOcean Droplet
# Skip this section for generic self-hosted deployments

# DigitalOcean API Token
# Create at: https://cloud.digitalocean.com/account/api/tokens
# Required permissions: Read and Write
# Example: dop_v1_abc123def456...
DO_API_TOKEN=

# SSH Key Name (as shown in DigitalOcean dashboard)
# Found at: https://cloud.digitalocean.com/account/security
# Example: my-laptop-key
DO_SSH_KEY_NAME=

# Droplet region (choose closest to your users)
# Options: nyc1, nyc3, sfo3, ams3, sgp1, lon1, fra1, tor1, blr1, syd1
# Default: nyc3
DO_REGION=nyc3

# Droplet size (determines CPU/RAM)
# Common options:
#   s-1vcpu-1gb   ($6/mo)   - Development/testing
#   s-2vcpu-2gb   ($18/mo)  - Small production
#   s-2vcpu-4gb   ($24/mo)  - Recommended for production
#   s-4vcpu-8gb   ($48/mo)  - High traffic
# Default: s-2vcpu-4gb
DO_DROPLET_SIZE=s-2vcpu-4gb

# ===========================================
# DigitalOcean Managed Database (Optional)
# ===========================================
# Set USE_MANAGED_DB=true to use DigitalOcean Managed PostgreSQL
# instead of self-hosted PostgreSQL container.
# Cost: $15-60/month depending on tier

# Use managed PostgreSQL instead of self-hosted
# Default: false (uses containerized PostgreSQL)
USE_MANAGED_DB=false

# Managed database size (only if USE_MANAGED_DB=true)
# Options:
#   db-s-1vcpu-1gb   ($15/mo)  - Development
#   db-s-1vcpu-2gb   ($30/mo)  - Small production
#   db-s-2vcpu-4gb   ($60/mo)  - Production with HA standby
# Default: db-s-1vcpu-2gb
DO_DB_SIZE=db-s-1vcpu-2gb

# ===========================================
# DigitalOcean Spaces (Optional)
# ===========================================
# Set USE_DO_SPACES=true to use DigitalOcean Spaces
# instead of self-hosted MinIO container.
# Cost: $5/month for 250GB + 1TB bandwidth

# Use DigitalOcean Spaces instead of MinIO
# Default: false (uses containerized MinIO)
USE_DO_SPACES=false

# Spaces access key (only if USE_DO_SPACES=true)
# Create at: https://cloud.digitalocean.com/account/api/spaces
DO_SPACES_ACCESS_KEY=

# Spaces secret key
DO_SPACES_SECRET_KEY=

# Spaces region (same as Droplet region recommended)
# Options: nyc3, sfo3, ams3, sgp1, fra1
DO_SPACES_REGION=nyc3

# Spaces bucket name
DO_SPACES_BUCKET=freshtrack-media
```

Add extensive comments explaining each option, including links to DigitalOcean dashboard pages for key retrieval.
  </action>
  <verify>
Run: `grep -c "DO_API_TOKEN\|DO_SSH_KEY_NAME\|DO_REGION\|USE_MANAGED_DB\|USE_DO_SPACES" scripts/deploy.config.example`
Expected: 5 or more matches confirming all new config options are present.
  </verify>
  <done>deploy.config.example contains complete DigitalOcean configuration section with API token, SSH key, region, Droplet size, managed database options, and Spaces options.</done>
</task>

<task type="auto">
  <name>Task 2: Create doctl helper functions library</name>
  <files>scripts/lib/doctl-helpers.sh</files>
  <action>
Create a new file `scripts/lib/doctl-helpers.sh` with reusable functions for DigitalOcean CLI operations:

```bash
#!/bin/bash
# FreshTrack Pro - DigitalOcean CLI Helper Functions
# Source this file in deploy-digitalocean.sh
# Requires: doctl CLI installed and authenticated

# ===========================================
# Authentication and Validation
# ===========================================

# Validate doctl is installed and authenticated
validate_doctl_auth() {
    step "Validating DigitalOcean CLI..."

    # Check if doctl is installed
    if ! command -v doctl &> /dev/null; then
        error "doctl CLI not found"
        echo ""
        echo "Install doctl:"
        echo "  macOS:  brew install doctl"
        echo "  Linux:  snap install doctl"
        echo "  Manual: https://docs.digitalocean.com/reference/doctl/how-to/install/"
        echo ""
        return 1
    fi

    success "doctl installed: $(doctl version | head -1)"

    # Authenticate with token if provided
    if [ -n "$DO_API_TOKEN" ]; then
        echo "$DO_API_TOKEN" | doctl auth init --context freshtrack 2>/dev/null
        doctl auth switch --context freshtrack 2>/dev/null
        success "Authenticated with provided API token"
    fi

    # Validate authentication by attempting API call
    if ! doctl account get --format Email --no-header 2>/dev/null; then
        error "doctl not authenticated"
        echo ""
        echo "Authenticate doctl:"
        echo "  Option 1: Set DO_API_TOKEN in deploy.config"
        echo "  Option 2: Run: doctl auth init"
        echo ""
        echo "Create API token at: https://cloud.digitalocean.com/account/api/tokens"
        return 1
    fi

    local account_email
    account_email=$(doctl account get --format Email --no-header)
    success "Authenticated as: ${account_email}"

    return 0
}

# Get SSH key fingerprint by name
get_ssh_key_fingerprint() {
    local key_name="$1"

    if [ -z "$key_name" ]; then
        error "SSH key name required"
        echo "Set DO_SSH_KEY_NAME in deploy.config"
        return 1
    fi

    step "Looking up SSH key: ${key_name}..."

    local fingerprint
    fingerprint=$(doctl compute ssh-key list --format Name,FingerPrint --no-header | grep "^${key_name}" | awk '{print $2}')

    if [ -z "$fingerprint" ]; then
        error "SSH key not found: ${key_name}"
        echo ""
        echo "Available SSH keys:"
        doctl compute ssh-key list --format Name,FingerPrint
        echo ""
        echo "Add SSH key at: https://cloud.digitalocean.com/account/security"
        return 1
    fi

    success "SSH key fingerprint: ${fingerprint}"
    echo "$fingerprint"
}

# Validate region exists
validate_region() {
    local region="$1"

    if [ -z "$region" ]; then
        warning "No region specified, using default: nyc3"
        echo "nyc3"
        return 0
    fi

    if ! doctl compute region list --format Slug --no-header | grep -qx "$region"; then
        error "Invalid region: ${region}"
        echo ""
        echo "Available regions:"
        doctl compute region list --format Slug,Name,Available
        return 1
    fi

    success "Region validated: ${region}"
    echo "$region"
}

# ===========================================
# Cloud-Init User Data
# ===========================================

# Create cloud-init configuration for Droplet first boot
create_cloud_init() {
    local output_file="${1:-/tmp/cloud-init.yaml}"
    local git_repo="${GIT_REPO_URL:-https://github.com/yourusername/freshtrack-pro.git}"
    local git_branch="${GIT_BRANCH:-main}"

    step "Creating cloud-init configuration..."

    cat > "$output_file" <<EOF
#cloud-config
package_update: true
package_upgrade: true

packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - gnupg
  - ufw
  - fail2ban
  - git
  - jq

runcmd:
  # Install Docker using official script
  - curl -fsSL https://get.docker.com -o /tmp/get-docker.sh
  - sh /tmp/get-docker.sh
  - systemctl enable docker
  - systemctl start docker
  - rm /tmp/get-docker.sh

  # Configure firewall
  - ufw allow 22/tcp comment 'SSH'
  - ufw allow 80/tcp comment 'HTTP'
  - ufw allow 443/tcp comment 'HTTPS'
  - ufw --force enable

  # Configure fail2ban for SSH protection
  - systemctl enable fail2ban
  - systemctl start fail2ban

  # Clone application repository
  - git clone --branch ${git_branch} ${git_repo} /opt/freshtrack-pro

  # Create secrets directory
  - mkdir -p /opt/freshtrack-pro/secrets
  - chmod 700 /opt/freshtrack-pro/secrets

  # Signal boot completion
  - touch /var/lib/cloud/instance/boot-finished

final_message: "FreshTrack Pro base setup complete after \$UPTIME seconds"
EOF

    success "Cloud-init configuration created: ${output_file}"
    echo "$output_file"
}

# ===========================================
# VPC and Networking
# ===========================================

# Get or create VPC for deployment
ensure_vpc() {
    local vpc_name="${1:-freshtrack-vpc}"
    local region="${2:-nyc3}"

    step "Checking for existing VPC: ${vpc_name}..."

    # Check if VPC exists
    local vpc_uuid
    vpc_uuid=$(doctl vpcs list --format Name,ID --no-header | grep "^${vpc_name}" | awk '{print $2}')

    if [ -n "$vpc_uuid" ]; then
        success "Using existing VPC: ${vpc_uuid}"
        echo "$vpc_uuid"
        return 0
    fi

    step "Creating VPC: ${vpc_name}..."

    vpc_uuid=$(doctl vpcs create \
        --name "${vpc_name}" \
        --region "${region}" \
        --ip-range "10.116.0.0/20" \
        --format ID \
        --no-header)

    if [ -z "$vpc_uuid" ]; then
        error "Failed to create VPC"
        return 1
    fi

    success "Created VPC: ${vpc_uuid}"
    echo "$vpc_uuid"
}

# Create Cloud Firewall for Droplet
ensure_cloud_firewall() {
    local firewall_name="${1:-freshtrack-firewall}"
    local droplet_id="$2"

    step "Checking for existing Cloud Firewall: ${firewall_name}..."

    # Check if firewall exists
    local firewall_id
    firewall_id=$(doctl compute firewall list --format Name,ID --no-header | grep "^${firewall_name}" | awk '{print $2}')

    if [ -n "$firewall_id" ]; then
        success "Using existing firewall: ${firewall_id}"

        # Add Droplet to firewall if specified
        if [ -n "$droplet_id" ]; then
            doctl compute firewall add-droplets "$firewall_id" --droplet-ids "$droplet_id" 2>/dev/null || true
            success "Droplet added to firewall"
        fi

        echo "$firewall_id"
        return 0
    fi

    step "Creating Cloud Firewall: ${firewall_name}..."

    local inbound="protocol:tcp,ports:22,sources:addresses:0.0.0.0/0,::/0"
    inbound="${inbound} protocol:tcp,ports:80,sources:addresses:0.0.0.0/0,::/0"
    inbound="${inbound} protocol:tcp,ports:443,sources:addresses:0.0.0.0/0,::/0"

    local outbound="protocol:tcp,ports:all,destinations:addresses:0.0.0.0/0,::/0"
    outbound="${outbound} protocol:udp,ports:all,destinations:addresses:0.0.0.0/0,::/0"
    outbound="${outbound} protocol:icmp,destinations:addresses:0.0.0.0/0,::/0"

    local create_args=(
        --name "${firewall_name}"
        --inbound-rules "$inbound"
        --outbound-rules "$outbound"
    )

    if [ -n "$droplet_id" ]; then
        create_args+=(--droplet-ids "$droplet_id")
    fi

    firewall_id=$(doctl compute firewall create "${create_args[@]}" --format ID --no-header)

    if [ -z "$firewall_id" ]; then
        error "Failed to create Cloud Firewall"
        return 1
    fi

    success "Created Cloud Firewall: ${firewall_id}"
    echo "$firewall_id"
}
```

Make the file executable. Include color output helpers that match deploy-selfhosted.sh style (step, success, error, warning functions should be available from the parent script that sources this).
  </action>
  <verify>
Run: `bash -n scripts/lib/doctl-helpers.sh && echo "Syntax OK" && grep -c "^[a-z_]*() {" scripts/lib/doctl-helpers.sh`
Expected: "Syntax OK" and count of 7 or more function definitions.
  </verify>
  <done>scripts/lib/doctl-helpers.sh contains validate_doctl_auth, get_ssh_key_fingerprint, validate_region, create_cloud_init, ensure_vpc, and ensure_cloud_firewall functions.</done>
</task>

<task type="auto">
  <name>Task 3: Create lib directory and make helpers executable</name>
  <files>scripts/lib/.gitkeep</files>
  <action>
1. Create the scripts/lib/ directory if it doesn't exist
2. Make doctl-helpers.sh executable with chmod +x
3. Add a brief README comment at the top of doctl-helpers.sh explaining it must be sourced from deploy scripts
4. Verify the file structure is correct

```bash
mkdir -p scripts/lib
chmod +x scripts/lib/doctl-helpers.sh
```

The file should already have the documentation header from Task 2, but ensure it clearly states:
- This file is meant to be sourced (not executed directly)
- It requires deploy-selfhosted.sh color helper functions (step, success, error, warning)
- It requires doctl CLI to be installed
  </action>
  <verify>
Run: `test -x scripts/lib/doctl-helpers.sh && echo "Executable OK" && ls -la scripts/lib/`
Expected: "Executable OK" and file listing showing doctl-helpers.sh with execute permissions.
  </verify>
  <done>scripts/lib/ directory exists and doctl-helpers.sh is executable with proper documentation.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Config template validation:**
   ```bash
   grep -E "^DO_|^USE_" scripts/deploy.config.example | wc -l
   # Should be 11 or more new DO-prefixed variables
   ```

2. **Helper library syntax check:**
   ```bash
   bash -n scripts/lib/doctl-helpers.sh
   # Should exit 0 with no output
   ```

3. **Function availability:**
   ```bash
   source scripts/lib/doctl-helpers.sh 2>/dev/null
   type validate_doctl_auth | head -1
   # Should show "validate_doctl_auth is a function"
   ```

4. **File permissions:**
   ```bash
   stat -c "%a" scripts/lib/doctl-helpers.sh
   # Should be 755 or similar with execute bit
   ```
</verification>

<success_criteria>
- deploy.config.example contains DigitalOcean API token, SSH key, region, Droplet size, managed DB, and Spaces options
- scripts/lib/doctl-helpers.sh exists with 6+ reusable functions
- All functions have proper error handling with informative messages
- Cloud-init configuration creates Docker-ready Ubuntu base
- VPC and Cloud Firewall functions are idempotent (create or reuse existing)
</success_criteria>

<output>
After completion, create `.planning/phases/12-digitalocean-deployment/12-01-SUMMARY.md`
</output>
