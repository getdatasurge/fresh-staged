---
phase: 12-digitalocean-deployment
plan: 03
type: execute
wave: 2
depends_on: ['12-01', '12-02']
files_modified:
  - docker/compose.digitalocean.yaml
  - scripts/lib/managed-db-helpers.sh
  - scripts/deploy-digitalocean.sh
autonomous: true

must_haves:
  truths:
    - 'Managed PostgreSQL can be provisioned via doctl with connection pooling enabled'
    - 'compose.digitalocean.yaml connects to managed database when USE_MANAGED_DB=true'
    - 'SSL connection is enforced for managed database connections'
    - 'Connection uses pooler endpoint, not direct connection'
  artifacts:
    - path: 'docker/compose.digitalocean.yaml'
      provides: 'Managed PostgreSQL integration overlay'
      contains: 'do_database_url'
    - path: 'scripts/lib/managed-db-helpers.sh'
      provides: 'Managed database provisioning functions'
      exports: ['create_managed_database', 'get_connection_string']
  key_links:
    - from: 'docker/compose.digitalocean.yaml'
      to: 'managed PostgreSQL'
      via: 'DATABASE_URL with pooler endpoint'
      pattern: '-pooler.*sslmode=require'
    - from: 'scripts/deploy-digitalocean.sh'
      to: 'scripts/lib/managed-db-helpers.sh'
      via: 'source command for managed DB functions'
      pattern: 'source.*managed-db-helpers'
---

<objective>
Enhance compose.digitalocean.yaml for managed PostgreSQL integration and create helper functions for provisioning DigitalOcean Managed Databases with connection pooling.

Purpose: Enable seamless switching between self-hosted PostgreSQL (containerized) and DigitalOcean Managed PostgreSQL for teams wanting reduced operational burden.

Output: Enhanced compose overlay with managed DB support and helper scripts for database provisioning.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-digitalocean-deployment/12-RESEARCH.md
@docker/compose.digitalocean.yaml
@docker/compose.selfhosted.yaml
@scripts/deploy-digitalocean.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create managed database helper functions</name>
  <files>scripts/lib/managed-db-helpers.sh</files>
  <action>
Create a new file `scripts/lib/managed-db-helpers.sh` with functions for DigitalOcean Managed PostgreSQL:

```bash
#!/bin/bash
# FreshTrack Pro - DigitalOcean Managed Database Helper Functions
# Source this file in deploy-digitalocean.sh when USE_MANAGED_DB=true
# Requires: doctl CLI installed and authenticated

# ===========================================
# Managed PostgreSQL Provisioning
# ===========================================

# Check if managed database cluster exists
check_existing_database() {
    local cluster_name="$1"

    step "Checking for existing database cluster: ${cluster_name}..."

    local cluster_info
    cluster_info=$(doctl databases list --format Name,ID,Engine,Status --no-header | grep "^${cluster_name}" || true)

    if [ -n "$cluster_info" ]; then
        local cluster_id cluster_status
        cluster_id=$(echo "$cluster_info" | awk '{print $2}')
        cluster_status=$(echo "$cluster_info" | awk '{print $4}')

        success "Found existing database cluster: ${cluster_name}"
        echo "  ID:     ${cluster_id}"
        echo "  Status: ${cluster_status}"

        DB_CLUSTER_ID="$cluster_id"
        return 0
    fi

    return 1
}

# Create managed PostgreSQL cluster
create_managed_database() {
    local cluster_name="${1:-freshtrack-db}"
    local region="${2:-$DO_REGION}"
    local size="${3:-$DO_DB_SIZE}"
    local vpc_uuid="$4"

    # Check for existing cluster
    if check_existing_database "$cluster_name"; then
        warning "Database cluster already exists. Skipping creation."
        return 0
    fi

    step "Creating managed PostgreSQL cluster: ${cluster_name}..."
    echo "  Region: ${region}"
    echo "  Size:   ${size}"
    echo ""
    echo "This may take 5-10 minutes..."

    local create_args=(
        --engine pg
        --version 15
        --region "$region"
        --size "$size"
        --num-nodes 1
        --wait
        --format ID
        --no-header
    )

    if [ -n "$vpc_uuid" ]; then
        create_args+=(--private-network-uuid "$vpc_uuid")
        info "Database will be in VPC for private networking"
    fi

    DB_CLUSTER_ID=$(doctl databases create "$cluster_name" "${create_args[@]}")

    if [ -z "$DB_CLUSTER_ID" ]; then
        error "Failed to create database cluster"
        return 1
    fi

    success "Database cluster created: ${DB_CLUSTER_ID}"

    # Create connection pool for transaction mode
    create_connection_pool "$DB_CLUSTER_ID"

    # Download SSL certificate
    download_ssl_certificate "$DB_CLUSTER_ID"

    return 0
}

# Create connection pool (transaction mode for web apps)
create_connection_pool() {
    local cluster_id="$1"
    local pool_name="${2:-app-pool}"
    local pool_size="${3:-25}"

    step "Creating connection pool: ${pool_name}..."

    # Check if pool already exists
    if doctl databases pool list "$cluster_id" --format Name --no-header | grep -qx "$pool_name"; then
        success "Connection pool already exists: ${pool_name}"
        return 0
    fi

    # Get default database and user
    local db_name="defaultdb"
    local db_user="doadmin"

    doctl databases pool create "$cluster_id" "$pool_name" \
        --db "$db_name" \
        --user "$db_user" \
        --size "$pool_size" \
        --mode transaction

    success "Connection pool created: ${pool_name} (transaction mode, ${pool_size} connections)"
}

# Download SSL certificate for secure connections
download_ssl_certificate() {
    local cluster_id="$1"
    local output_path="${2:-/opt/freshtrack-pro/secrets/ca-certificate.crt}"

    step "Downloading SSL certificate..."

    mkdir -p "$(dirname "$output_path")"

    doctl databases ca get "$cluster_id" --output "$output_path"

    if [ -f "$output_path" ]; then
        chmod 600 "$output_path"
        success "SSL certificate saved: ${output_path}"
    else
        warning "Failed to download SSL certificate"
        echo "You may need to download manually from DigitalOcean dashboard"
    fi
}

# ===========================================
# Connection String Management
# ===========================================

# Get connection string for managed database
get_connection_string() {
    local cluster_id="$1"
    local use_pool="${2:-true}"
    local ssl_mode="${3:-require}"

    step "Retrieving connection string..."

    # Get connection details
    local conn_info
    conn_info=$(doctl databases connection "$cluster_id" --format Host,Port,User,Password,Database --no-header)

    local host port user password database
    host=$(echo "$conn_info" | awk '{print $1}')
    port=$(echo "$conn_info" | awk '{print $2}')
    user=$(echo "$conn_info" | awk '{print $3}')
    password=$(echo "$conn_info" | awk '{print $4}')
    database=$(echo "$conn_info" | awk '{print $5}')

    # Use pooler endpoint if requested (IMPORTANT: always use for production)
    if [ "$use_pool" = "true" ]; then
        # Pooler hostname format: {host}-pooler instead of {host}
        # DigitalOcean format: private-xxx.db.ondigitalocean.com -> private-xxx-pooler.db.ondigitalocean.com
        host="${host//.db.ondigitalocean.com/-pooler.db.ondigitalocean.com}"
        info "Using connection pooler endpoint"
    else
        warning "Using direct connection (not recommended for production)"
    fi

    # Construct connection string
    local conn_string="postgresql://${user}:${password}@${host}:${port}/${database}?sslmode=${ssl_mode}"

    echo "$conn_string"
}

# Save connection string to secrets file
save_connection_string() {
    local cluster_id="$1"
    local output_path="${2:-/opt/freshtrack-pro/secrets/do_database_url}"

    local conn_string
    conn_string=$(get_connection_string "$cluster_id" "true" "require")

    mkdir -p "$(dirname "$output_path")"
    echo -n "$conn_string" > "$output_path"
    chmod 600 "$output_path"

    success "Connection string saved: ${output_path}"

    # Display obfuscated connection info
    local safe_conn
    safe_conn=$(echo "$conn_string" | sed 's/:.*@/:****@/')
    info "Connection: ${safe_conn}"
}

# ===========================================
# Database Management
# ===========================================

# Configure trusted sources (firewall)
configure_trusted_sources() {
    local cluster_id="$1"
    local droplet_id="$2"

    step "Configuring trusted sources..."

    # Get Droplet private IP
    local droplet_ip
    droplet_ip=$(doctl compute droplet get "$droplet_id" --format PrivateIPv4 --no-header)

    if [ -n "$droplet_ip" ]; then
        # Add Droplet as trusted source
        doctl databases firewalls append "$cluster_id" --rule "droplet:${droplet_id}"
        success "Added Droplet as trusted source"
    else
        warning "Could not get Droplet private IP, database may not be accessible"
    fi
}

# Display database cluster info
show_database_info() {
    local cluster_id="$1"

    echo ""
    echo "Managed PostgreSQL Cluster Information:"
    echo "========================================"
    doctl databases get "$cluster_id" --format ID,Name,Engine,Version,Status,Region,Size
    echo ""
    echo "Connection Pools:"
    doctl databases pool list "$cluster_id" --format Name,Size,Mode,Database,User
    echo ""
    echo "Dashboard: https://cloud.digitalocean.com/databases/${cluster_id}"
    echo ""
}
```

Make the file executable.
</action>
<verify>
Run: `bash -n scripts/lib/managed-db-helpers.sh && echo "Syntax OK" && grep -c "^[a-z_]*() {" scripts/lib/managed-db-helpers.sh`
Expected: "Syntax OK" and count of 9 or more function definitions.
</verify>
<done>scripts/lib/managed-db-helpers.sh contains create_managed_database, create_connection_pool, get_connection_string, save_connection_string, and related helper functions.</done>
</task>

<task type="auto">
  <name>Task 2: Enhance compose.digitalocean.yaml for managed PostgreSQL</name>
  <files>docker/compose.digitalocean.yaml</files>
  <action>
Replace the existing compose.digitalocean.yaml with an enhanced version that supports both self-hosted and managed PostgreSQL:

```yaml
# FreshTrack Pro DigitalOcean Deployment Overlay
# Usage: docker compose -f docker-compose.yml -f compose.prod.yaml -f compose.digitalocean.yaml up -d
#
# This overlay supports two database modes:
# 1. Self-hosted PostgreSQL (default) - Uses containerized PostgreSQL + PgBouncer
# 2. Managed PostgreSQL - Uses DigitalOcean Managed Database (set USE_MANAGED_DB=true)
#
# To switch modes, set environment variable before deployment:
#   export USE_MANAGED_DB=true
#   docker compose -f ... up -d

# ===========================================
# MANAGED POSTGRESQL MODE
# ===========================================
# When using DigitalOcean Managed PostgreSQL:
# 1. Comment out postgres and pgbouncer services below (or let them fail to start)
# 2. Ensure do_database_url secret contains the pooler connection string
# 3. Connection string format: postgresql://user:pass@host-pooler:25060/db?sslmode=require
#
# IMPORTANT: Always use the -pooler endpoint for managed databases!
# Direct connections bypass PgBouncer and exhaust the connection limit.

services:
  # ===========================================
  # PostgreSQL Database (Self-Hosted Mode)
  # ===========================================
  # These services are used when USE_MANAGED_DB=false (default)
  # When using managed database, these can be commented out or will be overridden
  postgres:
    profiles:
      - self-hosted-db
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1GB
        reservations:
          cpus: '0.5'
          memory: 512MB
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 5
        window: 120s
    ports:
      - '127.0.0.1:5432:5432'

  # ===========================================
  # PgBouncer Connection Pooler (Self-Hosted Mode)
  # ===========================================
  pgbouncer:
    profiles:
      - self-hosted-db
    ports:
      - '127.0.0.1:6432:6432'

  # ===========================================
  # Redis (Cache, Jobs, PubSub)
  # ===========================================
  redis:
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512MB
        reservations:
          cpus: '0.25'
          memory: 256MB
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 5
        window: 120s
    ports:
      - '127.0.0.1:6379:6379'

  # ===========================================
  # MinIO (S3-Compatible Object Storage)
  # ===========================================
  # For DigitalOcean Spaces alternative, set USE_DO_SPACES=true
  # and configure S3_ENDPOINT in backend environment
  minio:
    profiles:
      - self-hosted-storage
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 1GB
        reservations:
          cpus: '0.25'
          memory: 512MB
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 5
        window: 120s
    ports:
      - '127.0.0.1:9000:9000'
      - '127.0.0.1:9001:9001'

  # ===========================================
  # Backend API
  # ===========================================
  # Database connection is determined by secrets:
  # - Self-hosted: Uses database_url secret (connects to local pgbouncer)
  # - Managed: Uses do_database_url secret (connects to DO managed pooler)
  #
  # The deploy script sets up the appropriate secret based on USE_MANAGED_DB
  # backend:
  #   environment:
  #     # Self-hosted PostgreSQL (via PgBouncer):
  #     # DATABASE_URL_FILE: /run/secrets/database_url
  #     #
  #     # Managed PostgreSQL (via DO PgBouncer):
  #     # DATABASE_URL_FILE: /run/secrets/do_database_url
  #     #
  #     # The deployment script copies the correct URL to database_url
  #     DATABASE_URL_FILE: /run/secrets/database_url
  #
  #     # Stack Auth
  #     STACK_AUTH_SECRET_KEY_FILE: /run/secrets/stack_auth_secret
  #
  #     # DigitalOcean Spaces (if USE_DO_SPACES=true)
  #     # S3_ENDPOINT: https://${DO_SPACES_REGION}.digitaloceanspaces.com
  #     # S3_REGION: ${DO_SPACES_REGION}
  #     # S3_BUCKET: ${DO_SPACES_BUCKET}
  #     # S3_ACCESS_KEY_FILE: /run/secrets/spaces_access_key
  #     # S3_SECRET_KEY_FILE: /run/secrets/spaces_secret_key
  #   secrets:
  #     - database_url
  #     - stack_auth_secret
  #     # Uncomment for DigitalOcean Spaces:
  #     # - spaces_access_key
  #     # - spaces_secret_key

# ===========================================
# Secrets Configuration
# ===========================================
# Secrets are provided by Infisical Agent which exports them to /var/infisical/secrets/
# See deployment documentation for Infisical setup
#
# For managed PostgreSQL, the deployment script:
# 1. Creates the managed database cluster
# 2. Retrieves the pooler connection string
# 3. Saves it to /var/infisical/secrets/database_url (or do_database_url)
secrets:
  postgres_password:
    file: /var/infisical/secrets/postgres_password
  database_url:
    file: /var/infisical/secrets/database_url
  stack_auth_secret:
    file: /var/infisical/secrets/stack_auth_secret
  # DigitalOcean Managed PostgreSQL connection string
  # Contains: postgresql://user:pass@host-pooler:25060/db?sslmode=require
  do_database_url:
    file: /var/infisical/secrets/do_database_url
  # DigitalOcean Spaces credentials (if USE_DO_SPACES=true)
  spaces_access_key:
    file: /var/infisical/secrets/spaces_access_key
  spaces_secret_key:
    file: /var/infisical/secrets/spaces_secret_key

# ===========================================
# DigitalOcean VPC Private Networking
# ===========================================
# When Droplet and managed database are in the same VPC:
# - Traffic uses private network (no bandwidth charges)
# - Lower latency (~1ms vs 5-10ms)
# - Improved security (not exposed to public internet)
#
# The deployment script automatically places both in the same VPC.
```

Key changes:

1. Add Docker Compose profiles for conditional service loading (self-hosted-db, self-hosted-storage)
2. Add do_database_url and spaces_access_key/secret_key secrets
3. Include comprehensive comments explaining managed vs self-hosted modes
4. Document the pooler endpoint requirement prominently
   </action>
   <verify>
   Run: `grep -c "do_database_url\|USE_MANAGED_DB\|pooler" docker/compose.digitalocean.yaml`
   Expected: 5 or more matches showing managed database support is documented.
   </verify>
   <done>compose.digitalocean.yaml supports both self-hosted and managed PostgreSQL with clear documentation on mode switching.</done>
   </task>

<task type="auto">
  <name>Task 3: Integrate managed database functions into deploy-digitalocean.sh</name>
  <files>scripts/deploy-digitalocean.sh</files>
  <action>
Add managed database provisioning to deploy-digitalocean.sh. Find the section after `source "${SCRIPT_DIR}/lib/doctl-helpers.sh"` and add:

```bash
# Source managed database helpers if using managed DB
if [ "${USE_MANAGED_DB:-false}" = "true" ]; then
    source "${SCRIPT_DIR}/lib/managed-db-helpers.sh" 2>/dev/null || {
        error "managed-db-helpers.sh not found. Required when USE_MANAGED_DB=true."
        exit 1
    }
fi
```

Then add a function to handle managed database setup:

```bash
# ===========================================
# Managed Database Setup
# ===========================================

setup_managed_database() {
    if [ "${USE_MANAGED_DB:-false}" != "true" ]; then
        info "Using self-hosted PostgreSQL (containerized)"
        return 0
    fi

    step "Setting up DigitalOcean Managed PostgreSQL..."

    # Get VPC UUID for private networking
    local vpc_uuid
    vpc_uuid=$(ensure_vpc "freshtrack-vpc" "$DO_REGION")

    # Create or get existing database cluster
    create_managed_database "freshtrack-db" "$DO_REGION" "$DO_DB_SIZE" "$vpc_uuid" || {
        error "Failed to create managed database"
        return 1
    }

    # Configure firewall to allow Droplet access
    if [ -n "$DROPLET_ID" ]; then
        configure_trusted_sources "$DB_CLUSTER_ID" "$DROPLET_ID"
    fi

    # Save connection string to secrets
    save_connection_string "$DB_CLUSTER_ID" "/opt/freshtrack-pro/secrets/database_url"

    # Display database info
    show_database_info "$DB_CLUSTER_ID"

    success "Managed PostgreSQL configured"
}
```

Add `setup_managed_database` call in the main() function after Droplet provisioning and cloud-init wait:

```bash
    # ... existing code ...

    # Setup managed database if enabled
    setup_managed_database || {
        warning "Managed database setup failed, continuing with self-hosted mode"
    }

    # ... rest of deployment ...
```

Also add a --setup-managed-db flag handler for standalone database setup:

```bash
        --setup-managed-db)
            SETUP_MANAGED_DB_ONLY=true
            USE_MANAGED_DB=true
            shift
            ;;
```

And handle it in main():

```bash
    # Handle standalone managed DB setup
    if [ "${SETUP_MANAGED_DB_ONLY:-false}" = "true" ]; then
        load_config
        validate_doctl_auth || exit 1
        setup_managed_database || exit 1
        echo ""
        echo "Managed database setup complete."
        echo "Update DATABASE_URL in your application to use the managed database."
        exit 0
    fi
```

  </action>
  <verify>
Run: `grep -c "USE_MANAGED_DB\|setup_managed_database\|managed-db-helpers" scripts/deploy-digitalocean.sh`
Expected: 5 or more matches showing managed database integration.
  </verify>
  <done>deploy-digitalocean.sh integrates managed database helpers and provisions managed PostgreSQL when USE_MANAGED_DB=true.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Helper library syntax:**

   ```bash
   bash -n scripts/lib/managed-db-helpers.sh
   # Should exit 0
   ```

2. **Compose file validation:**

   ```bash
   docker compose -f docker-compose.yml -f docker/compose.prod.yaml -f docker/compose.digitalocean.yaml config --quiet && echo "Valid"
   # Should print "Valid" (or validate without errors)
   ```

3. **Managed DB function availability:**

   ```bash
   grep "create_managed_database\|get_connection_string" scripts/lib/managed-db-helpers.sh | wc -l
   # Should be 4+ (function definitions and usages)
   ```

4. **Integration with main script:**

   ```bash
   grep "USE_MANAGED_DB" scripts/deploy-digitalocean.sh | wc -l
   # Should be 3 or more references
   ```

5. **Pooler endpoint enforcement:**
   ```bash
   grep -i "pooler" docker/compose.digitalocean.yaml scripts/lib/managed-db-helpers.sh | wc -l
   # Should be 3+ showing pooler is documented and enforced
   ```
   </verification>

<success_criteria>

- scripts/lib/managed-db-helpers.sh has 9+ functions for managed database provisioning
- compose.digitalocean.yaml includes do_database_url secret and managed DB documentation
- deploy-digitalocean.sh conditionally loads managed-db-helpers.sh
- Connection string uses pooler endpoint (not direct connection)
- SSL mode is enforced (sslmode=require)
- VPC private networking is used when available
  </success_criteria>

<output>
After completion, create `.planning/phases/12-digitalocean-deployment/12-03-SUMMARY.md`
</output>
