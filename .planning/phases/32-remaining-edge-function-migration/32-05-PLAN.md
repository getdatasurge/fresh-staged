---
phase: 32-remaining-edge-function-migration
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/routers/reports.router.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Reports export returns real sensor reading data from database"
    - "CSV export includes timestamp, unit name, temperature, humidity columns"
    - "HTML export includes formatted report with data table"
    - "Exports filter by date range (startDate/endDate)"
    - "Exports filter by siteId when provided"
    - "Exports filter by unitId when provided"
  artifacts:
    - path: "backend/src/routers/reports.router.ts"
      provides: "Implemented reports.export procedure with real database queries"
      contains: "sensorReadings"
  key_links:
    - from: "backend/src/routers/reports.router.ts"
      to: "sensorReadings table"
      via: "Drizzle ORM query"
      pattern: "db\\.select.*sensorReadings"
---

<objective>
Implement the reports.export tRPC procedure with real database queries

Purpose: Close Gap 1 from 32-VERIFICATION.md - the frontend migration is complete but backend returns placeholder content instead of real data.

Output: Working reports.export that queries sensor_readings and manual_temperature_logs tables and formats as CSV or HTML.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-remaining-edge-function-migration/32-VERIFICATION.md

# Existing stub to implement
@backend/src/routers/reports.router.ts

# Database schema for data sources
@backend/src/db/schema/telemetry.ts
@backend/src/db/schema/hierarchy.ts

# Pattern reference from existing router
@backend/src/routers/alerts.router.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement reports.export with database queries</name>
  <files>backend/src/routers/reports.router.ts</files>
  <action>
Replace the TODO placeholder in reports.router.ts with actual implementation:

1. Add imports for db, schema tables, and Drizzle operators:
   - Import db from '../db/index.js'
   - Import sensorReadings, manualTemperatureLogs from schema
   - Import units, areas, sites from hierarchy schema
   - Import eq, and, gte, lte, inArray from drizzle-orm

2. Build the query based on reportType:
   - 'daily', 'exceptions', 'compliance' -> query sensorReadings
   - 'manual' -> query manualTemperatureLogs

3. Filter logic:
   - Always filter by date range: recordedAt >= startDate AND recordedAt <= endDate
   - If unitId provided: filter by unitId directly
   - If siteId provided (no unitId): subquery to get all unitIds for that site via units -> areas -> sites
   - Otherwise: subquery for all unitIds in the organization via units -> areas -> sites -> organizationId

4. Query structure for sensorReadings:
   ```typescript
   const readings = await db.select({
     timestamp: sensorReadings.recordedAt,
     unitName: units.name,
     temperature: sensorReadings.temperature,
     humidity: sensorReadings.humidity,
   })
   .from(sensorReadings)
   .innerJoin(units, eq(sensorReadings.unitId, units.id))
   .where(and(...conditions))
   .orderBy(sensorReadings.recordedAt)
   ```

5. Format CSV:
   ```typescript
   const csvHeader = 'timestamp,unit,temperature,humidity'
   const csvRows = readings.map(r =>
     `${r.timestamp.toISOString()},${r.unitName},${r.temperature},${r.humidity ?? ''}`
   )
   const content = [csvHeader, ...csvRows].join('\n')
   ```

6. Format HTML:
   ```typescript
   const html = `<!DOCTYPE html>
   <html>
   <head><title>${reportType} Report</title>
   <style>
     body { font-family: sans-serif; margin: 20px; }
     table { border-collapse: collapse; width: 100%; }
     th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
     th { background: #f5f5f5; }
   </style>
   </head>
   <body>
   <h1>${reportType.charAt(0).toUpperCase() + reportType.slice(1)} Report</h1>
   <p>${startDate} to ${endDate}</p>
   <table>
   <tr><th>Timestamp</th><th>Unit</th><th>Temperature</th><th>Humidity</th></tr>
   ${readings.map(r => `<tr><td>${r.timestamp.toISOString()}</td><td>${r.unitName}</td><td>${r.temperature}</td><td>${r.humidity ?? '-'}</td></tr>`).join('')}
   </table>
   </body>
   </html>`
   ```

7. Handle 'exceptions' reportType by adding WHERE clause for out-of-range temps (join with units.tempMin/tempMax)

8. Error handling: Wrap in try/catch, throw TRPCError with INTERNAL_SERVER_ERROR on failure
  </action>
  <verify>
Run TypeScript check:
```bash
cd /home/swoop/swoop-claude-projects/fresh-staged/backend && npx tsc --noEmit
```

Verify the file has real queries:
```bash
grep -n "sensorReadings\|db.select" backend/src/routers/reports.router.ts
```

Should show db.select calls and sensorReadings references, NOT the TODO placeholder.
  </verify>
  <done>
reports.export procedure queries database for real sensor data, formats as CSV or HTML, and filters by date range and optional siteId/unitId. No more TODO placeholder or hardcoded content.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. reports.router.ts contains db.select queries
3. sensorReadings table is queried
4. CSV format includes proper header and data rows
5. HTML format includes table with data
6. Filters for date range, siteId, unitId are implemented
</verification>

<success_criteria>
- [ ] reports.export returns real data from sensorReadings table
- [ ] CSV export has timestamp,unit,temperature,humidity columns with data
- [ ] HTML export has formatted table with data rows
- [ ] Date range filtering works (startDate to endDate)
- [ ] Optional siteId filter queries units in that site
- [ ] Optional unitId filter queries that specific unit
- [ ] TypeScript compiles
</success_criteria>

<output>
After completion, create `.planning/phases/32-remaining-edge-function-migration/32-05-SUMMARY.md`
</output>
