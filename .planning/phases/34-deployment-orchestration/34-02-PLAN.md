---
phase: 34-deployment-orchestration
plan: 02
type: execute
wave: 2
depends_on: ['34-01']
files_modified:
  - scripts/lib/deploy-lib.sh
  - scripts/deploy-orchestrated.sh
autonomous: true

must_haves:
  truths:
    - 'User sees deployment wait for all services to report healthy before completion'
    - 'User can observe 3 consecutive health passes required before proceeding'
    - 'User sees clear feedback during health wait phase'
  artifacts:
    - path: 'scripts/lib/deploy-lib.sh'
      provides: 'Enhanced health wait with 3-consecutive-pass logic'
      contains: 'consecutive'
    - path: 'scripts/deploy-orchestrated.sh'
      provides: 'Integrated health wait phase'
      contains: 'wait_for_healthy_services'
  key_links:
    - from: 'scripts/deploy-orchestrated.sh'
      to: 'scripts/lib/deploy-lib.sh'
      via: 'calls wait_for_healthy_services'
      pattern: 'wait_for_healthy_services'
    - from: 'scripts/lib/deploy-lib.sh'
      to: 'backend /health endpoint'
      via: 'curl health check'
      pattern: 'curl.*localhost:3000/health'
---

<objective>
Implement robust health wait logic requiring 3 consecutive health passes before deployment completion

Purpose: Ensure all services are truly healthy (not just momentarily responsive) before declaring deployment complete. Three consecutive passes prevents false positives from transient responses.

Output:

- Enhanced wait_for_healthy_services() function in deploy-lib.sh
- Integration with phase_health_wait() in deploy-orchestrated.sh
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan output

@.planning/phases/34-deployment-orchestration/34-01-SUMMARY.md

# Existing health check patterns

@scripts/deploy.sh
@scripts/health-check.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement 3-consecutive-pass health wait function</name>
  <files>scripts/lib/deploy-lib.sh</files>
  <action>
Add `wait_for_healthy_services()` function to scripts/lib/deploy-lib.sh.

Configuration constants (add near top of file after sourcing preflight-lib.sh):

```bash
# Health check configuration
HEALTH_CHECK_URL="${HEALTH_CHECK_URL:-http://localhost:3000/health}"
HEALTH_CHECK_INTERVAL="${HEALTH_CHECK_INTERVAL:-5}"      # Seconds between checks
HEALTH_CHECK_TIMEOUT="${HEALTH_CHECK_TIMEOUT:-10}"       # Curl timeout per check
HEALTH_CHECK_MAX_ATTEMPTS="${HEALTH_CHECK_MAX_ATTEMPTS:-60}"  # Max attempts (5 min total)
HEALTH_CONSECUTIVE_REQUIRED="${HEALTH_CONSECUTIVE_REQUIRED:-3}"  # Consecutive passes needed
```

Implement function:

```bash
# Wait for all services to be healthy with 3-consecutive-pass requirement
# Returns: 0 when healthy, 1 on timeout
# Satisfies: DEPLOY-05
wait_for_healthy_services() {
    local consecutive_passes=0
    local total_attempts=0
    local last_response=""

    step "Waiting for services to be healthy..."
    echo "  Checking: $HEALTH_CHECK_URL"
    echo "  Requirement: $HEALTH_CONSECUTIVE_REQUIRED consecutive passes"
    echo "  Max attempts: $HEALTH_CHECK_MAX_ATTEMPTS ($(( HEALTH_CHECK_MAX_ATTEMPTS * HEALTH_CHECK_INTERVAL / 60 )) minutes)"
    echo ""

    while [[ $total_attempts -lt $HEALTH_CHECK_MAX_ATTEMPTS ]]; do
        total_attempts=$((total_attempts + 1))

        # Attempt health check
        local http_code
        local response
        response=$(curl -s --max-time "$HEALTH_CHECK_TIMEOUT" "$HEALTH_CHECK_URL" 2>/dev/null) || response=""
        http_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time "$HEALTH_CHECK_TIMEOUT" "$HEALTH_CHECK_URL" 2>/dev/null) || http_code="000"

        # Check for healthy response
        if [[ "$http_code" == "200" ]] && echo "$response" | grep -q '"status":"healthy"'; then
            consecutive_passes=$((consecutive_passes + 1))
            echo -e "  [${GREEN}PASS${NC}] Attempt $total_attempts: HTTP $http_code - consecutive: $consecutive_passes/$HEALTH_CONSECUTIVE_REQUIRED"

            if [[ $consecutive_passes -ge $HEALTH_CONSECUTIVE_REQUIRED ]]; then
                echo ""
                success "Services healthy after $consecutive_passes consecutive passes!"
                return 0
            fi
        else
            # Reset consecutive counter on failure
            if [[ $consecutive_passes -gt 0 ]]; then
                warning "Consecutive pass streak reset (was $consecutive_passes)"
            fi
            consecutive_passes=0

            if [[ "$http_code" == "000" ]]; then
                echo -e "  [${RED}FAIL${NC}] Attempt $total_attempts: Connection failed"
            else
                echo -e "  [${RED}FAIL${NC}] Attempt $total_attempts: HTTP $http_code"
            fi
        fi

        # Wait before next attempt
        sleep "$HEALTH_CHECK_INTERVAL"
    done

    # Timeout reached
    echo ""
    error "Health check timeout after $total_attempts attempts"
    echo ""
    echo "Services did not achieve $HEALTH_CONSECUTIVE_REQUIRED consecutive healthy responses."
    echo ""
    echo "Troubleshooting:"
    echo "  1. Check backend logs: docker compose logs backend"
    echo "  2. Check service status: docker compose ps"
    echo "  3. Test health endpoint: curl -v $HEALTH_CHECK_URL"
    echo ""
    return 1
}
```

Also add helper function to check individual service health:

```bash
# Check if a specific service container is healthy
# Args: $1 = service name (e.g., "backend", "postgres")
# Returns: 0 if healthy, 1 if not
check_service_health() {
    local service="$1"
    local status

    status=$(docker compose -f docker-compose.yml -f compose.production.yaml ps --format json "$service" 2>/dev/null | jq -r '.[0].Health // "none"' 2>/dev/null) || status="unknown"

    case "$status" in
        healthy)
            return 0
            ;;
        starting)
            return 1
            ;;
        unhealthy|none|unknown)
            return 1
            ;;
        *)
            return 1
            ;;
    esac
}
```

Update self-test block to include health function tests (mock tests that don't require running services):

- Test that HEALTH_CONSECUTIVE_REQUIRED defaults to 3
- Test that wait_for_healthy_services function is defined
  </action>
  <verify>
  `grep "consecutive" scripts/lib/deploy-lib.sh` - shows consecutive pass logic.
  `grep "HEALTH_CONSECUTIVE_REQUIRED" scripts/lib/deploy-lib.sh` - shows configurable threshold.
  `bash scripts/lib/deploy-lib.sh` - self-tests pass (including new tests).
  </verify>
  <done>
  wait_for_healthy_services() function exists in deploy-lib.sh. Requires 3 consecutive healthy responses. Resets counter on any failure. Provides clear feedback during wait. Configurable via environment variables.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Integrate health wait into deployment orchestrator</name>
  <files>scripts/deploy-orchestrated.sh</files>
  <action>
Update phase_health_wait() function in scripts/deploy-orchestrated.sh to use the new wait_for_healthy_services() function.

Replace the placeholder health wait implementation:

```bash
# Phase: Wait for all services to be healthy
# Uses 3-consecutive-pass requirement from deploy-lib.sh
phase_health_wait() {
    step "Phase: Health Wait"
    echo "Waiting for all services to report healthy status..."
    echo ""

    # First, give services a moment to start
    echo "Allowing services 10 seconds to initialize..."
    sleep 10

    # Run the 3-consecutive-pass health check
    if ! wait_for_healthy_services; then
        error "Health wait phase failed"
        echo ""
        echo "The deployment has started but services are not healthy."
        echo "This checkpoint will be saved - you can resume after fixing the issue."
        return 1
    fi

    # Additional service checks (optional, informational)
    echo ""
    step "Verifying individual service status..."

    local services=("backend" "postgres" "redis" "frontend")
    local all_healthy=true

    for service in "${services[@]}"; do
        if check_service_health "$service"; then
            success "$service: healthy"
        else
            warning "$service: not reporting healthy (may still be starting)"
            # Don't fail on individual service checks - the main health endpoint passed
        fi
    done

    echo ""
    success "Health wait phase complete"
    return 0
}
```

Also add a final summary block after all phases complete that shows service URLs:

```bash
# Add to end of main() after all checkpoints pass:

display_deployment_summary() {
    local domain="${DOMAIN:-localhost}"

    echo ""
    echo -e "${GREEN}========================================"
    echo "       Deployment Complete!"
    echo "========================================${NC}"
    echo ""
    echo "Your FreshTrack Pro instance is ready!"
    echo ""
    echo -e "${BLUE}Service URLs:${NC}"
    echo "  Dashboard:    https://${domain}"
    echo "  API:          https://${domain}/api"
    echo "  Health:       https://${domain}/health"
    echo "  Monitoring:   https://monitoring.${domain}"
    echo "  Status Page:  https://status.${domain}"
    echo ""
    echo -e "${BLUE}Management Commands:${NC}"
    echo "  View logs:    docker compose logs -f"
    echo "  View status:  docker compose ps"
    echo "  Stop:         docker compose down"
    echo "  Restart:      docker compose restart"
    echo ""
    echo -e "${BLUE}Deployment State:${NC}"
    echo "  State file:   ${STATE_DIR}/.deployment-state"
    echo "  Redeploy:     ./scripts/deploy-orchestrated.sh --fresh"
    echo "  Resume:       ./scripts/deploy-orchestrated.sh --resume"
    echo ""
}
```

Call `display_deployment_summary` at the end of main() after the last checkpoint.
</action>
<verify>
`grep "wait_for_healthy_services" scripts/deploy-orchestrated.sh` - function is called.
`grep "consecutive" scripts/deploy-orchestrated.sh` - mentions consecutive in comments.
`./scripts/deploy-orchestrated.sh --help` - still shows help correctly.
`bash -n scripts/deploy-orchestrated.sh` - syntax check passes.
</verify>
<done>
phase_health_wait() calls wait_for_healthy_services() from deploy-lib.sh. Deployment waits for 3 consecutive healthy responses. User sees clear progress feedback during health wait. Final deployment summary shows service URLs.
</done>
</task>

</tasks>

<verification>
Overall plan verification:
1. `grep -c "consecutive" scripts/lib/deploy-lib.sh` - multiple occurrences
2. `grep "HEALTH_CONSECUTIVE_REQUIRED.*3" scripts/lib/deploy-lib.sh` - default is 3
3. `grep "wait_for_healthy_services" scripts/deploy-orchestrated.sh` - function called
4. `bash scripts/lib/deploy-lib.sh` - self-tests pass
5. `bash -n scripts/deploy-orchestrated.sh` - syntax valid
6. Review output format matches expected: PASS/FAIL indicators with consecutive count
</verification>

<success_criteria>

- wait_for_healthy_services() exists with 3-consecutive-pass requirement
- Counter resets to 0 on any failed health check
- Clear progress feedback shows "consecutive: N/3" format
- Configurable via HEALTH_CONSECUTIVE_REQUIRED environment variable
- phase_health_wait() in orchestrator calls wait_for_healthy_services()
- Deployment summary displays service URLs on completion
  </success_criteria>

<output>
After completion, create `.planning/phases/34-deployment-orchestration/34-02-SUMMARY.md`
</output>
