---
phase: 34-deployment-orchestration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/lib/deploy-lib.sh
  - scripts/deploy-orchestrated.sh
autonomous: true

must_haves:
  truths:
    - "User can run deployment script that orchestrates the full deployment"
    - "User can see checkpoint markers created at each deployment phase"
    - "User can resume deployment from last checkpoint after a failure"
    - "User can observe Docker Compose running with production overlay configuration"
    - "Placeholder health wait exists (enhanced with 3-consecutive-pass logic in Plan 02)"
  artifacts:
    - path: "scripts/lib/deploy-lib.sh"
      provides: "Deployment state management library"
      min_lines: 100
      note: "Base implementation ~100 lines; enhanced to ~160 lines in Plan 02 with health wait functions"
      contains: "deployment_checkpoint"
    - path: "scripts/deploy-orchestrated.sh"
      provides: "Main deployment orchestration entry point"
      min_lines: 80
      contains: "run_step"
  key_links:
    - from: "scripts/deploy-orchestrated.sh"
      to: "scripts/lib/deploy-lib.sh"
      via: "source"
      pattern: "source.*deploy-lib\\.sh"
    - from: "scripts/deploy-orchestrated.sh"
      to: "docker compose commands"
      via: "same deployment sequence as deploy.sh"
      pattern: "docker compose.*production\\.yaml"
      note: "Uses same docker compose commands as deploy.sh; orchestrator adds checkpoint tracking. deploy.sh remains for simple one-shot deployments without checkpoint recovery."
    - from: "scripts/lib/deploy-lib.sh"
      to: "scripts/lib/preflight-lib.sh"
      via: "source for checkpoint system"
      pattern: "source.*preflight-lib\\.sh"
---

<objective>
Create deployment orchestration library and entry script with checkpoint-based state tracking

Purpose: Enable checkpoint-based deployment with resume capability from any failure point. Uses the same docker compose deployment sequence as deploy.sh but adds checkpoint tracking for each phase. deploy.sh remains available for simple one-shot deployments.

Output:
- scripts/lib/deploy-lib.sh - Deployment state management extending preflight-lib.sh checkpoint system
- scripts/deploy-orchestrated.sh - Main orchestration script with checkpoint-tracked deployment phases
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing deployment infrastructure
@scripts/lib/preflight-lib.sh
@scripts/lib/prereq-lib.sh
@scripts/lib/config-lib.sh
@scripts/deploy.sh
@compose.production.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deployment state management library</name>
  <files>scripts/lib/deploy-lib.sh</files>
  <action>
Create scripts/lib/deploy-lib.sh that extends preflight-lib.sh checkpoint system for deployment-specific state tracking.

Source preflight-lib.sh at the start to inherit checkpoint functions (checkpoint_done, checkpoint_set, checkpoint_clear, run_step, STATE_DIR).

Define deployment phase constants:
```bash
DEPLOY_PHASES=(
  "preflight"
  "prerequisites"
  "configuration"
  "pull-images"
  "build-backend"
  "database-start"
  "database-migrate"
  "services-start"
  "health-wait"
  "cleanup"
)
```

Implement state tracking functions:

1. `get_deployment_state()` - Returns current deployment state from STATE_DIR/.deployment-state file. Format: `phase:status:timestamp`. Returns "none:not-started:0" if no state file exists.

2. `set_deployment_state()` - Args: $1=phase, $2=status (running|completed|failed). Writes to STATE_DIR/.deployment-state with ISO timestamp. Also writes human-readable STATE_DIR/.deployment-status for debugging.

3. `deployment_checkpoint()` - Args: $1=phase_name, $2=function_to_run. Wrapper around run_step() that also calls set_deployment_state before and after execution. On success, marks completed. On failure, marks failed and saves error context.

4. `get_resume_point()` - Reads .deployment-state and returns the first incomplete phase, or "complete" if all done. Used by orchestrator to determine where to resume.

5. `clear_deployment_state()` - Clears all deployment checkpoints and state files. Calls checkpoint_clear_all() plus removes .deployment-state and .deployment-status.

6. `show_deployment_status()` - Pretty-prints current deployment state showing completed phases (green), current phase (yellow), and pending phases (dim).

Include idempotency: If a checkpoint is already complete, skip re-execution (inherited from run_step behavior).

Add self-test block at bottom (when run directly) that tests:
- State file creation/reading: Call set_deployment_state "preflight" "running", verify STATE_DIR/.deployment-state contains "preflight:running"
- Phase progression: Call set_deployment_state "preflight" "completed", then call get_resume_point, verify returns next incomplete phase
- Resume point detection: After setting multiple phases complete, verify get_resume_point returns correct first incomplete phase
- State clearing: Call clear_deployment_state, verify .deployment-state file is removed

Use consistent style with preflight-lib.sh (colors, step/success/error helpers inherited via source).
  </action>
  <verify>
Run `bash scripts/lib/deploy-lib.sh` directly - self-tests should pass, specifically:
- Test output shows "Testing state file creation..." and passes
- Test output shows "Testing get_resume_point..." and passes
- Test output shows "Testing clear_deployment_state..." and passes
- Test output shows "All deploy-lib.sh tests passed"

Verify `source scripts/lib/deploy-lib.sh` works without errors.
Check that STATE_DIR/.deployment-state is created when set_deployment_state is called (visible in test output).
  </verify>
  <done>
deploy-lib.sh exists with deployment_checkpoint(), get_resume_point(), set_deployment_state(), show_deployment_status() functions. Self-tests pass including checkpoint recovery tests. Library sources without error.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create deployment orchestration entry script</name>
  <files>scripts/deploy-orchestrated.sh</files>
  <action>
Create scripts/deploy-orchestrated.sh as the main deployment entry point that orchestrates all phases with checkpoint tracking.

Script structure:

```bash
#!/usr/bin/env bash
# FreshTrack Pro One-Click Deployment Orchestrator
# Usage: ./scripts/deploy-orchestrated.sh [--resume] [--fresh] [--status]
#
# This script provides checkpoint-based deployment with resume capability.
# It uses the same deployment sequence as deploy.sh but adds state tracking.
# deploy.sh remains available for simple one-shot deployments without checkpoints.
set -euo pipefail
```

Parse arguments:
- `--resume` (default): Resume from last checkpoint
- `--fresh`: Clear all checkpoints and start from beginning
- `--status`: Show current deployment status and exit
- `--help`: Show usage

Source the library chain:
```bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/lib/deploy-lib.sh"
# deploy-lib.sh sources preflight-lib.sh which sets up error handling
```

Define phase functions that use the SAME deployment sequence as deploy.sh:

Note: These functions execute the same docker compose commands as deploy.sh.
The orchestrator adds checkpoint tracking; deploy.sh remains for one-shot deployments.

1. `phase_preflight()` - Run system validation: Call `run_preflight_checks "$DOMAIN"` from preflight-lib.sh (same as deploy.sh STEP 1 calling health-check.sh)

2. `phase_prerequisites()` - Install Docker, firewall, fail2ban: Call `install_all_prerequisites` from prereq-lib.sh

3. `phase_configuration()` - Interactive config if .env.production missing: Check if .env.production exists. If not, call `run_interactive_configuration` from config-lib.sh. If exists, skip with message.

4. `phase_pull_images()` - Pull Docker images (same as deploy.sh STEP 2): Run `docker compose -f docker-compose.yml -f compose.production.yaml pull`

5. `phase_build_backend()` - Build backend (same as deploy.sh STEP 3): Run `docker compose -f docker-compose.yml -f compose.production.yaml build backend`

6. `phase_database_start()` - Start database services (same as deploy.sh STEP 4 part 1): Run `docker compose -f docker-compose.yml -f compose.production.yaml up -d postgres redis`

7. `phase_database_migrate()` - Run migrations (same as deploy.sh STEP 4 part 2): Wait for postgres ready (pg_isready loop), then run `docker compose -f docker-compose.yml -f compose.production.yaml run --rm backend pnpm db:migrate:prod`

8. `phase_services_start()` - Start all services (same as deploy.sh STEP 5): Run `docker compose -f docker-compose.yml -f compose.production.yaml up -d`

9. `phase_health_wait()` - Wait for healthy (placeholder, enhanced in Plan 02): Simple curl loop to /health endpoint. Plan 02 adds 3-consecutive-pass logic.

10. `phase_cleanup()` - Cleanup (same as deploy.sh STEP 8): Run `docker image prune -f --filter "dangling=true"`

Main orchestration loop:
```bash
main() {
  echo "========================================"
  echo "FreshTrack Pro Deployment Orchestrator"
  echo "========================================"

  # Handle --fresh flag
  if [[ "${FRESH:-false}" == "true" ]]; then
    clear_deployment_state
  fi

  # Show current status
  show_deployment_status

  # Get resume point
  local resume_point
  resume_point=$(get_resume_point)

  if [[ "$resume_point" == "complete" ]]; then
    success "Deployment already complete!"
    echo "Use --fresh to redeploy from scratch."
    exit 0
  fi

  # Run each phase with checkpoint tracking
  deployment_checkpoint "preflight" phase_preflight
  deployment_checkpoint "prerequisites" phase_prerequisites
  deployment_checkpoint "configuration" phase_configuration
  deployment_checkpoint "pull-images" phase_pull_images
  deployment_checkpoint "build-backend" phase_build_backend
  deployment_checkpoint "database-start" phase_database_start
  deployment_checkpoint "database-migrate" phase_database_migrate
  deployment_checkpoint "services-start" phase_services_start
  deployment_checkpoint "health-wait" phase_health_wait
  deployment_checkpoint "cleanup" phase_cleanup

  # Mark deployment complete
  set_deployment_state "complete" "completed"

  echo ""
  echo "========================================"
  success "Deployment Complete!"
  echo "========================================"
  # Display URLs and next steps
}
```

Make executable: `chmod +x scripts/deploy-orchestrated.sh`
  </action>
  <verify>
`bash -n scripts/deploy-orchestrated.sh` - syntax check passes.
`./scripts/deploy-orchestrated.sh --help` shows usage.
`./scripts/deploy-orchestrated.sh --status` shows deployment status (should show "not started" on fresh system).
`grep "docker compose" scripts/deploy-orchestrated.sh | head -5` - shows docker compose commands matching deploy.sh patterns.
  </verify>
  <done>
deploy-orchestrated.sh exists with --resume, --fresh, --status flags. Sources deploy-lib.sh. Defines phase_* functions that use same deployment sequence as deploy.sh. Main loop uses deployment_checkpoint() for each phase. Script is executable.
  </done>
</task>

</tasks>

<verification>
Overall plan verification:
1. `ls -la scripts/lib/deploy-lib.sh scripts/deploy-orchestrated.sh` - both files exist
2. `bash scripts/lib/deploy-lib.sh` - self-tests pass (including checkpoint recovery tests)
3. `bash -n scripts/deploy-orchestrated.sh` - syntax valid
4. `./scripts/deploy-orchestrated.sh --status` - shows deployment status
5. Grep for checkpoint integration: `grep -l "deployment_checkpoint" scripts/deploy-orchestrated.sh`
6. Grep for preflight-lib integration: `grep "source.*preflight-lib" scripts/lib/deploy-lib.sh`
</verification>

<success_criteria>
- scripts/lib/deploy-lib.sh exists with deployment state management functions
- scripts/deploy-orchestrated.sh exists as executable entry point
- State tracking creates .deployment-state file in STATE_DIR
- Checkpoint system allows resume from any failure point (verified by self-tests)
- Docker Compose commands use production overlay: `-f docker-compose.yml -f compose.production.yaml`
- Uses same deployment sequence as deploy.sh (commands match, adds checkpoint tracking)
</success_criteria>

<output>
After completion, create `.planning/phases/34-deployment-orchestration/34-01-SUMMARY.md`
</output>
