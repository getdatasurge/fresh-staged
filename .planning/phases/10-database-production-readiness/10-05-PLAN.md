---
phase: 10-database-production-readiness
plan: 05
type: execute
wave: 3
depends_on: ['10-03']
files_modified:
  - docker/scripts/test-restore.sh
  - docs/DATABASE.md
autonomous: true

must_haves:
  truths:
    - 'Backup restoration procedure is documented step-by-step'
    - 'Restore script can restore backup to test database'
  artifacts:
    - path: 'docker/scripts/test-restore.sh'
      provides: 'Backup restoration test script'
      contains: 'pg_restore'
    - path: 'docs/DATABASE.md'
      provides: 'Restoration procedure documentation'
      contains: 'Restore Procedure'
  key_links:
    - from: 'docker/scripts/test-restore.sh'
      to: 'minio/postgres-backups'
      via: 'mc CLI download'
      pattern: 'mc cp.*postgres-backups'
---

<objective>
Create backup restoration script and document the restore procedure

Purpose: Ensure database can be recovered from backups with tested, documented procedures
Output: Restoration script for testing and comprehensive restore documentation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-database-production-readiness/10-RESEARCH.md

# Related files

@docker/scripts/backup-postgres.sh
@docs/DATABASE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backup restoration test script</name>
  <files>
    docker/scripts/test-restore.sh
  </files>
  <action>
Create docker/scripts/test-restore.sh:

```bash
#!/bin/bash
# PostgreSQL Backup Restoration Test Script
# Tests backup restoration to verify backup integrity
#
# Usage: ./test-restore.sh [backup_file]
# If no backup file specified, uses most recent backup
#
# Environment variables required:
# - POSTGRES_HOST, POSTGRES_USER, POSTGRES_PASSWORD
# - MINIO_ENDPOINT, MINIO_ACCESS_KEY, MINIO_SECRET_KEY

set -e

# Configuration
MINIO_BUCKET="postgres-backups"
RESTORE_DB="freshtrack_restore_test"
BACKUP_FILE="${1:-}"
LOCAL_BACKUP="/tmp/restore-test-backup"

# Logging
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

error_exit() {
    log "ERROR: $1"
    cleanup
    exit 1
}

cleanup() {
    log "Cleaning up..."
    rm -f "${LOCAL_BACKUP}" "${LOCAL_BACKUP}.tmp" 2>/dev/null || true

    # Drop test database if it exists
    if [ -n "${POSTGRES_HOST}" ]; then
        export PGPASSWORD="${POSTGRES_PASSWORD}"
        psql -h "${POSTGRES_HOST}" -U "${POSTGRES_USER}" -c "DROP DATABASE IF EXISTS ${RESTORE_DB};" 2>/dev/null || true
    fi
}

# Validate required environment variables
for var in POSTGRES_HOST POSTGRES_USER POSTGRES_PASSWORD MINIO_ENDPOINT MINIO_ACCESS_KEY MINIO_SECRET_KEY; do
    if [ -z "${!var}" ]; then
        error_exit "Required environment variable ${var} is not set"
    fi
done

# Set up trap for cleanup on exit
trap cleanup EXIT

# Configure MinIO client
log "Configuring MinIO client..."
mc alias set minio "${MINIO_ENDPOINT}" "${MINIO_ACCESS_KEY}" "${MINIO_SECRET_KEY}" --api S3v4 \
    || error_exit "Failed to configure MinIO client"

# If no backup file specified, find the most recent
if [ -z "$BACKUP_FILE" ]; then
    log "Finding most recent backup..."
    BACKUP_FILE=$(mc ls "minio/${MINIO_BUCKET}/" --json 2>/dev/null | \
        jq -r 'select(.key | test("freshtrack_.*\\.sql\\.gz$")) | .key' | \
        sort -r | head -1)

    if [ -z "$BACKUP_FILE" ]; then
        error_exit "No backup files found in MinIO bucket"
    fi
    log "Using most recent backup: ${BACKUP_FILE}"
fi

# Download backup from MinIO
log "Downloading backup: ${BACKUP_FILE}..."
mc cp "minio/${MINIO_BUCKET}/${BACKUP_FILE}" "${LOCAL_BACKUP}" \
    || error_exit "Failed to download backup from MinIO"

# Verify download
if [ ! -s "${LOCAL_BACKUP}" ]; then
    error_exit "Downloaded backup file is empty"
fi

BACKUP_SIZE=$(du -h "${LOCAL_BACKUP}" | cut -f1)
log "Downloaded backup: ${BACKUP_SIZE}"

# Set password for psql
export PGPASSWORD="${POSTGRES_PASSWORD}"

# Drop test database if exists from previous run
log "Preparing test database..."
psql -h "${POSTGRES_HOST}" -U "${POSTGRES_USER}" -c "DROP DATABASE IF EXISTS ${RESTORE_DB};" \
    || error_exit "Failed to drop existing test database"

# Create test database
psql -h "${POSTGRES_HOST}" -U "${POSTGRES_USER}" -c "CREATE DATABASE ${RESTORE_DB};" \
    || error_exit "Failed to create test database"

# Restore backup
# Backup is in custom format (-Fc), use pg_restore
log "Restoring backup to test database..."
pg_restore -h "${POSTGRES_HOST}" -U "${POSTGRES_USER}" -d "${RESTORE_DB}" "${LOCAL_BACKUP}" \
    || error_exit "pg_restore failed"

# Validate restoration - count tables
log "Validating restoration..."
TABLE_COUNT=$(psql -h "${POSTGRES_HOST}" -U "${POSTGRES_USER}" -d "${RESTORE_DB}" -t -c \
    "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';" | tr -d ' ')

if [ "$TABLE_COUNT" -lt 10 ]; then
    error_exit "Restore validation failed - only $TABLE_COUNT tables found (expected 10+)"
fi

log "Restoration validated: $TABLE_COUNT tables found"

# Count rows in key tables for additional validation
log "Checking key table row counts..."
for table in organizations users sites; do
    ROW_COUNT=$(psql -h "${POSTGRES_HOST}" -U "${POSTGRES_USER}" -d "${RESTORE_DB}" -t -c \
        "SELECT COUNT(*) FROM ${table};" 2>/dev/null | tr -d ' ' || echo "0")
    log "  ${table}: ${ROW_COUNT} rows"
done

# Success
log "=========================================="
log "RESTORE TEST SUCCESSFUL"
log "=========================================="
log "Backup file: ${BACKUP_FILE}"
log "Tables restored: ${TABLE_COUNT}"
log "Test database: ${RESTORE_DB} (will be cleaned up)"
log "=========================================="

# Cleanup is handled by trap
exit 0
```

Make the script executable:

```bash
chmod +x docker/scripts/test-restore.sh
```

  </action>
  <verify>
    ls -la docker/scripts/test-restore.sh
    head -50 docker/scripts/test-restore.sh
    grep "pg_restore" docker/scripts/test-restore.sh
    grep "RESTORE_DB" docker/scripts/test-restore.sh
  </verify>
  <done>
    docker/scripts/test-restore.sh created and executable
    Script downloads from MinIO, restores to test DB, validates table count
  </done>
</task>

<task type="auto">
  <name>Task 2: Document restoration procedure in DATABASE.md</name>
  <files>
    docs/DATABASE.md
  </files>
  <action>
Append restoration procedure documentation to docs/DATABASE.md:

````markdown
## Backup Restoration Procedures

### Quick Restore (Automated Test)

Run the restore test script to validate backup integrity:

```bash
# From docker environment
docker exec freshtrack-postgres-backup /scripts/test-restore.sh

# Or with specific backup file
docker exec freshtrack-postgres-backup /scripts/test-restore.sh freshtrack_2024-01-15_02-00-00.sql.gz
```
````

### Manual Restore (Production Recovery)

**CAUTION:** This procedure replaces the production database. Ensure you have a valid backup and understand the implications.

#### 1. List Available Backups

```bash
# Connect to MinIO and list backups
docker run --rm --network freshtrack_network minio/mc:latest \
  mc alias set minio http://minio:9000 ${MINIO_ACCESS_KEY} ${MINIO_SECRET_KEY} && \
  mc ls minio/postgres-backups/
```

#### 2. Download Backup File

```bash
# Download specific backup
docker run --rm --network freshtrack_network \
  -v /tmp:/backup \
  minio/mc:latest \
  sh -c "mc alias set minio http://minio:9000 ${MINIO_ACCESS_KEY} ${MINIO_SECRET_KEY} && \
         mc cp minio/postgres-backups/freshtrack_YYYY-MM-DD_HH-MM-SS.sql.gz /backup/"
```

#### 3. Stop Application Services

```bash
# Stop services that use the database (keep postgres running)
docker compose stop backend
```

#### 4. Restore Database

**Option A: Restore to same database (destructive)**

```bash
# Drop and recreate database
docker exec freshtrack-postgres psql -U freshtrack -c "DROP DATABASE freshtrack;"
docker exec freshtrack-postgres psql -U freshtrack -c "CREATE DATABASE freshtrack;"

# Restore
docker exec -i freshtrack-postgres pg_restore -U freshtrack -d freshtrack < /tmp/freshtrack_YYYY-MM-DD_HH-MM-SS.sql.gz
```

**Option B: Restore to new database (safer)**

```bash
# Create new database
docker exec freshtrack-postgres psql -U freshtrack -c "CREATE DATABASE freshtrack_restored;"

# Restore to new database
docker exec -i freshtrack-postgres pg_restore -U freshtrack -d freshtrack_restored < /tmp/freshtrack_YYYY-MM-DD_HH-MM-SS.sql.gz

# Verify restoration
docker exec freshtrack-postgres psql -U freshtrack -d freshtrack_restored -c "\dt"

# Swap databases (when verified)
docker exec freshtrack-postgres psql -U freshtrack -c "ALTER DATABASE freshtrack RENAME TO freshtrack_old;"
docker exec freshtrack-postgres psql -U freshtrack -c "ALTER DATABASE freshtrack_restored RENAME TO freshtrack;"
```

#### 5. Restart Application Services

```bash
docker compose start backend
```

#### 6. Verify Application

1. Check backend logs for database connection errors
2. Test key application functionality
3. Verify data integrity in UI

### Disaster Recovery Checklist

- [ ] Identify the backup to restore (date/time of last known good state)
- [ ] Notify stakeholders of downtime
- [ ] Take current backup (if database is accessible)
- [ ] Download backup file from MinIO
- [ ] Stop application services
- [ ] Perform restoration
- [ ] Verify table counts and key data
- [ ] Restart application services
- [ ] Verify application functionality
- [ ] Notify stakeholders of recovery completion
- [ ] Document incident and recovery in runbook

### Backup Schedule

| Frequency | Time (UTC) | Retention | Location                |
| --------- | ---------- | --------- | ----------------------- |
| Daily     | 2:00 AM    | 30 days   | MinIO: postgres-backups |

### Backup Monitoring

- **Alert:** BackupAgeTooOld - No backup in 25+ hours
- **Alert:** BackupContainerDown - Backup service not running
- **Dashboard:** Database Overview in Grafana

### Recovery Time Objectives

| Metric                         | Target     | Notes                    |
| ------------------------------ | ---------- | ------------------------ |
| RTO (Recovery Time Objective)  | < 1 hour   | Time to restore service  |
| RPO (Recovery Point Objective) | < 24 hours | Maximum data loss window |

With daily backups, maximum data loss is up to 24 hours. For lower RPO, increase backup frequency.

```
  </action>
  <verify>
    grep "Backup Restoration" docs/DATABASE.md
    grep "pg_restore" docs/DATABASE.md
    grep "Disaster Recovery" docs/DATABASE.md
    wc -l docs/DATABASE.md
  </verify>
  <done>
    docs/DATABASE.md updated with comprehensive restoration procedures
    Manual and automated restore procedures documented
    Disaster recovery checklist included
  </done>
</task>

</tasks>

<verification>
- [ ] docker/scripts/test-restore.sh exists and is executable
- [ ] Script downloads backup from MinIO
- [ ] Script restores to test database
- [ ] Script validates restoration (table count check)
- [ ] Script cleans up test database
- [ ] docs/DATABASE.md has restoration procedures
- [ ] docs/DATABASE.md has disaster recovery checklist
</verification>

<success_criteria>
Backup restoration procedure documented and tested, including automated test script and manual recovery steps with disaster recovery checklist
</success_criteria>

<output>
After completion, create `.planning/phases/10-database-production-readiness/10-05-SUMMARY.md`
</output>
```
