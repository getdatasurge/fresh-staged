---
phase: 45-production-deployment
plan: 02
type: execute
wave: 2
depends_on: ['45-01']
files_modified:
  - .env.production
  - secrets/postgres_password.txt
  - secrets/jwt_secret.txt
  - secrets/minio_password.txt
  - secrets/grafana_password.txt
  - secrets/stack_auth_secret.txt
autonomous: false

must_haves:
  truths:
    - 'SSH connection to VM succeeds'
    - 'Docker and Docker Compose are installed on VM'
    - ".env.production is configured with user's credentials"
    - 'All Docker services start without errors'
    - 'Database migrations complete successfully'
    - 'Health endpoint returns 200 OK'
  artifacts:
    - path: '.env.production'
      provides: 'Production environment configuration'
      contains: 'DOMAIN='
    - path: 'secrets/postgres_password.txt'
      provides: 'Database password'
  key_links:
    - from: 'deploy-orchestrated.sh'
      to: 'Docker Compose'
      via: 'docker compose up'
      pattern: 'docker compose.*up'
---

<objective>
Execute deployment to VM using the orchestrated deployment script.

Purpose: Deploy FreshTrack Pro to the user's VM with all services running.
Output: Working production instance with all services healthy.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/45-production-deployment/45-01-SUMMARY.md
@scripts/deploy-orchestrated.sh
@.env.production.example
@compose.production.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Clone Repository and Setup on VM</name>
  <files>N/A - remote operations</files>
  <action>
    SSH into the VM and prepare for deployment:

    1. Connect to VM:
       ```bash
       ssh ${VM_USER}@${VM_HOST}
       ```

    2. Clone the repository:
       ```bash
       git clone https://github.com/your-org/freshtrack-pro.git /opt/freshtrack
       cd /opt/freshtrack
       ```

    3. Create secrets directory and generate secrets:
       ```bash
       mkdir -p secrets
       openssl rand -base64 32 > secrets/postgres_password.txt
       openssl rand -base64 32 > secrets/jwt_secret.txt
       openssl rand -base64 32 > secrets/minio_password.txt
       openssl rand -base64 32 > secrets/grafana_password.txt
       chmod 600 secrets/*.txt
       ```

    4. Copy and configure .env.production:
       ```bash
       cp .env.production.example .env.production
       ```

    If user provides SSH key path, use: `ssh -i ${SSH_KEY_PATH} ${VM_USER}@${VM_HOST}`

  </action>
  <verify>Repository cloned and secrets generated on VM</verify>
  <done>VM has repository at /opt/freshtrack with secrets directory populated</done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 2: Configure .env.production with User Credentials</name>
  <action>
    User must edit .env.production on the VM with their credentials:

    ```bash
    nano /opt/freshtrack/.env.production
    ```

    Required edits:
    1. Set DOMAIN to your domain (e.g., app.freshtrackpro.com)
    2. Set FRONTEND_URL, API_URL to https://${DOMAIN}
    3. Set Stack Auth credentials:
       - STACK_AUTH_PROJECT_ID
       - STACK_AUTH_PUBLISHABLE_KEY
    4. Set Stripe API key:
       - STRIPE_SECRET_KEY
    5. Set Resend API key:
       - RESEND_API_KEY
       - EMAIL_FROM_ADDRESS
    6. (Optional) Set TTN credentials
    7. (Optional) Set Telnyx credentials

    Also create Stack Auth secret file:
    ```bash
    echo "your-stack-auth-secret-key" > secrets/stack_auth_secret.txt
    chmod 600 secrets/stack_auth_secret.txt
    ```

  </action>
  <how-to-verify>
    User confirms:
    - .env.production edited with all required values
    - secrets/stack_auth_secret.txt created
  </how-to-verify>
  <resume-signal>Type "config complete" when .env.production is configured</resume-signal>
</task>

<task type="auto">
  <name>Task 3: Run Deployment Script</name>
  <files>N/A - remote execution</files>
  <action>
    Execute the orchestrated deployment on the VM:

    ```bash
    cd /opt/freshtrack
    chmod +x scripts/deploy-orchestrated.sh
    sudo ./scripts/deploy-orchestrated.sh
    ```

    The script will:
    1. Run pre-flight validation
    2. Install prerequisites (Docker, firewall, fail2ban)
    3. Pull Docker images
    4. Build backend
    5. Start database services
    6. Run migrations
    7. Start all services
    8. Wait for health checks (3 consecutive passes)
    9. Clean up old images

    Monitor progress and watch for any errors.
    If script fails, it can be resumed with: `sudo ./scripts/deploy-orchestrated.sh --resume`

  </action>
  <verify>
    Script completes with "Deployment Complete!" message
    All services show as healthy in `docker compose ps`
  </verify>
  <done>
    deploy-orchestrated.sh exits successfully
    Health endpoint https://${DOMAIN}/health returns 200
  </done>
</task>

</tasks>

<verification>
- SSH connection to VM works
- Repository cloned to /opt/freshtrack
- .env.production configured with user credentials
- deploy-orchestrated.sh completes successfully
- docker compose ps shows all services running
- https://${DOMAIN}/health returns 200 OK
</verification>

<success_criteria>
Deployment script completes:

- All Docker services are running (backend, worker, postgres, redis, minio, caddy)
- Health endpoint returns 200 OK
- No error messages in docker compose logs
  </success_criteria>

<output>
After completion, create `.planning/phases/45-production-deployment/45-02-SUMMARY.md`
</output>
