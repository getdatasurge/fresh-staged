---
phase: 15-background-jobs-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/package.json
  - backend/src/plugins/queue.plugin.ts
  - backend/src/services/queue.service.ts
  - backend/src/jobs/index.ts
  - backend/src/types/queue.d.ts
  - backend/src/app.ts
autonomous: true

must_haves:
  truths:
    - "BullMQ Queue instances created and connected to Redis"
    - "Queue plugin registered with Fastify during app startup"
    - "QueueService provides type-safe addJob method"
    - "Job types enforce organizationId for multi-tenant isolation"
  artifacts:
    - path: "backend/src/plugins/queue.plugin.ts"
      provides: "Fastify plugin that registers QueueService"
      exports: ["queuePlugin"]
    - path: "backend/src/services/queue.service.ts"
      provides: "Queue management with initialize/addJob/shutdown"
      exports: ["QueueService", "getQueueService"]
    - path: "backend/src/jobs/index.ts"
      provides: "Job type definitions and constants"
      exports: ["QueueNames", "JobNames", "BaseJobData"]
    - path: "backend/src/types/queue.d.ts"
      provides: "Fastify instance decoration types"
      contains: "declare module 'fastify'"
  key_links:
    - from: "backend/src/app.ts"
      to: "backend/src/plugins/queue.plugin.ts"
      via: "app.register(queuePlugin)"
      pattern: "register\\(queuePlugin\\)"
    - from: "backend/src/plugins/queue.plugin.ts"
      to: "backend/src/services/queue.service.ts"
      via: "QueueService instantiation and decoration"
      pattern: "new QueueService"
---

<objective>
Set up BullMQ job queue infrastructure with Fastify plugin and QueueService.

Purpose: Provides foundation for background job processing (SMS, email digests) by integrating BullMQ with the existing Fastify architecture, following the established socket.plugin.ts pattern.

Output: Working queue plugin with type-safe job definitions and Redis connection handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-background-jobs-infrastructure/15-RESEARCH.md

# Existing patterns to follow
@backend/src/plugins/socket.plugin.ts
@backend/src/services/socket.service.ts
@backend/src/app.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install BullMQ dependencies and create job type definitions</name>
  <files>
    backend/package.json
    backend/src/jobs/index.ts
    backend/src/types/queue.d.ts
  </files>
  <action>
1. Install BullMQ and ioredis:
   ```bash
   cd backend && npm install bullmq ioredis
   ```
   Note: ioredis is a dependency of bullmq but explicit install ensures version control.

2. Create `backend/src/jobs/index.ts` with job type definitions:
   ```typescript
   // Job registry and type definitions
   import type { Job, JobsOptions } from 'bullmq';

   // Base interface enforcing organization scope for multi-tenant isolation
   export interface BaseJobData {
     organizationId: string;
   }

   // SMS notification job data (Phase 16)
   export interface SmsNotificationJobData extends BaseJobData {
     phoneNumber: string;
     message: string;
     alertId?: string;
   }

   // Email digest job data (Phase 17)
   export interface EmailDigestJobData extends BaseJobData {
     userId: string;
     period: 'daily' | 'weekly';
     startDate: string;
     endDate: string;
   }

   // Queue name constants (prevents typos)
   export const QueueNames = {
     SMS_NOTIFICATIONS: 'sms-notifications',
     EMAIL_DIGESTS: 'email-digests',
   } as const;

   export type QueueName = typeof QueueNames[keyof typeof QueueNames];

   // Job name constants
   export const JobNames = {
     SMS_SEND: 'sms:send',
     EMAIL_DIGEST: 'email:digest',
   } as const;

   export type JobName = typeof JobNames[keyof typeof JobNames];

   // Type helpers for strongly-typed job handling
   export type SmsNotificationJob = Job<SmsNotificationJobData>;
   export type EmailDigestJob = Job<EmailDigestJobData>;

   // Default job options
   export const defaultJobOptions: JobsOptions = {
     attempts: 3,
     backoff: {
       type: 'exponential',
       delay: 1000, // 1 second initial delay
     },
     removeOnComplete: 100, // Keep last 100 completed jobs
     removeOnFail: 500,     // Keep last 500 failed jobs for debugging
   };
   ```

3. Create `backend/src/types/queue.d.ts` to extend Fastify instance:
   ```typescript
   import type { QueueService } from '../services/queue.service.js';

   declare module 'fastify' {
     interface FastifyInstance {
       queueService: QueueService;
     }
   }
   ```
  </action>
  <verify>
    - `npm ls bullmq ioredis` shows both packages installed
    - TypeScript compiles without errors: `cd backend && npx tsc --noEmit`
    - Job types are exported correctly
  </verify>
  <done>
    BullMQ installed, job type definitions created with BaseJobData enforcing organizationId, Fastify type augmentation in place.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement QueueService following SocketService pattern</name>
  <files>backend/src/services/queue.service.ts</files>
  <action>
Create `backend/src/services/queue.service.ts` following the established SocketService pattern:

```typescript
/**
 * Queue service for BullMQ job management
 *
 * Provides centralized queue management for background job processing.
 * Follows the same pattern as SocketService for consistency.
 *
 * Features:
 * - Redis connection with graceful fallback
 * - Type-safe job dispatching with org isolation
 * - Event monitoring for logging
 * - Graceful shutdown handling
 */

import { Queue, QueueEvents } from 'bullmq';
import IORedis from 'ioredis';
import { QueueNames, defaultJobOptions, type BaseJobData, type QueueName } from '../jobs/index.js';

export class QueueService {
  private queues: Map<string, Queue> = new Map();
  private queueEvents: Map<string, QueueEvents> = new Map();
  private connection?: IORedis;
  private initialized = false;

  /**
   * Initialize QueueService with Redis connection
   *
   * Uses environment variables for configuration:
   * - REDIS_URL: Full connection string (takes precedence)
   * - REDIS_HOST: Redis host (default: localhost)
   * - REDIS_PORT: Redis port (default: 6379)
   *
   * Fails if Redis is not available (unlike SocketService which falls back).
   * Background jobs require Redis for persistence.
   */
  async initialize(): Promise<void> {
    const redisUrl = process.env.REDIS_URL;
    const redisHost = process.env.REDIS_HOST || 'localhost';
    const redisPort = parseInt(process.env.REDIS_PORT || '6379', 10);

    // Queue processing requires Redis - no fallback mode
    if (!redisUrl && !process.env.REDIS_HOST) {
      console.warn(
        '[QueueService] Redis not configured - job queues disabled. ' +
        'Set REDIS_URL or REDIS_HOST to enable background jobs.'
      );
      return;
    }

    try {
      // Create shared Redis connection for queues
      // Note: Workers need separate connection with maxRetriesPerRequest: null
      this.connection = redisUrl
        ? new IORedis(redisUrl, { maxRetriesPerRequest: 1 })
        : new IORedis({
            host: redisHost,
            port: redisPort,
            maxRetriesPerRequest: 1, // Fast failure for queue producers
          });

      this.connection.on('error', (err) => {
        console.error('[QueueService] Redis connection error:', err.message);
      });

      this.connection.on('connect', () => {
        console.log('[QueueService] Redis connected');
      });

      // Register all queues
      this.registerQueue(QueueNames.SMS_NOTIFICATIONS);
      this.registerQueue(QueueNames.EMAIL_DIGESTS);

      this.initialized = true;
      console.log('[QueueService] Initialized with Redis');
    } catch (error) {
      console.error('[QueueService] Failed to initialize:', error);
      throw error;
    }
  }

  /**
   * Register a named queue with event listeners
   */
  private registerQueue(name: string): void {
    if (!this.connection) {
      throw new Error('Cannot register queue - Redis not connected');
    }

    const queue = new Queue(name, {
      connection: this.connection,
      defaultJobOptions,
    });

    // Setup QueueEvents for monitoring (optional but useful for logging)
    const queueEvents = new QueueEvents(name, {
      connection: this.connection.duplicate(),
    });

    queueEvents.on('completed', ({ jobId }) => {
      console.log(`[QueueService] Job ${jobId} completed in queue ${name}`);
    });

    queueEvents.on('failed', ({ jobId, failedReason }) => {
      console.error(`[QueueService] Job ${jobId} failed in queue ${name}:`, failedReason);
    });

    queueEvents.on('stalled', ({ jobId }) => {
      console.warn(`[QueueService] Job ${jobId} stalled in queue ${name}`);
    });

    this.queues.set(name, queue);
    this.queueEvents.set(name, queueEvents);

    console.log(`[QueueService] Queue "${name}" registered`);
  }

  /**
   * Add a job to a queue with type-safe data
   *
   * @param queueName - Queue name from QueueNames constant
   * @param jobName - Job name from JobNames constant
   * @param data - Job data (must include organizationId)
   * @param options - Optional job-specific options
   * @returns Promise resolving to the created job
   */
  async addJob<T extends BaseJobData>(
    queueName: QueueName,
    jobName: string,
    data: T,
    options?: Parameters<Queue['add']>[2]
  ): Promise<ReturnType<Queue['add']>> {
    if (!this.initialized) {
      throw new Error('QueueService not initialized - Redis connection required');
    }

    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue "${queueName}" not found`);
    }

    // Validate organizationId is present
    if (!data.organizationId) {
      throw new Error('Job data must include organizationId for multi-tenant isolation');
    }

    const job = await queue.add(jobName, data, options);
    console.log(`[QueueService] Job ${job.id} added to queue ${queueName}`);

    return job;
  }

  /**
   * Get a queue by name (for advanced operations)
   */
  getQueue(name: QueueName): Queue | undefined {
    return this.queues.get(name);
  }

  /**
   * Get all queues (for Bull Board integration)
   */
  getAllQueues(): Queue[] {
    return Array.from(this.queues.values());
  }

  /**
   * Check if service is initialized and connected
   */
  isInitialized(): boolean {
    return this.initialized;
  }

  /**
   * Gracefully shutdown all queues and Redis connection
   */
  async shutdown(): Promise<void> {
    if (!this.initialized) {
      return;
    }

    console.log('[QueueService] Shutting down...');

    // Close all QueueEvents first
    const queueEventsClosePromises = Array.from(this.queueEvents.values()).map(
      (qe) => qe.close().catch((err) => console.error('[QueueService] Error closing QueueEvents:', err))
    );
    await Promise.all(queueEventsClosePromises);

    // Close all queues
    const queueClosePromises = Array.from(this.queues.values()).map(
      (q) => q.close().catch((err) => console.error('[QueueService] Error closing queue:', err))
    );
    await Promise.all(queueClosePromises);

    // Disconnect Redis
    if (this.connection) {
      await this.connection.quit().catch(() => {});
    }

    this.queues.clear();
    this.queueEvents.clear();
    this.initialized = false;

    console.log('[QueueService] Shutdown complete');
  }
}

/**
 * Singleton QueueService instance
 */
let instance: QueueService | null = null;

export function setQueueService(service: QueueService): void {
  instance = service;
}

export function getQueueService(): QueueService | null {
  return instance;
}
```
  </action>
  <verify>
    - TypeScript compiles: `cd backend && npx tsc --noEmit`
    - File exists with all methods: initialize, addJob, shutdown, getQueue, getAllQueues
  </verify>
  <done>
    QueueService implemented with Redis connection, queue registration, type-safe job addition, and graceful shutdown.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create queue.plugin.ts and register in app.ts</name>
  <files>
    backend/src/plugins/queue.plugin.ts
    backend/src/app.ts
  </files>
  <action>
1. Create `backend/src/plugins/queue.plugin.ts` following socket.plugin.ts pattern:

```typescript
import type { FastifyInstance, FastifyPluginAsync } from 'fastify';
import fastifyPlugin from 'fastify-plugin';
import { QueueService, setQueueService } from '../services/queue.service.js';

/**
 * BullMQ queue plugin for Fastify
 *
 * Integrates BullMQ job queues with Fastify for background processing.
 * Follows the same pattern as socket.plugin.ts for consistency.
 *
 * Features:
 * - Redis connection with graceful degradation
 * - Type-safe queue operations via QueueService
 * - Graceful shutdown handling
 *
 * Usage:
 *   app.register(queuePlugin);
 *   // After registration:
 *   app.queueService.addJob('sms-notifications', 'sms:send', { ... });
 */

export interface QueuePluginOptions {
  // Reserved for future options (e.g., enabling/disabling specific queues)
}

const queuePlugin: FastifyPluginAsync<QueuePluginOptions> = async (
  fastify: FastifyInstance,
  _opts: QueuePluginOptions
) => {
  // Create QueueService instance
  const queueService = new QueueService();

  // Set singleton for service access outside of request context
  setQueueService(queueService);

  // Decorate Fastify instance
  fastify.decorate('queueService', queueService);

  // Initialize queues after server is ready
  fastify.ready(async () => {
    try {
      await queueService.initialize();
      fastify.log.info('Queue plugin initialized');
    } catch (error) {
      fastify.log.error('Failed to initialize queue plugin:', error);
      // Don't throw - allow app to run without background jobs
    }
  });

  // Graceful shutdown
  fastify.addHook('onClose', async () => {
    fastify.log.info('Closing BullMQ queues...');
    await queueService.shutdown();
  });

  fastify.log.info('Queue plugin registered');
};

export default fastifyPlugin(queuePlugin, {
  name: 'bullmq-queue',
  fastify: '5.x',
});
```

2. Update `backend/src/app.ts` to register the queue plugin:
   - Add import: `import queuePlugin from './plugins/queue.plugin.js';`
   - Register after socket plugin (order matters for decorators):
     ```typescript
     // Register BullMQ queue plugin for background jobs
     app.register(queuePlugin);
     ```

   Place the registration after `app.register(socketPlugin, ...)` and before `app.register(authPlugin)`.
  </action>
  <verify>
    - TypeScript compiles: `cd backend && npx tsc --noEmit`
    - App starts without errors: `cd backend && npm run dev` (Ctrl+C after startup logs)
    - Look for log: "Queue plugin registered"
    - If Redis is running: "Queue plugin initialized" and "Redis connected"
  </verify>
  <done>
    Queue plugin registered with Fastify, QueueService available on app instance, graceful shutdown configured.
  </done>
</task>

</tasks>

<verification>
1. Build passes: `cd backend && npm run build`
2. All tests pass: `cd backend && npm test`
3. App starts and logs queue initialization (when Redis available)
4. Type checking passes: `npx tsc --noEmit`
5. QueueService singleton accessible via getQueueService()
</verification>

<success_criteria>
- BullMQ and ioredis packages installed in backend/package.json
- Job type definitions with BaseJobData enforcing organizationId
- QueueService with initialize/addJob/shutdown matching SocketService pattern
- Queue plugin registered in app.ts
- Fastify instance decorated with queueService
- Graceful shutdown closes all queues and Redis connections
</success_criteria>

<output>
After completion, create `.planning/phases/15-background-jobs-infrastructure/15-01-SUMMARY.md`
</output>
