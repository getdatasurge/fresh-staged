---
phase: 17-email-digests
plan: 03
type: execute
wave: 2
depends_on: ['17-01']
files_modified:
  - backend/src/utils/unsubscribe-token.ts
  - backend/src/routes/unsubscribe.ts
  - backend/src/routes/index.ts
  - backend/src/workers/processors/email-digest.processor.ts
autonomous: true

must_haves:
  truths:
    - 'User can unsubscribe via one-click link in email footer'
    - 'Unsubscribe token is secure and expires after 30 days'
    - 'Digest processor uses grouped data and generates unsubscribe URLs'
  artifacts:
    - path: 'backend/src/utils/unsubscribe-token.ts'
      provides: 'JWT generation and verification for unsubscribe'
      exports: ['generateUnsubscribeToken', 'verifyUnsubscribeToken']
    - path: 'backend/src/routes/unsubscribe.ts'
      provides: 'GET /unsubscribe endpoint'
      contains: 'verifyUnsubscribeToken'
    - path: 'backend/src/workers/processors/email-digest.processor.ts'
      provides: 'Processor using grouped data and generating unsubscribe tokens'
      contains: 'buildGroupedDigestData'
  key_links:
    - from: 'backend/src/workers/processors/email-digest.processor.ts'
      to: 'generateUnsubscribeToken'
      via: 'import and call'
      pattern: 'generateUnsubscribeToken'
    - from: 'backend/src/routes/unsubscribe.ts'
      to: 'verifyUnsubscribeToken'
      via: 'token verification'
      pattern: 'verifyUnsubscribeToken'
---

<objective>
Implement secure one-click unsubscribe with JWT tokens and update the digest processor to use grouped data with plain text support.

Purpose: Per CONTEXT.md, "One-click unsubscribe link in footer" is required for email deliverability compliance. Processor must be updated to use the new grouped digest data.
Output: Unsubscribe utility, /unsubscribe endpoint, updated processor with grouped data and plain text
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-email-digests/17-CONTEXT.md
@.planning/phases/17-email-digests/17-RESEARCH.md
@.planning/phases/17-email-digests/17-01-SUMMARY.md
@backend/src/workers/processors/email-digest.processor.ts
@backend/src/routes/preferences.ts
@backend/src/routes/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unsubscribe token utility</name>
  <files>
    backend/src/utils/unsubscribe-token.ts
  </files>
  <action>
Create backend/src/utils/unsubscribe-token.ts with JWT-based token generation and verification:

```typescript
/**
 * Unsubscribe Token Utility
 *
 * Generates and verifies JWT tokens for one-click email unsubscribe.
 * Tokens are signed with UNSUBSCRIBE_SECRET (falls back to JWT_SECRET)
 * and expire after 30 days.
 *
 * Token payload:
 * - userId: User to unsubscribe
 * - type: 'daily' | 'weekly' | 'all' - which digest to disable
 */

import { SignJWT, jwtVerify, type JWTPayload } from 'jose';

// Use dedicated secret or fall back to JWT_SECRET
const getUnsubscribeSecret = () => {
  const secret = process.env.UNSUBSCRIBE_SECRET || process.env.JWT_SECRET;
  if (!secret) {
    throw new Error(
      '[UnsubscribeToken] No secret configured. Set UNSUBSCRIBE_SECRET or JWT_SECRET.',
    );
  }
  return new TextEncoder().encode(secret);
};

/**
 * Unsubscribe token payload
 */
export interface UnsubscribePayload extends JWTPayload {
  userId: string;
  type: 'daily' | 'weekly' | 'all';
}

/**
 * Generate a signed JWT token for one-click unsubscribe
 *
 * @param userId - User ID to encode in token
 * @param type - Which digest(s) to unsubscribe from
 * @returns Signed JWT token valid for 30 days
 */
export async function generateUnsubscribeToken(
  userId: string,
  type: 'daily' | 'weekly' | 'all',
): Promise<string> {
  const secret = getUnsubscribeSecret();

  return new SignJWT({ userId, type })
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('30d') // Token valid for 30 days
    .sign(secret);
}

/**
 * Verify and decode an unsubscribe token
 *
 * @param token - JWT token to verify
 * @returns Decoded payload or null if invalid/expired
 */
export async function verifyUnsubscribeToken(token: string): Promise<UnsubscribePayload | null> {
  try {
    const secret = getUnsubscribeSecret();
    const { payload } = await jwtVerify(token, secret);

    // Validate payload structure
    if (
      typeof payload.userId !== 'string' ||
      !['daily', 'weekly', 'all'].includes(payload.type as string)
    ) {
      console.warn('[UnsubscribeToken] Invalid payload structure');
      return null;
    }

    return payload as UnsubscribePayload;
  } catch (error) {
    // Token expired, invalid signature, or malformed
    console.warn('[UnsubscribeToken] Verification failed:', error);
    return null;
  }
}
```

Note: jose library is already installed (used by Stack Auth integration).
</action>
<verify>

- TypeScript compilation: `cd /home/skynet/freshtrack-pro-local/fresh-staged/backend && pnpm tsc --noEmit`
- Verify jose is in package.json dependencies
  </verify>
  <done>
- generateUnsubscribeToken creates signed JWT with userId and type
- verifyUnsubscribeToken returns payload or null
- 30-day expiration configured
- Uses UNSUBSCRIBE_SECRET with JWT_SECRET fallback
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create /unsubscribe endpoint</name>
  <files>
    backend/src/routes/unsubscribe.ts
    backend/src/routes/index.ts
  </files>
  <action>
1. Create backend/src/routes/unsubscribe.ts:
```typescript
/**
 * Unsubscribe Routes
 *
 * Handles one-click email unsubscribe from digest notifications.
 * Token-based authentication (no user session required).
 */

import type { FastifyInstance } from 'fastify';
import type { ZodTypeProvider } from 'fastify-type-provider-zod';
import { z } from 'zod';
import { eq } from 'drizzle-orm';
import { db } from '../db/client.js';
import { profiles } from '../db/schema/users.js';
import { verifyUnsubscribeToken } from '../utils/unsubscribe-token.js';
import { removeUserDigestSchedulers } from '../jobs/schedulers/digest-schedulers.js';

// Response schemas
const SuccessResponseSchema = z.object({
success: z.boolean(),
message: z.string(),
type: z.enum(['daily', 'weekly', 'all']),
});

const ErrorResponseSchema = z.object({
error: z.string(),
});

export default async function unsubscribeRoutes(fastify: FastifyInstance) {
const app = fastify.withTypeProvider<ZodTypeProvider>();

/\*\*

- GET /unsubscribe
- One-click unsubscribe from digest emails
-
- Query params:
- - token: JWT containing userId and unsubscribe type
-
- No authentication required (token-based verification).
- Returns HTML page confirming unsubscribe or showing error.
  \*/
  app.get(
  '/',
  {
  schema: {
  querystring: z.object({
  token: z.string().min(1),
  }),
  response: {
  200: SuccessResponseSchema,
  400: ErrorResponseSchema,
  404: ErrorResponseSchema,
  },
  },
  },
  async (request, reply) => {
  const { token } = request.query;

        // Verify token
        const payload = await verifyUnsubscribeToken(token);
        if (!payload) {
          return reply.status(400).send({
            error: 'Invalid or expired unsubscribe link. Please update your preferences in the app.',
          });
        }

        const { userId, type } = payload;

        // Get user profile
        const [profile] = await db
          .select()
          .from(profiles)
          .where(eq(profiles.userId, userId))
          .limit(1);

        if (!profile) {
          return reply.status(404).send({ error: 'User not found' });
        }

        // Update preferences based on type
        const updates: Partial<{ digestDaily: boolean; digestWeekly: boolean }> = {};

        if (type === 'daily' || type === 'all') {
          updates.digestDaily = false;
        }
        if (type === 'weekly' || type === 'all') {
          updates.digestWeekly = false;
        }

        await db
          .update(profiles)
          .set(updates)
          .where(eq(profiles.userId, userId));

        // Remove schedulers
        if (type === 'all') {
          await removeUserDigestSchedulers(userId);
        } else {
          // For single type, re-sync to update scheduler state
          const { syncUserDigestSchedulers } = await import(
            '../jobs/schedulers/digest-schedulers.js'
          );
          await syncUserDigestSchedulers(userId, profile.organizationId, {
            dailyEnabled: type === 'daily' ? false : profile.digestDaily,
            weeklyEnabled: type === 'weekly' ? false : profile.digestWeekly,
            timezone: profile.timezone,
            dailyTime: (profile as any).digestDailyTime || '09:00',
          });
        }

        const messages = {
          daily: 'You have been unsubscribed from daily digest emails.',
          weekly: 'You have been unsubscribed from weekly digest emails.',
          all: 'You have been unsubscribed from all digest emails.',
        };

        fastify.log.info(
          { userId, type },
          '[Unsubscribe] User unsubscribed from digest'
        );

        return reply.send({
          success: true,
          message: messages[type],
          type,
        });
      }

  );
  }

````

2. Register the route in backend/src/routes/index.ts:
   - Import unsubscribeRoutes
   - Register at prefix '/unsubscribe'

```typescript
import unsubscribeRoutes from './unsubscribe.js';

// In the function body, add:
fastify.register(unsubscribeRoutes, { prefix: '/unsubscribe' });
````

Note: This endpoint does NOT have /api prefix - it's a public endpoint accessed from email links.
</action>
<verify>

- TypeScript compilation: `cd /home/skynet/freshtrack-pro-local/fresh-staged/backend && pnpm tsc --noEmit`
- Backend starts: `pnpm dev`
- Test endpoint manually (would need valid token)
  </verify>
  <done>
- GET /unsubscribe?token=xxx endpoint exists
- Token verification using verifyUnsubscribeToken
- Updates profile to disable appropriate digest type
- Removes/updates schedulers accordingly
- Returns JSON response (frontend could render confirmation page)
  </done>
  </task>

<task type="auto">
  <name>Task 3: Update digest processor to use grouped data and unsubscribe tokens</name>
  <files>
    backend/src/workers/processors/email-digest.processor.ts
  </files>
  <action>
Update the email-digest.processor.ts to:
1. Use buildGroupedDigestData instead of buildDigestData
2. Pass user's site filter (digestSiteIds) to the builder
3. Generate secure unsubscribe URL with JWT token
4. Render plain text version of email
5. Pass both html and text to EmailService

```typescript
// Update imports
import { render } from '@react-email/render';
import type { EmailDigestJobData } from '../../jobs/index.js';
import { getEmailService } from '../../services/email.service.js';
import {
  DigestBuilderService,
  type GroupedDigestData,
} from '../../services/digest-builder.service.js';
import { DailyDigest } from '../../emails/daily-digest.js';
import { WeeklyDigest } from '../../emails/weekly-digest.js';
import { db } from '../../db/client.js';
import { profiles } from '../../db/schema/users.js';
import { eq } from 'drizzle-orm';
import { generateUnsubscribeToken } from '../../utils/unsubscribe-token.js';

// Update processEmailDigest function:
export async function processEmailDigest(
  job: Job<EmailDigestJobData>,
): Promise<ProcessEmailDigestResult> {
  const { userId, organizationId, period } = job.data;
  console.log(`[Email Digest] Processing ${period} digest for user ${userId}`);

  // Get user profile (need all fields including new ones)
  const [user] = await db.select().from(profiles).where(eq(profiles.userId, userId)).limit(1);

  if (!user) {
    console.warn(`[Email Digest] User ${userId} not found - skipping`);
    return { success: false, reason: 'user_not_found' };
  }

  // Check if emails enabled globally
  if (!user.emailEnabled) {
    console.log(`[Email Digest] User ${userId} has emails disabled - skipping`);
    return { success: false, reason: 'user_disabled_emails' };
  }

  // Check if specific digest type enabled
  if (period === 'daily' && !user.digestDaily) {
    console.log(`[Email Digest] User ${userId} has daily digest disabled - skipping`);
    return { success: false, reason: 'daily_digest_disabled' };
  }
  if (period === 'weekly' && !user.digestWeekly) {
    console.log(`[Email Digest] User ${userId} has weekly digest disabled - skipping`);
    return { success: false, reason: 'weekly_digest_disabled' };
  }

  // Calculate date range at execution time
  const endDate = new Date();
  const startDate = new Date();
  if (period === 'daily') {
    startDate.setDate(startDate.getDate() - 1);
  } else {
    startDate.setDate(startDate.getDate() - 7);
  }

  // Parse site filter from user profile
  // digestSiteIds is stored as JSON text, null means all sites
  const siteIds: string[] | null = (user as any).digestSiteIds
    ? JSON.parse((user as any).digestSiteIds)
    : null;

  // Build GROUPED digest data with site filter
  const digestData = await digestBuilder.buildGroupedDigestData(
    userId,
    organizationId,
    period,
    startDate,
    endDate,
    siteIds,
  );

  // Skip if no alerts (don't send empty digests)
  if (digestData.sites.length === 0) {
    console.log(`[Email Digest] No alerts for user ${userId} in period - skipping send`);
    return { success: true, reason: 'no_content' };
  }

  // Build URLs for email links
  const baseUrl = process.env.APP_URL || 'https://app.freshtrack.app';
  const dashboardUrl = `${baseUrl}/alerts`;

  // Generate secure unsubscribe token
  const unsubscribeToken = await generateUnsubscribeToken(userId, period);
  const unsubscribeUrl = `${baseUrl}/unsubscribe?token=${unsubscribeToken}`;

  // Render appropriate template
  const Template = period === 'daily' ? DailyDigest : WeeklyDigest;
  const templateProps = {
    userName: user.fullName || 'User',
    digest: digestData,
    unsubscribeUrl,
    dashboardUrl,
  };

  // Render HTML and plain text versions
  const html = await render(Template(templateProps));
  const text = await render(Template(templateProps), { plainText: true });

  // Get EmailService
  const emailService = getEmailService();
  if (!emailService || !emailService.isEnabled()) {
    console.warn('[Email Digest] EmailService not available - skipping send');
    return { success: false, reason: 'email_service_disabled' };
  }

  // Send via EmailService with both HTML and plain text
  const result = await emailService.sendDigest({
    to: user.email,
    subject: `Your ${period} alert digest - ${digestData.summary.total} alert${digestData.summary.total !== 1 ? 's' : ''}`,
    html,
    text,
  });

  if (!result) {
    return { success: false, reason: 'email_service_returned_null' };
  }

  console.log(
    `[Email Digest] Sent ${period} digest to ${user.email} - messageId: ${result.messageId}`,
  );
  return { success: true, messageId: result.messageId };
}
```

  </action>
  <verify>
- TypeScript compilation: `cd /home/skynet/freshtrack-pro-local/fresh-staged/backend && pnpm tsc --noEmit`
- Check imports resolve correctly
- Worker starts without errors: `pnpm worker` (in backend directory)
  </verify>
  <done>
- Processor uses buildGroupedDigestData with site filtering
- Generates secure unsubscribe URL with JWT token
- Renders both HTML and plain text versions
- Passes both versions to EmailService
- Empty check uses sites.length instead of alerts.length
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes for all modified files

2. Unsubscribe flow:
   - Generate token: `generateUnsubscribeToken(userId, 'daily')` returns valid JWT
   - Verify token: `verifyUnsubscribeToken(token)` returns payload
   - GET /unsubscribe?token=xxx updates preferences and returns success

3. Processor integration:
   - Uses buildGroupedDigestData (from Plan 02)
   - Passes siteIds from user profile
   - Generates unsubscribe URL with token
   - Sends both HTML and plain text

4. End-to-end (manual test):
   - Trigger a test digest job
   - Email contains hierarchical site/unit structure
   - Unsubscribe link in footer is clickable
   - Clicking unsubscribe disables digest preference
     </verification>

<success_criteria>

1. generateUnsubscribeToken creates valid 30-day JWT
2. verifyUnsubscribeToken correctly validates and decodes tokens
3. GET /unsubscribe endpoint disables appropriate digest and returns success
4. Processor uses grouped digest data with site filtering
5. Emails include secure, functional unsubscribe links
6. Both HTML and plain text versions are sent
   </success_criteria>

<output>
After completion, create `.planning/phases/17-email-digests/17-03-SUMMARY.md`
</output>
