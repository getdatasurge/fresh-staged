---
phase: 17-email-digests
plan: 02
type: execute
wave: 2
depends_on: ['17-01']
files_modified:
  - backend/src/services/digest-builder.service.ts
  - backend/src/emails/daily-digest.tsx
  - backend/src/emails/weekly-digest.tsx
  - backend/src/services/email.service.ts
autonomous: true

must_haves:
  truths:
    - 'Digest emails group alerts by site then by unit'
    - 'Users only see alerts from their selected sites'
    - 'Email includes both HTML and plain text versions'
  artifacts:
    - path: 'backend/src/services/digest-builder.service.ts'
      provides: 'buildGroupedDigestData method with site filtering'
      contains: 'buildGroupedDigestData'
    - path: 'backend/src/emails/daily-digest.tsx'
      provides: 'Template rendering grouped structure'
      contains: 'sites.map'
    - path: 'backend/src/services/email.service.ts'
      provides: 'sendDigest accepts text parameter'
      contains: 'text:'
  key_links:
    - from: 'backend/src/emails/daily-digest.tsx'
      to: 'GroupedDigestData'
      via: 'props type'
      pattern: 'sites.*units.*alerts'
    - from: 'backend/src/services/email.service.ts'
      to: 'Resend API'
      via: 'html and text fields'
      pattern: 'text,'
---

<objective>
Implement site/unit grouping in digest data and update email templates to render hierarchical alert structure with plain text fallback.

Purpose: Per CONTEXT.md, alerts should be grouped "by site, then by unit within each site" for easy scanning, with site filtering based on user preferences.
Output: DigestBuilderService with grouped output, updated templates, plain text email support
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-email-digests/17-CONTEXT.md
@.planning/phases/17-email-digests/17-RESEARCH.md
@.planning/phases/17-email-digests/17-01-SUMMARY.md
@backend/src/services/digest-builder.service.ts
@backend/src/emails/daily-digest.tsx
@backend/src/emails/weekly-digest.tsx
@backend/src/services/email.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add buildGroupedDigestData method to DigestBuilderService</name>
  <files>
    backend/src/services/digest-builder.service.ts
  </files>
  <action>
1. Add new interfaces for grouped digest structure:
```typescript
/**
 * Grouped alert data for hierarchical email display
 */
export interface GroupedDigestData {
  sites: Array<{
    siteId: string;
    siteName: string;
    units: Array<{
      unitId: string;
      unitName: string;
      alerts: DigestAlert[];
    }>;
  }>;
  summary: DigestSummary;
  organizationName: string;
  period: 'daily' | 'weekly';
  startDate: Date;
  endDate: Date;
}
```

2. Add buildGroupedDigestData method to DigestBuilderService class:

```typescript
/**
 * Build grouped digest data with site/unit hierarchy
 * Queries alerts within date range, groups by site then unit
 * Supports optional site filtering via siteIds parameter
 *
 * @param userId - User requesting the digest
 * @param organizationId - Organization to query alerts for
 * @param period - 'daily' or 'weekly'
 * @param startDate - Start of date range
 * @param endDate - End of date range
 * @param siteIds - Optional array of site UUIDs to filter (null/undefined = all sites)
 * @returns Grouped digest data with alerts organized by site then unit
 */
async buildGroupedDigestData(
  userId: string,
  organizationId: string,
  period: 'daily' | 'weekly',
  startDate: Date,
  endDate: Date,
  siteIds?: string[] | null
): Promise<GroupedDigestData> {
  // Build WHERE conditions
  const conditions = [
    eq(sites.organizationId, organizationId),
    gte(alerts.triggeredAt, startDate),
    lte(alerts.triggeredAt, endDate),
  ];

  // Add site filter if provided
  if (siteIds && siteIds.length > 0) {
    conditions.push(inArray(sites.id, siteIds));
  }

  // Query alerts with site/unit joins
  const alertResults = await db
    .select({
      id: alerts.id,
      severity: alerts.severity,
      message: alerts.message,
      triggeredAt: alerts.triggeredAt,
      status: alerts.status,
      unitId: units.id,
      unitName: units.name,
      siteId: sites.id,
      siteName: sites.name,
    })
    .from(alerts)
    .innerJoin(units, eq(alerts.unitId, units.id))
    .innerJoin(areas, eq(units.areaId, areas.id))
    .innerJoin(sites, eq(areas.siteId, sites.id))
    .where(and(...conditions))
    .orderBy(sites.name, units.name, desc(alerts.triggeredAt))
    .limit(50);

  // Group results by site then unit
  const siteMap = new Map<string, {
    siteId: string;
    siteName: string;
    unitMap: Map<string, {
      unitId: string;
      unitName: string;
      alerts: DigestAlert[];
    }>;
  }>();

  for (const row of alertResults) {
    if (!siteMap.has(row.siteId)) {
      siteMap.set(row.siteId, {
        siteId: row.siteId,
        siteName: row.siteName,
        unitMap: new Map(),
      });
    }
    const site = siteMap.get(row.siteId)!;

    if (!site.unitMap.has(row.unitId)) {
      site.unitMap.set(row.unitId, {
        unitId: row.unitId,
        unitName: row.unitName,
        alerts: [],
      });
    }
    const unit = site.unitMap.get(row.unitId)!;

    unit.alerts.push({
      id: row.id,
      severity: row.severity as 'critical' | 'warning' | 'info',
      message: row.message,
      triggeredAt: row.triggeredAt,
      unitName: row.unitName,
      siteName: row.siteName,
      status: row.status,
    });
  }

  // Convert maps to arrays
  const groupedSites = Array.from(siteMap.values()).map(site => ({
    siteId: site.siteId,
    siteName: site.siteName,
    units: Array.from(site.unitMap.values()),
  }));

  // Build summary from all alerts
  const allAlerts = alertResults.map(row => ({
    severity: row.severity,
    status: row.status,
  }));

  const summary: DigestSummary = {
    total: allAlerts.length,
    critical: allAlerts.filter(a => a.severity === 'critical').length,
    warning: allAlerts.filter(a => a.severity === 'warning').length,
    info: allAlerts.filter(a => a.severity === 'info').length,
    resolved: allAlerts.filter(a => a.status === 'resolved').length,
  };

  // Get organization name
  const [org] = await db
    .select({ name: organizations.name })
    .from(organizations)
    .where(eq(organizations.id, organizationId))
    .limit(1);

  return {
    sites: groupedSites,
    summary,
    organizationName: org?.name || 'Your Organization',
    period,
    startDate,
    endDate,
  };
}
```

3. Add inArray import from drizzle-orm at top of file:

```typescript
import { eq, and, gte, lte, desc, inArray } from 'drizzle-orm';
```

  </action>
  <verify>
- TypeScript compilation: `cd /home/skynet/freshtrack-pro-local/fresh-staged/backend && pnpm tsc --noEmit`
- Method signature matches expected interface
  </verify>
  <done>
- GroupedDigestData interface exported
- buildGroupedDigestData method groups alerts by site then unit
- Site filtering works when siteIds provided
- 50 alert limit maintained
  </done>
</task>

<task type="auto">
  <name>Task 2: Update email templates to render grouped structure</name>
  <files>
    backend/src/emails/daily-digest.tsx
    backend/src/emails/weekly-digest.tsx
  </files>
  <action>
1. Update both templates to accept GroupedDigestData instead of DigestData.
   Import the new type and update props interface.

2. For daily-digest.tsx, restructure the alert list section:

```tsx
import type { GroupedDigestData, DigestAlert } from '../services/digest-builder.service.js';

interface DailyDigestProps {
  userName: string;
  digest: GroupedDigestData; // Changed from DigestData
  unsubscribeUrl: string;
  dashboardUrl: string;
}

// In the component, replace the alert list rendering:
{
  digest.sites.length > 0 ? (
    <>
      <Heading as="h2" style={{ margin: '0 0 12px 0', fontSize: '18px', color: '#212529' }}>
        Alerts by Location
      </Heading>
      {digest.sites.map((site) => (
        <Section key={site.siteId} style={{ marginBottom: '20px' }}>
          {/* Site header */}
          <Text
            style={{
              margin: '0 0 8px 0',
              fontSize: '15px',
              fontWeight: 'bold',
              color: '#212529',
              backgroundColor: '#e9ecef',
              padding: '8px 12px',
              borderRadius: '4px',
            }}
          >
            {site.siteName}
          </Text>

          {site.units.map((unit) => (
            <Section key={unit.unitId} style={{ marginLeft: '12px', marginBottom: '12px' }}>
              {/* Unit header */}
              <Text
                style={{
                  margin: '0 0 6px 0',
                  fontSize: '13px',
                  fontWeight: 'bold',
                  color: '#495057',
                }}
              >
                {unit.unitName} ({unit.alerts.length} alert{unit.alerts.length !== 1 ? 's' : ''})
              </Text>

              {/* Unit alerts */}
              <Section
                style={{
                  border: '1px solid #dee2e6',
                  borderRadius: '4px',
                  overflow: 'hidden',
                }}
              >
                {unit.alerts.slice(0, 5).map((alert) => (
                  <AlertRow
                    key={alert.id}
                    severity={alert.severity}
                    message={alert.message || 'Alert triggered'}
                    unitName={alert.unitName}
                    siteName={alert.siteName}
                    triggeredAt={alert.triggeredAt}
                  />
                ))}
                {unit.alerts.length > 5 && (
                  <Text
                    style={{
                      margin: 0,
                      padding: '8px',
                      fontSize: '12px',
                      color: '#6c757d',
                      backgroundColor: '#f8f9fa',
                      textAlign: 'center',
                    }}
                  >
                    + {unit.alerts.length - 5} more
                  </Text>
                )}
              </Section>
            </Section>
          ))}
        </Section>
      ))}

      {/* CTA Button */}
      <Section style={{ textAlign: 'center', margin: '24px 0' }}>
        <Button
          href={dashboardUrl}
          style={{
            backgroundColor: '#0d6efd',
            color: '#ffffff',
            padding: '12px 32px',
            borderRadius: '6px',
            textDecoration: 'none',
            fontSize: '14px',
            fontWeight: 'bold',
            display: 'inline-block',
          }}
        >
          View All Alerts
        </Button>
      </Section>
    </>
  ) : (
    <Text
      style={
        {
          /* ... existing no alerts style */
        }
      }
    >
      No alerts in the last 24 hours. Everything looks good!
    </Text>
  );
}
```

3. Apply the same pattern to weekly-digest.tsx with its purple color scheme.
   - Change the period text from "24 hours" to "7 days"
   - Use the purple (#6f42c1) background for headers

4. Update the "no content" check in both templates:
   - Instead of checking `displayAlerts.length`, check `digest.sites.length`
     </action>
     <verify>

- TypeScript compilation: `cd /home/skynet/freshtrack-pro-local/fresh-staged/backend && pnpm tsc --noEmit`
- Preview templates (if React Email preview is set up): `cd backend && pnpm email:preview`
  </verify>
  <done>
- DailyDigest accepts GroupedDigestData props
- WeeklyDigest accepts GroupedDigestData props
- Both templates render site sections with nested unit sections
- Per-unit alert display with 5-alert limit per unit
- Existing styling maintained, grouped structure added
  </done>
  </task>

<task type="auto">
  <name>Task 3: Add plain text support to EmailService</name>
  <files>
    backend/src/services/email.service.ts
  </files>
  <action>
1. Update SendDigestParams interface to include optional text field:
```typescript
export interface SendDigestParams {
  /** Recipient email address */
  to: string;
  /** Email subject line */
  subject: string;
  /** HTML email body content */
  html: string;
  /** Plain text email body (optional, recommended for deliverability) */
  text?: string;
}
```

2. Update sendDigest method to pass text to Resend:

```typescript
async sendDigest(params: SendDigestParams): Promise<SendDigestResult | null> {
  // ... existing checks ...

  const { to, subject, html, text } = params;

  console.log(
    `[EmailService] Sending digest email from ${this.fromAddress} to ${to}`
  );

  // Send via Resend SDK
  const { data, error } = await this.client.emails.send({
    from: this.fromAddress,
    to,
    subject,
    html,
    text, // Include plain text version if provided
    tags: [
      {
        name: 'type',
        value: 'digest',
      },
    ],
  });

  // ... rest of method unchanged ...
}
```

Note: The Resend SDK accepts `text` as an optional field. If not provided, Resend will auto-generate from HTML.
</action>
<verify>

- TypeScript compilation: `cd /home/skynet/freshtrack-pro-local/fresh-staged/backend && pnpm tsc --noEmit`
- Verify Resend SDK types accept text field (already confirmed in research)
  </verify>
  <done>
- SendDigestParams includes optional text field
- sendDigest passes text to Resend API when provided
- Backward compatible (text is optional)
  </done>
  </task>

</tasks>

<verification>
1. TypeScript compilation passes for all modified files
2. DigestBuilderService.buildGroupedDigestData:
   - Returns GroupedDigestData with sites array
   - Each site has units array
   - Each unit has alerts array
   - Site filtering works when siteIds provided

3. Email templates:
   - Accept GroupedDigestData props
   - Render site headers followed by unit sections
   - Alerts grouped under their respective units

4. EmailService:
   - sendDigest accepts text parameter
   - Resend API receives text field when provided
     </verification>

<success_criteria>

1. buildGroupedDigestData method exists and returns properly structured data
2. Site filtering works correctly (null = all sites, array = filtered)
3. Both email templates render hierarchical site > unit > alert structure
4. EmailService supports plain text parameter for Resend
5. All TypeScript compiles without errors
   </success_criteria>

<output>
After completion, create `.planning/phases/17-email-digests/17-02-SUMMARY.md`
</output>
