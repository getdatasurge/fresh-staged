{
  "units": [
    {
      "name": "safe_print",
      "qualified_name": "scripts.ralph.watch-filter.py.safe_print",
      "file": "scripts/ralph/watch-filter.py",
      "line": 52,
      "language": "python",
      "unit_type": "function",
      "signature": "def safe_print(msg: str) -> None",
      "docstring": "Print that fails open - disables output on BrokenPipe instead of crashing.",
      "calls": [],
      "called_by": ["process_event"],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "argparse, json, os, sys, typing",
      "code_preview": "def safe_print(msg: str) -> None:\n    \"\"\"Print that fails open - disables output on BrokenPipe instead of crashing.\"\"\"\n    global _output_disabled\n    if _output_disabled:\n        return\n    try:\n        print(msg, flush=True)\n    except BrokenPipeError:"
    },
    {
      "name": "drain_stdin",
      "qualified_name": "scripts.ralph.watch-filter.py.drain_stdin",
      "file": "scripts/ralph/watch-filter.py",
      "line": 63,
      "language": "python",
      "unit_type": "function",
      "signature": "def drain_stdin() -> None",
      "docstring": "Consume remaining stdin to prevent SIGPIPE to upstream processes.",
      "calls": [],
      "called_by": ["<module>"],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:2, def-use chains:0",
      "dependencies": "argparse, json, os, sys, typing",
      "code_preview": "def drain_stdin() -> None:\n    \"\"\"Consume remaining stdin to prevent SIGPIPE to upstream processes.\"\"\"\n    try:\n        for _ in sys.stdin:\n            pass\n    except Exception:"
    },
    {
      "name": "truncate",
      "qualified_name": "scripts.ralph.watch-filter.py.truncate",
      "file": "scripts/ralph/watch-filter.py",
      "line": 72,
      "language": "python",
      "unit_type": "function",
      "signature": "def truncate(s: str, max_len: int) -> str",
      "docstring": "",
      "calls": [],
      "called_by": ["process_event", "format_tool_use", "format_tool_result"],
      "cfg_summary": "complexity:2, blocks:5",
      "dfg_summary": "vars:3, def-use chains:6",
      "dependencies": "argparse, json, os, sys, typing",
      "code_preview": "def truncate(s: str, max_len: int = 60) -> str:\n    s = s.replace(\"\\n\", \" \").strip()\n    if len(s) > max_len:\n        return s[: max_len - 3] + \"...\""
    },
    {
      "name": "format_tool_use",
      "qualified_name": "scripts.ralph.watch-filter.py.format_tool_use",
      "file": "scripts/ralph/watch-filter.py",
      "line": 79,
      "language": "python",
      "unit_type": "function",
      "signature": "def format_tool_use(tool_name: str, tool_input: dict) -> str",
      "docstring": "Format a tool use event for TUI display.",
      "calls": ["truncate"],
      "called_by": ["process_event"],
      "cfg_summary": "complexity:12, blocks:44",
      "dfg_summary": "vars:15, def-use chains:28",
      "dependencies": "argparse, json, os, sys, typing",
      "code_preview": "def format_tool_use(tool_name: str, tool_input: dict) -> str:\n    \"\"\"Format a tool use event for TUI display.\"\"\"\n    icon = ICONS.get(tool_name, \"\ud83d\udd39\")\n\n    if tool_name == \"Bash\":\n        cmd = tool_input.get(\"command\", \"\")\n        desc = tool_input.get(\"description\", \"\")\n        if desc:\n            return f\"{icon} Bash: {truncate(desc)}\"\n        return f\"{icon} Bash: {truncate(cmd, 60)}\""
    },
    {
      "name": "format_tool_result",
      "qualified_name": "scripts.ralph.watch-filter.py.format_tool_result",
      "file": "scripts/ralph/watch-filter.py",
      "line": 130,
      "language": "python",
      "unit_type": "function",
      "signature": "def format_tool_result(block: dict) -> Optional[str]",
      "docstring": "Format a tool_result block (errors only).\n\nArgs:\n    block: The full tool_result block (not just content)",
      "calls": ["truncate"],
      "called_by": ["process_event"],
      "cfg_summary": "complexity:4, blocks:10",
      "dfg_summary": "vars:10, def-use chains:10",
      "dependencies": "argparse, json, os, sys, typing",
      "code_preview": "def format_tool_result(block: dict) -> Optional[str]:\n    \"\"\"Format a tool_result block (errors only).\n\n    Args:\n        block: The full tool_result block (not just content)\n    \"\"\"\n    # Check is_error on the block itself\n    if block.get(\"is_error\"):\n        content = block.get(\"content\", \"\")\n        error_text = str(content) if content else \"unknown error\""
    },
    {
      "name": "process_event",
      "qualified_name": "scripts.ralph.watch-filter.py.process_event",
      "file": "scripts/ralph/watch-filter.py",
      "line": 152,
      "language": "python",
      "unit_type": "function",
      "signature": "def process_event(event: dict, verbose: bool) -> None",
      "docstring": "Process a single stream-json event.",
      "calls": ["format_tool_result", "truncate", "format_tool_use", "safe_print"],
      "called_by": ["main"],
      "cfg_summary": "complexity:12, blocks:28",
      "dfg_summary": "vars:20, def-use chains:31",
      "dependencies": "argparse, json, os, sys, typing",
      "code_preview": "def process_event(event: dict, verbose: bool) -> None:\n    \"\"\"Process a single stream-json event.\"\"\"\n    event_type = event.get(\"type\", \"\")\n\n    # Tool use events (assistant messages)\n    if event_type == \"assistant\":\n        message = event.get(\"message\", {})\n        content = message.get(\"content\", [])\n\n        for block in content:"
    },
    {
      "name": "main",
      "qualified_name": "scripts.ralph.watch-filter.py.main",
      "file": "scripts/ralph/watch-filter.py",
      "line": 192,
      "language": "python",
      "unit_type": "function",
      "signature": "def main() -> None",
      "docstring": "",
      "calls": [
        "cmd_rp_setup_review",
        "cmd_epic_set_plan",
        "cmd_migrate_state",
        "cmd_task_set_backend",
        "cmd_ralph_resume"
      ],
      "called_by": ["<module>", "<module>", "<module>"],
      "cfg_summary": "complexity:3, blocks:7",
      "dfg_summary": "vars:8, def-use chains:2",
      "dependencies": "argparse, json, os, sys, typing",
      "code_preview": "def main() -> None:\n    parser = argparse.ArgumentParser(description=\"Filter Claude stream-json output\")\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"Show text and thinking in addition to tool calls\",\n    )\n    args = parser.parse_args()\n\n    for line in sys.stdin:"
    },
    {
      "name": "get_repo_root",
      "qualified_name": "scripts.ralph.flowctl.py.get_repo_root",
      "file": "scripts/ralph/flowctl.py",
      "line": 81,
      "language": "python",
      "unit_type": "function",
      "signature": "def get_repo_root() -> Path",
      "docstring": "Find git repo root.",
      "calls": [],
      "called_by": [
        "find_active_runs",
        "cmd_codex_impl_review",
        "find_active_runs",
        "get_embedded_file_contents",
        "gather_context_hints"
      ],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:3, def-use chains:1",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def get_repo_root() -> Path:\n    \"\"\"Find git repo root.\"\"\"\n    try:\n        result = subprocess.run(\n            [\"git\", \"rev-parse\", \"--show-toplevel\"],\n            capture_output=True,\n            text=True,\n            check=True,\n        )\n        return Path(result.stdout.strip())"
    },
    {
      "name": "get_flow_dir",
      "qualified_name": "scripts.ralph.flowctl.py.get_flow_dir",
      "file": "scripts/ralph/flowctl.py",
      "line": 96,
      "language": "python",
      "unit_type": "function",
      "signature": "def get_flow_dir() -> Path",
      "docstring": "Get .flow/ directory path.",
      "calls": ["get_repo_root", "get_repo_root"],
      "called_by": [
        "load_task_definition",
        "cmd_epic_add_dep",
        "save_task_definition",
        "cmd_checkpoint_save",
        "cmd_task_create"
      ],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:2, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def get_flow_dir() -> Path:\n    \"\"\"Get .flow/ directory path.\"\"\""
    },
    {
      "name": "ensure_flow_exists",
      "qualified_name": "scripts.ralph.flowctl.py.ensure_flow_exists",
      "file": "scripts/ralph/flowctl.py",
      "line": 101,
      "language": "python",
      "unit_type": "function",
      "signature": "def ensure_flow_exists() -> bool",
      "docstring": "Check if .flow/ exists.",
      "calls": [],
      "called_by": [
        "cmd_checkpoint_save",
        "cmd_task_create",
        "cmd_codex_plan_review",
        "cmd_epic_set_plan",
        "cmd_epic_set_plan_review_status"
      ],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:1, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def ensure_flow_exists() -> bool:\n    \"\"\"Check if .flow/ exists.\"\"\""
    },
    {
      "name": "get_state_dir",
      "qualified_name": "scripts.ralph.flowctl.py.get_state_dir",
      "file": "scripts/ralph/flowctl.py",
      "line": 106,
      "language": "python",
      "unit_type": "function",
      "signature": "def get_state_dir() -> Path",
      "docstring": "Get state directory for runtime task state.\n\nResolution order:\n1. FLOW_STATE_DIR env var (explicit override for orchestrators)\n2. git common-dir (shared across all worktrees automatically)\n3. Fallback to .flow/state for non-git repos",
      "calls": ["get_flow_dir", "get_flow_dir"],
      "called_by": ["get_state_store", "cmd_state_path", "cmd_state_path", "get_state_store"],
      "cfg_summary": "complexity:2, blocks:6",
      "dfg_summary": "vars:7, def-use chains:1",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def get_state_dir() -> Path:\n    \"\"\"Get state directory for runtime task state.\n\n    Resolution order:\n    1. FLOW_STATE_DIR env var (explicit override for orchestrators)\n    2. git common-dir (shared across all worktrees automatically)\n    3. Fallback to .flow/state for non-git repos\n    \"\"\"\n    # 1. Explicit override\n    if state_dir := os.environ.get(\"FLOW_STATE_DIR\"):"
    },
    {
      "name": "get_state_store",
      "qualified_name": "scripts.ralph.flowctl.py.get_state_store",
      "file": "scripts/ralph/flowctl.py",
      "line": 213,
      "language": "python",
      "unit_type": "function",
      "signature": "def get_state_store() -> LocalFileStateStore",
      "docstring": "Get the state store instance.",
      "calls": ["get_state_dir", "get_state_dir", "LocalFileStateStore", "LocalFileStateStore"],
      "called_by": [
        "cmd_start",
        "cmd_migrate_state",
        "reset_task_runtime",
        "cmd_migrate_state",
        "cmd_checkpoint_restore"
      ],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:2, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def get_state_store() -> LocalFileStateStore:\n    \"\"\"Get the state store instance.\"\"\""
    },
    {
      "name": "load_task_definition",
      "qualified_name": "scripts.ralph.flowctl.py.load_task_definition",
      "file": "scripts/ralph/flowctl.py",
      "line": 221,
      "language": "python",
      "unit_type": "function",
      "signature": "def load_task_definition(task_id: str, use_json: bool) -> dict",
      "docstring": "Load task definition from tracked file (no runtime state).",
      "calls": ["get_flow_dir", "load_json_or_exit", "load_json_or_exit", "get_flow_dir"],
      "called_by": ["load_task_with_state", "cmd_start", "cmd_start", "load_task_with_state"],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:7, def-use chains:5",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def load_task_definition(task_id: str, use_json: bool = True) -> dict:\n    \"\"\"Load task definition from tracked file (no runtime state).\"\"\"\n    flow_dir = get_flow_dir()\n    def_path = flow_dir / TASKS_DIR / f\"{task_id}.json\""
    },
    {
      "name": "load_task_with_state",
      "qualified_name": "scripts.ralph.flowctl.py.load_task_with_state",
      "file": "scripts/ralph/flowctl.py",
      "line": 228,
      "language": "python",
      "unit_type": "function",
      "signature": "def load_task_with_state(task_id: str, use_json: bool) -> dict",
      "docstring": "Load task definition merged with runtime state.\n\nBackward compatible: if no state file exists, reads legacy runtime\nfields from definition file.",
      "calls": [
        "load_task_definition",
        "get_state_store",
        "get_state_store",
        "normalize_task",
        "load_task_definition"
      ],
      "called_by": ["cmd_status", "cmd_next", "cmd_status", "cmd_tasks", "cmd_task_reset"],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:11, def-use chains:13",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def load_task_with_state(task_id: str, use_json: bool = True) -> dict:\n    \"\"\"Load task definition merged with runtime state.\n\n    Backward compatible: if no state file exists, reads legacy runtime\n    fields from definition file.\n    \"\"\"\n    definition = load_task_definition(task_id, use_json=use_json)\n\n    # Load runtime state\n    store = get_state_store()"
    },
    {
      "name": "save_task_runtime",
      "qualified_name": "scripts.ralph.flowctl.py.save_task_runtime",
      "file": "scripts/ralph/flowctl.py",
      "line": 251,
      "language": "python",
      "unit_type": "function",
      "signature": "def save_task_runtime(task_id: str, updates: dict) -> None",
      "docstring": "Write runtime state only (merge with existing). Never touch definition file.",
      "calls": ["now_iso", "get_state_store", "now_iso", "get_state_store"],
      "called_by": ["cmd_block", "cmd_done", "cmd_block", "cmd_done"],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def save_task_runtime(task_id: str, updates: dict) -> None:\n    \"\"\"Write runtime state only (merge with existing). Never touch definition file.\"\"\"\n    store = get_state_store()\n    with store.lock_task(task_id):\n        current = store.load_runtime(task_id) or {\"status\": \"todo\"}\n        merged = {**current, **updates, \"updated_at\": now_iso()}"
    },
    {
      "name": "reset_task_runtime",
      "qualified_name": "scripts.ralph.flowctl.py.reset_task_runtime",
      "file": "scripts/ralph/flowctl.py",
      "line": 260,
      "language": "python",
      "unit_type": "function",
      "signature": "def reset_task_runtime(task_id: str) -> None",
      "docstring": "Reset runtime state to baseline (overwrite, not merge). Used by task reset.",
      "calls": ["now_iso", "get_state_store", "now_iso", "get_state_store"],
      "called_by": ["cmd_task_reset", "cmd_task_reset"],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:4, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def reset_task_runtime(task_id: str) -> None:\n    \"\"\"Reset runtime state to baseline (overwrite, not merge). Used by task reset.\"\"\"\n    store = get_state_store()\n    with store.lock_task(task_id):\n        # Overwrite with clean baseline state"
    },
    {
      "name": "delete_task_runtime",
      "qualified_name": "scripts.ralph.flowctl.py.delete_task_runtime",
      "file": "scripts/ralph/flowctl.py",
      "line": 268,
      "language": "python",
      "unit_type": "function",
      "signature": "def delete_task_runtime(task_id: str) -> None",
      "docstring": "Delete runtime state file entirely. Used by checkpoint restore when no runtime.",
      "calls": ["get_state_store", "get_state_store"],
      "called_by": ["cmd_checkpoint_restore", "cmd_checkpoint_restore"],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:4, def-use chains:6",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def delete_task_runtime(task_id: str) -> None:\n    \"\"\"Delete runtime state file entirely. Used by checkpoint restore when no runtime.\"\"\"\n    store = get_state_store()\n    with store.lock_task(task_id):\n        state_path = store._state_path(task_id)\n        if state_path.exists():"
    },
    {
      "name": "save_task_definition",
      "qualified_name": "scripts.ralph.flowctl.py.save_task_definition",
      "file": "scripts/ralph/flowctl.py",
      "line": 277,
      "language": "python",
      "unit_type": "function",
      "signature": "def save_task_definition(task_id: str, definition: dict) -> None",
      "docstring": "Write definition to tracked file (filters out runtime fields).",
      "calls": ["get_flow_dir", "get_flow_dir", "atomic_write_json", "atomic_write_json"],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def save_task_definition(task_id: str, definition: dict) -> None:\n    \"\"\"Write definition to tracked file (filters out runtime fields).\"\"\"\n    flow_dir = get_flow_dir()\n    def_path = flow_dir / TASKS_DIR / f\"{task_id}.json\"\n    # Filter out runtime fields\n    clean_def = {k: v for k, v in definition.items() if k not in RUNTIME_FIELDS}"
    },
    {
      "name": "get_default_config",
      "qualified_name": "scripts.ralph.flowctl.py.get_default_config",
      "file": "scripts/ralph/flowctl.py",
      "line": 286,
      "language": "python",
      "unit_type": "function",
      "signature": "def get_default_config() -> dict",
      "docstring": "Return default config structure.",
      "calls": [],
      "called_by": ["set_config", "cmd_init", "set_config", "cmd_init", "load_flow_config"],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:0, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def get_default_config() -> dict:\n    \"\"\"Return default config structure.\"\"\"\n    return {\n        \"memory\": {\"enabled\": True},\n        \"planSync\": {\"enabled\": True, \"crossEpic\": False},\n        \"review\": {\"backend\": None},"
    },
    {
      "name": "deep_merge",
      "qualified_name": "scripts.ralph.flowctl.py.deep_merge",
      "file": "scripts/ralph/flowctl.py",
      "line": 295,
      "language": "python",
      "unit_type": "function",
      "signature": "def deep_merge(base: dict, override: dict) -> dict",
      "docstring": "Deep merge override into base. Override values win for conflicts.",
      "calls": ["deep_merge", "deep_merge"],
      "called_by": ["cmd_init", "deep_merge", "deep_merge", "cmd_init", "load_flow_config"],
      "cfg_summary": "complexity:3, blocks:8",
      "dfg_summary": "vars:8, def-use chains:7",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def deep_merge(base: dict, override: dict) -> dict:\n    \"\"\"Deep merge override into base. Override values win for conflicts.\"\"\"\n    result = base.copy()\n    for key, value in override.items():\n        if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n            result[key] = deep_merge(result[key], value)\n        else:\n            result[key] = value"
    },
    {
      "name": "load_flow_config",
      "qualified_name": "scripts.ralph.flowctl.py.load_flow_config",
      "file": "scripts/ralph/flowctl.py",
      "line": 306,
      "language": "python",
      "unit_type": "function",
      "signature": "def load_flow_config() -> dict",
      "docstring": "Load .flow/config.json, merging with defaults for missing keys.",
      "calls": ["get_flow_dir", "get_flow_dir", "get_default_config", "deep_merge", "deep_merge"],
      "called_by": ["get_config", "get_config"],
      "cfg_summary": "complexity:3, blocks:8",
      "dfg_summary": "vars:10, def-use chains:7",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def load_flow_config() -> dict:\n    \"\"\"Load .flow/config.json, merging with defaults for missing keys.\"\"\"\n    config_path = get_flow_dir() / CONFIG_FILE\n    defaults = get_default_config()\n    if not config_path.exists():\n        return defaults\n    try:\n        data = json.loads(config_path.read_text(encoding=\"utf-8\"))\n        if isinstance(data, dict):\n            return deep_merge(defaults, data)"
    },
    {
      "name": "get_config",
      "qualified_name": "scripts.ralph.flowctl.py.get_config",
      "file": "scripts/ralph/flowctl.py",
      "line": 321,
      "language": "python",
      "unit_type": "function",
      "signature": "def get_config(key: str, default)",
      "docstring": "Get nested config value like 'memory.enabled'.",
      "calls": ["load_flow_config", "load_flow_config"],
      "called_by": [
        "cmd_config_get",
        "require_memory_enabled",
        "cmd_config_set",
        "cmd_config_get",
        "cmd_review_backend"
      ],
      "cfg_summary": "complexity:4, blocks:11",
      "dfg_summary": "vars:7, def-use chains:10",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def get_config(key: str, default=None):\n    \"\"\"Get nested config value like 'memory.enabled'.\"\"\"\n    config = load_flow_config()\n    for part in key.split(\".\"):\n        if not isinstance(config, dict):\n            return default\n        config = config.get(part, {})\n        if config == {}:\n            return default"
    },
    {
      "name": "set_config",
      "qualified_name": "scripts.ralph.flowctl.py.set_config",
      "file": "scripts/ralph/flowctl.py",
      "line": 333,
      "language": "python",
      "unit_type": "function",
      "signature": "def set_config(key: str, value) -> dict",
      "docstring": "Set nested config value and return updated config.",
      "calls": [
        "atomic_write_json",
        "atomic_write_json",
        "get_default_config",
        "get_default_config",
        "get_flow_dir"
      ],
      "called_by": ["cmd_config_set", "cmd_config_set"],
      "cfg_summary": "complexity:8, blocks:20",
      "dfg_summary": "vars:16, def-use chains:17",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def set_config(key: str, value) -> dict:\n    \"\"\"Set nested config value and return updated config.\"\"\"\n    config_path = get_flow_dir() / CONFIG_FILE\n    if config_path.exists():\n        try:\n            config = json.loads(config_path.read_text(encoding=\"utf-8\"))\n        except (json.JSONDecodeError, Exception):\n            config = get_default_config()\n    else:\n        config = get_default_config()"
    },
    {
      "name": "json_output",
      "qualified_name": "scripts.ralph.flowctl.py.json_output",
      "file": "scripts/ralph/flowctl.py",
      "line": 366,
      "language": "python",
      "unit_type": "function",
      "signature": "def json_output(data: dict, success: bool) -> None",
      "docstring": "Output JSON response.",
      "calls": [],
      "called_by": ["cmd_epics", "cmd_ralph_pause", "cmd_task_create", "cmd_dep_add", "cmd_init"],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def json_output(data: dict, success: bool = True) -> None:\n    \"\"\"Output JSON response.\"\"\"\n    result = {\"success\": success, **data}"
    },
    {
      "name": "error_exit",
      "qualified_name": "scripts.ralph.flowctl.py.error_exit",
      "file": "scripts/ralph/flowctl.py",
      "line": 372,
      "language": "python",
      "unit_type": "function",
      "signature": "def error_exit(message: str, code: int, use_json: bool) -> None",
      "docstring": "Output error and exit.",
      "calls": ["json_output", "json_output"],
      "called_by": [
        "cmd_task_show_backend",
        "cmd_checkpoint_save",
        "cmd_validate",
        "read_file_or_stdin",
        "require_memory_enabled"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:6, def-use chains:3",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def error_exit(message: str, code: int = 1, use_json: bool = True) -> None:\n    \"\"\"Output error and exit.\"\"\"\n    if use_json:\n        json_output({\"error\": message}, success=False)\n    else:\n        print(f\"Error: {message}\", file=sys.stderr)"
    },
    {
      "name": "now_iso",
      "qualified_name": "scripts.ralph.flowctl.py.now_iso",
      "file": "scripts/ralph/flowctl.py",
      "line": 381,
      "language": "python",
      "unit_type": "function",
      "signature": "def now_iso() -> str",
      "docstring": "Current timestamp in ISO format.",
      "calls": [],
      "called_by": [
        "cmd_epic_set_backend",
        "cmd_task_set_spec",
        "cmd_epic_set_branch",
        "cmd_epic_create",
        "cmd_epic_rm_dep"
      ],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:1, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def now_iso() -> str:\n    \"\"\"Current timestamp in ISO format.\"\"\""
    },
    {
      "name": "require_rp_cli",
      "qualified_name": "scripts.ralph.flowctl.py.require_rp_cli",
      "file": "scripts/ralph/flowctl.py",
      "line": 386,
      "language": "python",
      "unit_type": "function",
      "signature": "def require_rp_cli() -> str",
      "docstring": "Ensure rp-cli is available.",
      "calls": ["error_exit", "error_exit"],
      "called_by": ["run_rp_cli", "run_rp_cli"],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:3, def-use chains:2",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def require_rp_cli() -> str:\n    \"\"\"Ensure rp-cli is available.\"\"\"\n    rp = shutil.which(\"rp-cli\")\n    if not rp:\n        error_exit(\"rp-cli not found in PATH\", use_json=False, code=2)"
    },
    {
      "name": "run_rp_cli",
      "qualified_name": "scripts.ralph.flowctl.py.run_rp_cli",
      "file": "scripts/ralph/flowctl.py",
      "line": 394,
      "language": "python",
      "unit_type": "function",
      "signature": "def run_rp_cli(args: list[str], timeout: Optional[int]) -> subprocess.CompletedProcess",
      "docstring": "Run rp-cli with safe error handling and timeout.\n\nArgs:\n    args: Command arguments to pass to rp-cli\n    timeout: Max seconds to wait. Default from FLOW_RP_TIMEOUT env or 1200s (20min).",
      "calls": ["require_rp_cli", "error_exit", "error_exit", "require_rp_cli"],
      "called_by": [
        "cmd_rp_windows",
        "cmd_rp_prompt_export",
        "cmd_rp_prompt_set",
        "cmd_rp_ensure_workspace",
        "cmd_rp_prompt_get"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:12, def-use chains:3",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def run_rp_cli(\n    args: list[str], timeout: Optional[int] = None\n) -> subprocess.CompletedProcess:\n    \"\"\"Run rp-cli with safe error handling and timeout.\n\n    Args:\n        args: Command arguments to pass to rp-cli\n        timeout: Max seconds to wait. Default from FLOW_RP_TIMEOUT env or 1200s (20min).\n    \"\"\"\n    if timeout is None:"
    },
    {
      "name": "normalize_repo_root",
      "qualified_name": "scripts.ralph.flowctl.py.normalize_repo_root",
      "file": "scripts/ralph/flowctl.py",
      "line": 418,
      "language": "python",
      "unit_type": "function",
      "signature": "def normalize_repo_root(path: str) -> list[str]",
      "docstring": "Normalize repo root for window matching.",
      "calls": [],
      "called_by": [
        "cmd_rp_pick_window",
        "cmd_rp_setup_review",
        "cmd_rp_pick_window",
        "cmd_rp_setup_review"
      ],
      "cfg_summary": "complexity:3, blocks:7",
      "dfg_summary": "vars:7, def-use chains:9",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def normalize_repo_root(path: str) -> list[str]:\n    \"\"\"Normalize repo root for window matching.\"\"\"\n    root = os.path.realpath(path)\n    roots = [root]\n    if root.startswith(\"/private/tmp/\"):\n        roots.append(\"/tmp/\" + root[len(\"/private/tmp/\") :])\n    elif root.startswith(\"/tmp/\"):\n        roots.append(\"/private/tmp/\" + root[len(\"/tmp/\") :])"
    },
    {
      "name": "parse_windows",
      "qualified_name": "scripts.ralph.flowctl.py.parse_windows",
      "file": "scripts/ralph/flowctl.py",
      "line": 429,
      "language": "python",
      "unit_type": "function",
      "signature": "def parse_windows(raw: str) -> list[dict[str, Any]]",
      "docstring": "Parse rp-cli windows JSON.",
      "calls": ["error_exit", "error_exit"],
      "called_by": [
        "cmd_rp_pick_window",
        "cmd_rp_windows",
        "cmd_rp_setup_review",
        "cmd_rp_windows",
        "cmd_rp_pick_window"
      ],
      "cfg_summary": "complexity:3, blocks:7",
      "dfg_summary": "vars:8, def-use chains:4",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def parse_windows(raw: str) -> list[dict[str, Any]]:\n    \"\"\"Parse rp-cli windows JSON.\"\"\"\n    try:\n        data = json.loads(raw)\n        if isinstance(data, list):\n            return data\n        if (\n            isinstance(data, dict)\n            and \"windows\" in data\n            and isinstance(data[\"windows\"], list)"
    },
    {
      "name": "extract_window_id",
      "qualified_name": "scripts.ralph.flowctl.py.extract_window_id",
      "file": "scripts/ralph/flowctl.py",
      "line": 448,
      "language": "python",
      "unit_type": "function",
      "signature": "def extract_window_id(win: dict[str, Any]) -> Optional[int]",
      "docstring": "",
      "calls": [],
      "called_by": [
        "cmd_rp_setup_review",
        "cmd_rp_pick_window",
        "cmd_rp_setup_review",
        "cmd_rp_pick_window"
      ],
      "cfg_summary": "complexity:3, blocks:8",
      "dfg_summary": "vars:3, def-use chains:2",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def extract_window_id(win: dict[str, Any]) -> Optional[int]:\n    for key in (\"windowID\", \"windowId\", \"id\"):\n        if key in win:\n            try:\n                return int(win[key])\n            except Exception:\n                return None"
    },
    {
      "name": "extract_root_paths",
      "qualified_name": "scripts.ralph.flowctl.py.extract_root_paths",
      "file": "scripts/ralph/flowctl.py",
      "line": 458,
      "language": "python",
      "unit_type": "function",
      "signature": "def extract_root_paths(win: dict[str, Any]) -> list[str]",
      "docstring": "",
      "calls": [],
      "called_by": [
        "cmd_rp_pick_window",
        "cmd_rp_pick_window",
        "cmd_rp_setup_review",
        "cmd_rp_setup_review"
      ],
      "cfg_summary": "complexity:5, blocks:13",
      "dfg_summary": "vars:7, def-use chains:8",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def extract_root_paths(win: dict[str, Any]) -> list[str]:\n    for key in (\"rootFolderPaths\", \"rootFolders\", \"rootFolderPath\"):\n        if key in win:\n            val = win[key]\n            if isinstance(val, list):\n                return [str(v) for v in val]\n            if isinstance(val, str):\n                return [val]"
    },
    {
      "name": "parse_builder_tab",
      "qualified_name": "scripts.ralph.flowctl.py.parse_builder_tab",
      "file": "scripts/ralph/flowctl.py",
      "line": 469,
      "language": "python",
      "unit_type": "function",
      "signature": "def parse_builder_tab(output: str) -> str",
      "docstring": "",
      "calls": ["error_exit", "error_exit"],
      "called_by": [
        "cmd_rp_setup_review",
        "cmd_rp_builder",
        "cmd_rp_setup_review",
        "cmd_rp_builder"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:4, def-use chains:3",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def parse_builder_tab(output: str) -> str:\n    match = re.search(r\"Tab:\\s*([A-Za-z0-9-]+)\", output)\n    if not match:\n        error_exit(\"builder output missing Tab id\", use_json=False, code=2)"
    },
    {
      "name": "parse_chat_id",
      "qualified_name": "scripts.ralph.flowctl.py.parse_chat_id",
      "file": "scripts/ralph/flowctl.py",
      "line": 476,
      "language": "python",
      "unit_type": "function",
      "signature": "def parse_chat_id(output: str) -> Optional[str]",
      "docstring": "",
      "calls": [],
      "called_by": ["cmd_rp_chat_send", "cmd_rp_chat_send"],
      "cfg_summary": "complexity:3, blocks:8",
      "dfg_summary": "vars:3, def-use chains:6",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def parse_chat_id(output: str) -> Optional[str]:\n    match = re.search(r\"Chat\\s*:\\s*`([^`]+)`\", output)\n    if match:\n        return match.group(1)\n    match = re.search(r\"\\\"chat_id\\\"\\s*:\\s*\\\"([^\\\"]+)\\\"\", output)\n    if match:\n        return match.group(1)"
    },
    {
      "name": "build_chat_payload",
      "qualified_name": "scripts.ralph.flowctl.py.build_chat_payload",
      "file": "scripts/ralph/flowctl.py",
      "line": 486,
      "language": "python",
      "unit_type": "function",
      "signature": "def build_chat_payload(message: str, mode: str, new_chat: bool, chat_name: Optional[str], chat_id: Optional[str], selected_paths: Optional[list[str]]) -> str",
      "docstring": "",
      "calls": [],
      "called_by": ["cmd_rp_chat_send", "cmd_prep_chat", "cmd_prep_chat", "cmd_rp_chat_send"],
      "cfg_summary": "complexity:5, blocks:10",
      "dfg_summary": "vars:8, def-use chains:10",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def build_chat_payload(\n    message: str,\n    mode: str,\n    new_chat: bool = False,\n    chat_name: Optional[str] = None,\n    chat_id: Optional[str] = None,\n    selected_paths: Optional[list[str]] = None,\n) -> str:\n    payload: dict[str, Any] = {\n        \"message\": message,"
    },
    {
      "name": "is_supported_schema",
      "qualified_name": "scripts.ralph.flowctl.py.is_supported_schema",
      "file": "scripts/ralph/flowctl.py",
      "line": 509,
      "language": "python",
      "unit_type": "function",
      "signature": "def is_supported_schema(version: Any) -> bool",
      "docstring": "Check schema version compatibility.",
      "calls": [],
      "called_by": ["validate_flow_root", "cmd_detect", "cmd_detect", "validate_flow_root"],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:3, def-use chains:1",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def is_supported_schema(version: Any) -> bool:\n    \"\"\"Check schema version compatibility.\"\"\"\n    try:\n        return int(version) in SUPPORTED_SCHEMA_VERSIONS\n    except Exception:"
    },
    {
      "name": "atomic_write",
      "qualified_name": "scripts.ralph.flowctl.py.atomic_write",
      "file": "scripts/ralph/flowctl.py",
      "line": 517,
      "language": "python",
      "unit_type": "function",
      "signature": "def atomic_write(path: Path, content: str) -> None",
      "docstring": "Write file atomically via temp + rename.",
      "calls": [],
      "called_by": [
        "cmd_checkpoint_restore",
        "clear_task_evidence",
        "cmd_done",
        "cmd_epic_set_plan",
        "cmd_memory_init"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def atomic_write(path: Path, content: str) -> None:\n    \"\"\"Write file atomically via temp + rename.\"\"\"\n    path.parent.mkdir(parents=True, exist_ok=True)\n    fd, tmp_path = tempfile.mkstemp(dir=path.parent, suffix=\".tmp\")\n    try:\n        with os.fdopen(fd, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n        os.replace(tmp_path, path)\n    except Exception:\n        if os.path.exists(tmp_path):"
    },
    {
      "name": "atomic_write_json",
      "qualified_name": "scripts.ralph.flowctl.py.atomic_write_json",
      "file": "scripts/ralph/flowctl.py",
      "line": 531,
      "language": "python",
      "unit_type": "function",
      "signature": "def atomic_write_json(path: Path, data: dict) -> None",
      "docstring": "Write JSON file atomically with sorted keys.",
      "calls": ["atomic_write", "atomic_write"],
      "called_by": [
        "set_config",
        "cmd_task_create",
        "cmd_init",
        "set_config",
        "cmd_task_set_backend"
      ],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:5, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def atomic_write_json(path: Path, data: dict) -> None:\n    \"\"\"Write JSON file atomically with sorted keys.\"\"\"\n    content = json.dumps(data, indent=2, sort_keys=True) + \"\\n\""
    },
    {
      "name": "load_json",
      "qualified_name": "scripts.ralph.flowctl.py.load_json",
      "file": "scripts/ralph/flowctl.py",
      "line": 537,
      "language": "python",
      "unit_type": "function",
      "signature": "def load_json(path: Path) -> dict",
      "docstring": "Load JSON file.",
      "calls": [],
      "called_by": [
        "cmd_migrate_state",
        "find_dependents",
        "cmd_status",
        "cmd_checkpoint_save",
        "cmd_checkpoint_save"
      ],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:4, def-use chains:2",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def load_json(path: Path) -> dict:\n    \"\"\"Load JSON file.\"\"\"\n    with open(path, encoding=\"utf-8\") as f:"
    },
    {
      "name": "load_json_or_exit",
      "qualified_name": "scripts.ralph.flowctl.py.load_json_or_exit",
      "file": "scripts/ralph/flowctl.py",
      "line": 543,
      "language": "python",
      "unit_type": "function",
      "signature": "def load_json_or_exit(path: Path, what: str, use_json: bool) -> dict",
      "docstring": "Load JSON file with safe error handling.",
      "calls": ["error_exit", "error_exit"],
      "called_by": [
        "cmd_task_set_backend",
        "cmd_dep_add",
        "cmd_task_set_spec",
        "validate_epic",
        "cmd_next"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:8, def-use chains:6",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def load_json_or_exit(path: Path, what: str, use_json: bool = True) -> dict:\n    \"\"\"Load JSON file with safe error handling.\"\"\"\n    if not path.exists():\n        error_exit(f\"{what} missing: {path}\", use_json=use_json)\n    try:\n        with open(path, encoding=\"utf-8\") as f:\n            return json.load(f)\n    except json.JSONDecodeError as e:\n        error_exit(f\"{what} invalid JSON: {path} ({e})\", use_json=use_json)\n    except Exception as e:"
    },
    {
      "name": "read_text_or_exit",
      "qualified_name": "scripts.ralph.flowctl.py.read_text_or_exit",
      "file": "scripts/ralph/flowctl.py",
      "line": 556,
      "language": "python",
      "unit_type": "function",
      "signature": "def read_text_or_exit(path: Path, what: str, use_json: bool) -> str",
      "docstring": "Read text file with safe error handling.",
      "calls": ["error_exit", "error_exit"],
      "called_by": [
        "read_file_or_stdin",
        "cmd_rp_prompt_set",
        "cmd_task_set_spec",
        "cmd_task_set_spec",
        "cmd_prep_chat"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:5, def-use chains:5",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def read_text_or_exit(path: Path, what: str, use_json: bool = True) -> str:\n    \"\"\"Read text file with safe error handling.\"\"\"\n    if not path.exists():\n        error_exit(f\"{what} missing: {path}\", use_json=use_json)\n    try:\n        return path.read_text(encoding=\"utf-8\")\n    except Exception as e:"
    },
    {
      "name": "read_file_or_stdin",
      "qualified_name": "scripts.ralph.flowctl.py.read_file_or_stdin",
      "file": "scripts/ralph/flowctl.py",
      "line": 566,
      "language": "python",
      "unit_type": "function",
      "signature": "def read_file_or_stdin(file_arg: str, what: str, use_json: bool) -> str",
      "docstring": "Read from file path or stdin if file_arg is '-'.\n\nSupports heredoc usage: flowctl ... --file - <<'EOF'",
      "calls": ["read_text_or_exit", "error_exit", "error_exit", "read_text_or_exit"],
      "called_by": [
        "cmd_epic_set_plan",
        "cmd_task_set_spec",
        "cmd_task_set_spec",
        "_task_set_section",
        "_task_set_section"
      ],
      "cfg_summary": "complexity:2, blocks:5",
      "dfg_summary": "vars:8, def-use chains:6",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def read_file_or_stdin(file_arg: str, what: str, use_json: bool = True) -> str:\n    \"\"\"Read from file path or stdin if file_arg is '-'.\n\n    Supports heredoc usage: flowctl ... --file - <<'EOF'\n    \"\"\"\n    if file_arg == \"-\":\n        try:\n            return sys.stdin.read()\n        except Exception as e:\n            error_exit(f\"Failed to read {what} from stdin: {e}\", use_json=use_json)"
    },
    {
      "name": "generate_epic_suffix",
      "qualified_name": "scripts.ralph.flowctl.py.generate_epic_suffix",
      "file": "scripts/ralph/flowctl.py",
      "line": 579,
      "language": "python",
      "unit_type": "function",
      "signature": "def generate_epic_suffix(length: int) -> str",
      "docstring": "Generate random alphanumeric suffix for epic IDs (a-z0-9).",
      "calls": [],
      "called_by": ["cmd_epic_create", "cmd_epic_create"],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:6, def-use chains:2",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def generate_epic_suffix(length: int = 3) -> str:\n    \"\"\"Generate random alphanumeric suffix for epic IDs (a-z0-9).\"\"\"\n    alphabet = string.ascii_lowercase + string.digits"
    },
    {
      "name": "parse_id",
      "qualified_name": "scripts.ralph.flowctl.py.parse_id",
      "file": "scripts/ralph/flowctl.py",
      "line": 585,
      "language": "python",
      "unit_type": "function",
      "signature": "def parse_id(id_str: str) -> tuple[Optional[int], Optional[int]]",
      "docstring": "Parse ID into (epic_num, task_num). Returns (epic, None) for epic IDs.\n\nSupports both legacy (fn-N) and new (fn-N-xxx) formats with optional suffix.",
      "calls": [],
      "called_by": ["is_task_id", "sort_key", "cmd_epics", "cmd_ready", "is_epic_id"],
      "cfg_summary": "complexity:2, blocks:5",
      "dfg_summary": "vars:6, def-use chains:7",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def parse_id(id_str: str) -> tuple[Optional[int], Optional[int]]:\n    \"\"\"Parse ID into (epic_num, task_num). Returns (epic, None) for epic IDs.\n\n    Supports both legacy (fn-N) and new (fn-N-xxx) formats with optional suffix.\n    \"\"\"\n    match = re.match(r\"^fn-(\\d+)(?:-[a-z0-9]{3})?(?:\\.(\\d+))?$\", id_str)\n    if not match:\n        return None, None\n    epic = int(match.group(1))\n    task = int(match.group(2)) if match.group(2) else None"
    },
    {
      "name": "normalize_epic",
      "qualified_name": "scripts.ralph.flowctl.py.normalize_epic",
      "file": "scripts/ralph/flowctl.py",
      "line": 598,
      "language": "python",
      "unit_type": "function",
      "signature": "def normalize_epic(epic_data: dict) -> dict",
      "docstring": "Apply defaults for optional epic fields.",
      "calls": [],
      "called_by": [
        "cmd_task_show_backend",
        "cmd_epics",
        "cmd_epic_set_backend",
        "validate_epic",
        "cmd_next"
      ],
      "cfg_summary": "complexity:8, blocks:16",
      "dfg_summary": "vars:1, def-use chains:8",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def normalize_epic(epic_data: dict) -> dict:\n    \"\"\"Apply defaults for optional epic fields.\"\"\"\n    if \"plan_review_status\" not in epic_data:\n        epic_data[\"plan_review_status\"] = \"unknown\"\n    if \"plan_reviewed_at\" not in epic_data:\n        epic_data[\"plan_reviewed_at\"] = None\n    if \"branch_name\" not in epic_data:\n        epic_data[\"branch_name\"] = None\n    if \"depends_on_epics\" not in epic_data:\n        epic_data[\"depends_on_epics\"] = []"
    },
    {
      "name": "normalize_task",
      "qualified_name": "scripts.ralph.flowctl.py.normalize_task",
      "file": "scripts/ralph/flowctl.py",
      "line": 618,
      "language": "python",
      "unit_type": "function",
      "signature": "def normalize_task(task_data: dict) -> dict",
      "docstring": "Apply defaults for optional task fields and migrate legacy keys.",
      "calls": [],
      "called_by": [
        "cmd_start",
        "cmd_task_show_backend",
        "cmd_start",
        "cmd_task_show_backend",
        "load_task_with_state"
      ],
      "cfg_summary": "complexity:6, blocks:12",
      "dfg_summary": "vars:1, def-use chains:7",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def normalize_task(task_data: dict) -> dict:\n    \"\"\"Apply defaults for optional task fields and migrate legacy keys.\"\"\"\n    if \"priority\" not in task_data:\n        task_data[\"priority\"] = None\n    # Migrate legacy 'deps' key to 'depends_on'\n    if \"depends_on\" not in task_data:\n        task_data[\"depends_on\"] = task_data.get(\"deps\", [])\n    # Backend spec defaults (for orchestration products like flow-swarm)\n    if \"impl\" not in task_data:\n        task_data[\"impl\"] = None"
    },
    {
      "name": "task_priority",
      "qualified_name": "scripts.ralph.flowctl.py.task_priority",
      "file": "scripts/ralph/flowctl.py",
      "line": 635,
      "language": "python",
      "unit_type": "function",
      "signature": "def task_priority(task_data: dict) -> int",
      "docstring": "Priority for sorting (None -> 999).",
      "calls": [],
      "called_by": ["sort_key", "sort_key", "cmd_ready", "cmd_next", "cmd_next"],
      "cfg_summary": "complexity:2, blocks:5",
      "dfg_summary": "vars:2, def-use chains:2",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def task_priority(task_data: dict) -> int:\n    \"\"\"Priority for sorting (None -> 999).\"\"\"\n    try:\n        if task_data.get(\"priority\") is None:\n            return 999\n        return int(task_data.get(\"priority\"))\n    except Exception:"
    },
    {
      "name": "is_epic_id",
      "qualified_name": "scripts.ralph.flowctl.py.is_epic_id",
      "file": "scripts/ralph/flowctl.py",
      "line": 645,
      "language": "python",
      "unit_type": "function",
      "signature": "def is_epic_id(id_str: str) -> bool",
      "docstring": "Check if ID is an epic ID (fn-N).",
      "calls": ["parse_id", "parse_id"],
      "called_by": [
        "cmd_epic_close",
        "cmd_show",
        "cmd_next",
        "cmd_task_create",
        "cmd_codex_plan_review"
      ],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:4, def-use chains:3",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def is_epic_id(id_str: str) -> bool:\n    \"\"\"Check if ID is an epic ID (fn-N).\"\"\"\n    epic, task = parse_id(id_str)"
    },
    {
      "name": "is_task_id",
      "qualified_name": "scripts.ralph.flowctl.py.is_task_id",
      "file": "scripts/ralph/flowctl.py",
      "line": 651,
      "language": "python",
      "unit_type": "function",
      "signature": "def is_task_id(id_str: str) -> bool",
      "docstring": "Check if ID is a task ID (fn-N.M).",
      "calls": ["parse_id", "parse_id"],
      "called_by": ["_task_set_section", "cmd_list", "cmd_block", "cmd_epics", "cmd_migrate_state"],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:4, def-use chains:3",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def is_task_id(id_str: str) -> bool:\n    \"\"\"Check if ID is a task ID (fn-N.M).\"\"\"\n    epic, task = parse_id(id_str)"
    },
    {
      "name": "epic_id_from_task",
      "qualified_name": "scripts.ralph.flowctl.py.epic_id_from_task",
      "file": "scripts/ralph/flowctl.py",
      "line": 657,
      "language": "python",
      "unit_type": "function",
      "signature": "def epic_id_from_task(task_id: str) -> str",
      "docstring": "Extract epic ID from task ID. Raises ValueError if invalid.\n\nPreserves suffix: fn-5-x7k.3 -> fn-5-x7k",
      "calls": ["parse_id", "parse_id"],
      "called_by": [
        "cmd_task_create",
        "cmd_dep_add",
        "cmd_task_reset",
        "cmd_task_reset",
        "cmd_dep_add"
      ],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:5, def-use chains:5",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def epic_id_from_task(task_id: str) -> str:\n    \"\"\"Extract epic ID from task ID. Raises ValueError if invalid.\n\n    Preserves suffix: fn-5-x7k.3 -> fn-5-x7k\n    \"\"\"\n    epic, task = parse_id(task_id)\n    if epic is None or task is None:\n        raise ValueError(f\"Invalid task ID: {task_id}\")\n    # Split on '.' and take epic part (preserves suffix if present)"
    },
    {
      "name": "get_changed_files",
      "qualified_name": "scripts.ralph.flowctl.py.get_changed_files",
      "file": "scripts/ralph/flowctl.py",
      "line": 672,
      "language": "python",
      "unit_type": "function",
      "signature": "def get_changed_files(base_branch: str) -> list[str]",
      "docstring": "Get files changed between base branch and HEAD (committed changes only).",
      "calls": ["get_repo_root", "get_repo_root"],
      "called_by": [
        "cmd_codex_impl_review",
        "cmd_codex_impl_review",
        "gather_context_hints",
        "gather_context_hints"
      ],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:5, def-use chains:2",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def get_changed_files(base_branch: str) -> list[str]:\n    \"\"\"Get files changed between base branch and HEAD (committed changes only).\"\"\"\n    try:\n        result = subprocess.run(\n            [\"git\", \"diff\", \"--name-only\", f\"{base_branch}..HEAD\"],\n            capture_output=True,\n            text=True,\n            check=True,\n            cwd=get_repo_root(),\n        )"
    },
    {
      "name": "get_embedded_file_contents",
      "qualified_name": "scripts.ralph.flowctl.py.get_embedded_file_contents",
      "file": "scripts/ralph/flowctl.py",
      "line": 687,
      "language": "python",
      "unit_type": "function",
      "signature": "def get_embedded_file_contents(file_paths: list[str]) -> tuple[str, dict]",
      "docstring": "Read and embed file contents for codex review prompts.\n\nReturns:\n    tuple: (embedded_content_str, stats_dict)\n    - embedded_content_str: Formatted string with file contents and warnings\n    - stats_dict: {\"embedded\": int, \"total\": int, \"bytes\": int,\n                   \"binary_skipped\": list, \"deleted_skipped\": list,\n                   \"outside_repo_skipped\": list, \"budget_skipped\": list}\n\nArgs:\n    file_paths: List of file paths (relative to repo root)\n\nEnvironment:\n    FLOW_CODEX_EMBED_MAX_BYTES: Total byte budget for embedded files.\n        Default 102400 (100KB). Set to 0 for unlimited.",
      "calls": ["get_repo_root", "get_repo_root"],
      "called_by": [
        "cmd_codex_impl_review",
        "cmd_codex_plan_review",
        "cmd_codex_plan_review",
        "cmd_codex_impl_review"
      ],
      "cfg_summary": "complexity:21, blocks:51",
      "dfg_summary": "vars:45, def-use chains:88",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def get_embedded_file_contents(file_paths: list[str]) -> tuple[str, dict]:\n    \"\"\"Read and embed file contents for codex review prompts.\n\n    Returns:\n        tuple: (embedded_content_str, stats_dict)\n        - embedded_content_str: Formatted string with file contents and warnings\n        - stats_dict: {\"embedded\": int, \"total\": int, \"bytes\": int,\n                       \"binary_skipped\": list, \"deleted_skipped\": list,\n                       \"outside_repo_skipped\": list, \"budget_skipped\": list}\n"
    },
    {
      "name": "extract_symbols_from_file",
      "qualified_name": "scripts.ralph.flowctl.py.extract_symbols_from_file",
      "file": "scripts/ralph/flowctl.py",
      "line": 900,
      "language": "python",
      "unit_type": "function",
      "signature": "def extract_symbols_from_file(file_path: Path) -> list[str]",
      "docstring": "Extract exported/defined symbols from a file (functions, classes, consts).\n\nReturns empty list on any error - never crashes.",
      "calls": [],
      "called_by": ["gather_context_hints", "gather_context_hints"],
      "cfg_summary": "complexity:28, blocks:81",
      "dfg_summary": "vars:10, def-use chains:68",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def extract_symbols_from_file(file_path: Path) -> list[str]:\n    \"\"\"Extract exported/defined symbols from a file (functions, classes, consts).\n\n    Returns empty list on any error - never crashes.\n    \"\"\"\n    try:\n        if not file_path.exists():\n            return []\n        content = file_path.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        if not content:"
    },
    {
      "name": "find_references",
      "qualified_name": "scripts.ralph.flowctl.py.find_references",
      "file": "scripts/ralph/flowctl.py",
      "line": 1020,
      "language": "python",
      "unit_type": "function",
      "signature": "def find_references(symbol: str, exclude_files: list[str], max_results: int) -> list[tuple[str, int]]",
      "docstring": "Find files referencing a symbol. Returns [(path, line_number), ...].",
      "calls": ["get_repo_root", "get_repo_root"],
      "called_by": ["gather_context_hints", "gather_context_hints"],
      "cfg_summary": "complexity:6, blocks:16",
      "dfg_summary": "vars:14, def-use chains:5",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def find_references(\n    symbol: str, exclude_files: list[str], max_results: int = 3\n) -> list[tuple[str, int]]:\n    \"\"\"Find files referencing a symbol. Returns [(path, line_number), ...].\"\"\"\n    repo_root = get_repo_root()\n    try:\n        result = subprocess.run(\n            [\n                \"git\",\n                \"grep\","
    },
    {
      "name": "gather_context_hints",
      "qualified_name": "scripts.ralph.flowctl.py.gather_context_hints",
      "file": "scripts/ralph/flowctl.py",
      "line": 1085,
      "language": "python",
      "unit_type": "function",
      "signature": "def gather_context_hints(base_branch: str, max_hints: int) -> str",
      "docstring": "Gather context hints for code review.\n\nReturns formatted hints like:\nConsider these related files:\n- src/auth.ts:15 - references validateToken\n- src/types.ts:42 - references User",
      "calls": [
        "find_references",
        "find_references",
        "get_repo_root",
        "extract_symbols_from_file",
        "get_changed_files"
      ],
      "called_by": [
        "cmd_codex_plan_review",
        "cmd_codex_plan_review",
        "cmd_codex_impl_review",
        "cmd_codex_impl_review"
      ],
      "cfg_summary": "complexity:11, blocks:30",
      "dfg_summary": "vars:19, def-use chains:21",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def gather_context_hints(base_branch: str, max_hints: int = 15) -> str:\n    \"\"\"Gather context hints for code review.\n\n    Returns formatted hints like:\n    Consider these related files:\n    - src/auth.ts:15 - references validateToken\n    - src/types.ts:42 - references User\n    \"\"\"\n    changed_files = get_changed_files(base_branch)\n    if not changed_files:"
    },
    {
      "name": "require_codex",
      "qualified_name": "scripts.ralph.flowctl.py.require_codex",
      "file": "scripts/ralph/flowctl.py",
      "line": 1133,
      "language": "python",
      "unit_type": "function",
      "signature": "def require_codex() -> str",
      "docstring": "Ensure codex CLI is available. Returns path to codex.",
      "calls": ["error_exit", "error_exit"],
      "called_by": ["run_codex_exec", "run_codex_exec"],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:3, def-use chains:2",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def require_codex() -> str:\n    \"\"\"Ensure codex CLI is available. Returns path to codex.\"\"\"\n    codex = shutil.which(\"codex\")\n    if not codex:\n        error_exit(\"codex not found in PATH\", use_json=False, code=2)"
    },
    {
      "name": "get_codex_version",
      "qualified_name": "scripts.ralph.flowctl.py.get_codex_version",
      "file": "scripts/ralph/flowctl.py",
      "line": 1141,
      "language": "python",
      "unit_type": "function",
      "signature": "def get_codex_version() -> Optional[str]",
      "docstring": "Get codex version, or None if not available.",
      "calls": [],
      "called_by": ["cmd_codex_check", "cmd_codex_check"],
      "cfg_summary": "complexity:2, blocks:5",
      "dfg_summary": "vars:7, def-use chains:7",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def get_codex_version() -> Optional[str]:\n    \"\"\"Get codex version, or None if not available.\"\"\"\n    codex = shutil.which(\"codex\")\n    if not codex:\n        return None\n    try:\n        result = subprocess.run(\n            [codex, \"--version\"],\n            capture_output=True,\n            text=True,"
    },
    {
      "name": "resolve_codex_sandbox",
      "qualified_name": "scripts.ralph.flowctl.py.resolve_codex_sandbox",
      "file": "scripts/ralph/flowctl.py",
      "line": 1164,
      "language": "python",
      "unit_type": "function",
      "signature": "def resolve_codex_sandbox(sandbox: str) -> str",
      "docstring": "Resolve sandbox mode, handling 'auto' based on platform.\n\nPriority: CLI --sandbox (if not 'auto') > CODEX_SANDBOX env var > platform default.\n'auto' resolves to 'danger-full-access' on Windows (where sandbox blocks reads),\nand 'read-only' on Unix.\n\nReturns the resolved sandbox value (never returns 'auto').\nRaises ValueError if invalid mode specified.",
      "calls": [],
      "called_by": [
        "cmd_codex_impl_review",
        "cmd_codex_plan_review",
        "cmd_codex_plan_review",
        "cmd_codex_impl_review"
      ],
      "cfg_summary": "complexity:6, blocks:14",
      "dfg_summary": "vars:6, def-use chains:11",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def resolve_codex_sandbox(sandbox: str) -> str:\n    \"\"\"Resolve sandbox mode, handling 'auto' based on platform.\n\n    Priority: CLI --sandbox (if not 'auto') > CODEX_SANDBOX env var > platform default.\n    'auto' resolves to 'danger-full-access' on Windows (where sandbox blocks reads),\n    and 'read-only' on Unix.\n\n    Returns the resolved sandbox value (never returns 'auto').\n    Raises ValueError if invalid mode specified.\n    \"\"\""
    },
    {
      "name": "run_codex_exec",
      "qualified_name": "scripts.ralph.flowctl.py.run_codex_exec",
      "file": "scripts/ralph/flowctl.py",
      "line": 1201,
      "language": "python",
      "unit_type": "function",
      "signature": "def run_codex_exec(prompt: str, session_id: Optional[str], sandbox: str, model: Optional[str]) -> tuple[str, Optional[str], int, str]",
      "docstring": "Run codex exec and return (stdout, thread_id, exit_code, stderr).\n\nIf session_id provided, tries to resume. Falls back to new session if resume fails.\nModel: FLOW_CODEX_MODEL env > parameter > default (gpt-5.2 + high reasoning).\n\nNote: Prompt is passed via stdin (using '-') to avoid Windows command-line\nlength limits (~8191 chars) and special character escaping issues. (GH-35)\n\nReturns:\n    tuple: (stdout, thread_id, exit_code, stderr)\n    - exit_code is 0 for success, non-zero for failure\n    - stderr contains error output from the process",
      "calls": ["parse_codex_thread_id", "parse_codex_thread_id", "require_codex", "require_codex"],
      "called_by": [
        "cmd_codex_impl_review",
        "cmd_codex_plan_review",
        "cmd_codex_plan_review",
        "cmd_codex_impl_review"
      ],
      "cfg_summary": "complexity:2, blocks:5",
      "dfg_summary": "vars:15, def-use chains:18",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def run_codex_exec(\n    prompt: str,\n    session_id: Optional[str] = None,\n    sandbox: str = \"read-only\",\n    model: Optional[str] = None,\n) -> tuple[str, Optional[str], int, str]:\n    \"\"\"Run codex exec and return (stdout, thread_id, exit_code, stderr).\n\n    If session_id provided, tries to resume. Falls back to new session if resume fails.\n    Model: FLOW_CODEX_MODEL env > parameter > default (gpt-5.2 + high reasoning)."
    },
    {
      "name": "parse_codex_thread_id",
      "qualified_name": "scripts.ralph.flowctl.py.parse_codex_thread_id",
      "file": "scripts/ralph/flowctl.py",
      "line": 1278,
      "language": "python",
      "unit_type": "function",
      "signature": "def parse_codex_thread_id(output: str) -> Optional[str]",
      "docstring": "Extract thread_id from codex --json output.\n\nLooks for: {\"type\":\"thread.started\",\"thread_id\":\"019baa19-...\"}",
      "calls": [],
      "called_by": ["run_codex_exec", "run_codex_exec"],
      "cfg_summary": "complexity:4, blocks:11",
      "dfg_summary": "vars:4, def-use chains:6",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def parse_codex_thread_id(output: str) -> Optional[str]:\n    \"\"\"Extract thread_id from codex --json output.\n\n    Looks for: {\"type\":\"thread.started\",\"thread_id\":\"019baa19-...\"}\n    \"\"\"\n    for line in output.split(\"\\n\"):\n        if not line.strip():\n            continue\n        try:\n            data = json.loads(line)"
    },
    {
      "name": "parse_codex_verdict",
      "qualified_name": "scripts.ralph.flowctl.py.parse_codex_verdict",
      "file": "scripts/ralph/flowctl.py",
      "line": 1295,
      "language": "python",
      "unit_type": "function",
      "signature": "def parse_codex_verdict(output: str) -> Optional[str]",
      "docstring": "Extract verdict from codex output.\n\nLooks for <verdict>SHIP</verdict> or <verdict>NEEDS_WORK</verdict>",
      "calls": [],
      "called_by": [
        "cmd_codex_impl_review",
        "cmd_codex_plan_review",
        "cmd_codex_plan_review",
        "cmd_codex_impl_review"
      ],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:3, def-use chains:3",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def parse_codex_verdict(output: str) -> Optional[str]:\n    \"\"\"Extract verdict from codex output.\n\n    Looks for <verdict>SHIP</verdict> or <verdict>NEEDS_WORK</verdict>\n    \"\"\"\n    match = re.search(r\"<verdict>(SHIP|NEEDS_WORK|MAJOR_RETHINK)</verdict>\", output)"
    },
    {
      "name": "is_sandbox_failure",
      "qualified_name": "scripts.ralph.flowctl.py.is_sandbox_failure",
      "file": "scripts/ralph/flowctl.py",
      "line": 1304,
      "language": "python",
      "unit_type": "function",
      "signature": "def is_sandbox_failure(exit_code: int, stdout: str, stderr: str) -> bool",
      "docstring": "Detect if codex failure is due to sandbox restrictions.\n\nReturns True if the failure appears to be caused by sandbox policy blocking\noperations rather than actual code issues. Checks:\n1. exit_code != 0 (must be a failure)\n2. Error patterns in stderr or JSON item failures in stdout\n\nOnly matches error patterns in actual error contexts (stderr, failed items),\nnot in regular output that might mention these phrases.",
      "calls": [],
      "called_by": [
        "cmd_codex_plan_review",
        "cmd_codex_impl_review",
        "cmd_codex_impl_review",
        "cmd_codex_plan_review"
      ],
      "cfg_summary": "complexity:11, blocks:29",
      "dfg_summary": "vars:13, def-use chains:13",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def is_sandbox_failure(exit_code: int, stdout: str, stderr: str) -> bool:\n    \"\"\"Detect if codex failure is due to sandbox restrictions.\n\n    Returns True if the failure appears to be caused by sandbox policy blocking\n    operations rather than actual code issues. Checks:\n    1. exit_code != 0 (must be a failure)\n    2. Error patterns in stderr or JSON item failures in stdout\n\n    Only matches error patterns in actual error contexts (stderr, failed items),\n    not in regular output that might mention these phrases."
    },
    {
      "name": "build_review_prompt",
      "qualified_name": "scripts.ralph.flowctl.py.build_review_prompt",
      "file": "scripts/ralph/flowctl.py",
      "line": 1361,
      "language": "python",
      "unit_type": "function",
      "signature": "def build_review_prompt(review_type: str, spec_content: str, context_hints: str, diff_summary: str, task_specs: str, embedded_files: str, diff_content: str, files_embedded: bool) -> str",
      "docstring": "Build XML-structured review prompt for codex.\n\nreview_type: 'impl' or 'plan'\ntask_specs: Combined task spec content (plan reviews only)\nembedded_files: Pre-read file contents for codex sandbox mode\ndiff_content: Actual git diff output (impl reviews only)\nfiles_embedded: True if files are embedded (Windows), False if Codex can read from disk (Unix)\n\nUses same Carmack-level criteria as RepoPrompt workflow to ensure parity.",
      "calls": [],
      "called_by": [
        "cmd_codex_impl_review",
        "cmd_codex_plan_review",
        "cmd_codex_plan_review",
        "cmd_codex_impl_review"
      ],
      "cfg_summary": "complexity:8, blocks:18",
      "dfg_summary": "vars:11, def-use chains:27",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def build_review_prompt(\n    review_type: str,\n    spec_content: str,\n    context_hints: str,\n    diff_summary: str = \"\",\n    task_specs: str = \"\",\n    embedded_files: str = \"\",\n    diff_content: str = \"\",\n    files_embedded: bool = False,\n) -> str:"
    },
    {
      "name": "build_rereview_preamble",
      "qualified_name": "scripts.ralph.flowctl.py.build_rereview_preamble",
      "file": "scripts/ralph/flowctl.py",
      "line": 1576,
      "language": "python",
      "unit_type": "function",
      "signature": "def build_rereview_preamble(changed_files: list[str], review_type: str, files_embedded: bool) -> str",
      "docstring": "Build preamble for re-reviews.\n\nWhen resuming a Codex session, file contents may be cached from the original review.\nThis preamble explicitly instructs Codex how to access updated content.\n\nfiles_embedded: True if files are embedded (Windows), False if Codex can read from disk (Unix)",
      "calls": [],
      "called_by": [
        "cmd_codex_plan_review",
        "cmd_codex_impl_review",
        "cmd_codex_impl_review",
        "cmd_codex_plan_review"
      ],
      "cfg_summary": "complexity:5, blocks:14",
      "dfg_summary": "vars:7, def-use chains:8",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def build_rereview_preamble(\n    changed_files: list[str], review_type: str, files_embedded: bool = True\n) -> str:\n    \"\"\"Build preamble for re-reviews.\n\n    When resuming a Codex session, file contents may be cached from the original review.\n    This preamble explicitly instructs Codex how to access updated content.\n\n    files_embedded: True if files are embedded (Windows), False if Codex can read from disk (Unix)\n    \"\"\""
    },
    {
      "name": "get_actor",
      "qualified_name": "scripts.ralph.flowctl.py.get_actor",
      "file": "scripts/ralph/flowctl.py",
      "line": 1658,
      "language": "python",
      "unit_type": "function",
      "signature": "def get_actor() -> str",
      "docstring": "Determine current actor for soft-claim semantics.\n\nPriority:\n1. FLOW_ACTOR env var\n2. git config user.email\n3. git config user.name\n4. $USER env var\n5. \"unknown\"",
      "calls": [],
      "called_by": ["cmd_ready", "cmd_done", "cmd_start", "cmd_done", "cmd_next"],
      "cfg_summary": "complexity:5, blocks:14",
      "dfg_summary": "vars:7, def-use chains:2",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def get_actor() -> str:\n    \"\"\"Determine current actor for soft-claim semantics.\n\n    Priority:\n    1. FLOW_ACTOR env var\n    2. git config user.email\n    3. git config user.name\n    4. $USER env var\n    5. \"unknown\"\n    \"\"\""
    },
    {
      "name": "scan_max_epic_id",
      "qualified_name": "scripts.ralph.flowctl.py.scan_max_epic_id",
      "file": "scripts/ralph/flowctl.py",
      "line": 1700,
      "language": "python",
      "unit_type": "function",
      "signature": "def scan_max_epic_id(flow_dir: Path) -> int",
      "docstring": "Scan .flow/epics/ to find max epic number. Returns 0 if none exist.\n\nHandles both legacy (fn-N.json) and new (fn-N-xxx.json) formats.",
      "calls": [],
      "called_by": ["cmd_epic_create", "cmd_epic_create"],
      "cfg_summary": "complexity:4, blocks:10",
      "dfg_summary": "vars:10, def-use chains:9",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def scan_max_epic_id(flow_dir: Path) -> int:\n    \"\"\"Scan .flow/epics/ to find max epic number. Returns 0 if none exist.\n\n    Handles both legacy (fn-N.json) and new (fn-N-xxx.json) formats.\n    \"\"\"\n    epics_dir = flow_dir / EPICS_DIR\n    if not epics_dir.exists():\n        return 0\n\n    max_n = 0"
    },
    {
      "name": "scan_max_task_id",
      "qualified_name": "scripts.ralph.flowctl.py.scan_max_task_id",
      "file": "scripts/ralph/flowctl.py",
      "line": 1718,
      "language": "python",
      "unit_type": "function",
      "signature": "def scan_max_task_id(flow_dir: Path, epic_id: str) -> int",
      "docstring": "Scan .flow/tasks/ to find max task number for an epic. Returns 0 if none exist.",
      "calls": [],
      "called_by": ["cmd_task_create", "cmd_task_create"],
      "cfg_summary": "complexity:4, blocks:10",
      "dfg_summary": "vars:11, def-use chains:11",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def scan_max_task_id(flow_dir: Path, epic_id: str) -> int:\n    \"\"\"Scan .flow/tasks/ to find max task number for an epic. Returns 0 if none exist.\"\"\"\n    tasks_dir = flow_dir / TASKS_DIR\n    if not tasks_dir.exists():\n        return 0\n\n    max_m = 0\n    for task_file in tasks_dir.glob(f\"{epic_id}.*.json\"):\n        match = re.match(rf\"^{re.escape(epic_id)}\\.(\\d+)\\.json$\", task_file.name)\n        if match:"
    },
    {
      "name": "require_keys",
      "qualified_name": "scripts.ralph.flowctl.py.require_keys",
      "file": "scripts/ralph/flowctl.py",
      "line": 1733,
      "language": "python",
      "unit_type": "function",
      "signature": "def require_keys(obj: dict, keys: list[str], what: str, use_json: bool) -> None",
      "docstring": "Validate dict has required keys. Exits on missing keys.",
      "calls": ["error_exit", "error_exit"],
      "called_by": [],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:7, def-use chains:6",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def require_keys(obj: dict, keys: list[str], what: str, use_json: bool = True) -> None:\n    \"\"\"Validate dict has required keys. Exits on missing keys.\"\"\"\n    missing = [k for k in keys if k not in obj]\n    if missing:\n        error_exit(\n            f\"{what} missing required keys: {', '.join(missing)}\", use_json=use_json"
    },
    {
      "name": "create_epic_spec",
      "qualified_name": "scripts.ralph.flowctl.py.create_epic_spec",
      "file": "scripts/ralph/flowctl.py",
      "line": 1745,
      "language": "python",
      "unit_type": "function",
      "signature": "def create_epic_spec(id_str: str, title: str) -> str",
      "docstring": "Create epic spec markdown content.",
      "calls": [],
      "called_by": ["cmd_epic_create", "cmd_epic_create"],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:2, def-use chains:2",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def create_epic_spec(id_str: str, title: str) -> str:\n    \"\"\"Create epic spec markdown content.\"\"\"\n    return f\"\"\"# {id_str} {title}\n\n## Overview\nTBD\n\n## Scope\nTBD\n"
    },
    {
      "name": "create_task_spec",
      "qualified_name": "scripts.ralph.flowctl.py.create_task_spec",
      "file": "scripts/ralph/flowctl.py",
      "line": 1770,
      "language": "python",
      "unit_type": "function",
      "signature": "def create_task_spec(id_str: str, title: str, acceptance: Optional[str]) -> str",
      "docstring": "Create task spec markdown content.",
      "calls": [],
      "called_by": ["cmd_task_create", "cmd_task_create"],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:4, def-use chains:4",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def create_task_spec(id_str: str, title: str, acceptance: Optional[str] = None) -> str:\n    \"\"\"Create task spec markdown content.\"\"\"\n    acceptance_content = acceptance if acceptance else \"- [ ] TBD\"\n    return f\"\"\"# {id_str} {title}\n\n## Description\nTBD\n\n## Acceptance\n{acceptance_content}"
    },
    {
      "name": "patch_task_section",
      "qualified_name": "scripts.ralph.flowctl.py.patch_task_section",
      "file": "scripts/ralph/flowctl.py",
      "line": 1791,
      "language": "python",
      "unit_type": "function",
      "signature": "def patch_task_section(content: str, section: str, new_content: str) -> str",
      "docstring": "Patch a specific section in task spec. Preserves other sections.\n\nRaises ValueError on invalid content (duplicate/missing headings).",
      "calls": [],
      "called_by": [
        "cmd_task_set_spec",
        "cmd_task_set_spec",
        "_task_set_section",
        "_task_set_section",
        "cmd_block"
      ],
      "cfg_summary": "complexity:8, blocks:19",
      "dfg_summary": "vars:16, def-use chains:22",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def patch_task_section(content: str, section: str, new_content: str) -> str:\n    \"\"\"Patch a specific section in task spec. Preserves other sections.\n\n    Raises ValueError on invalid content (duplicate/missing headings).\n    \"\"\"\n    # Check for duplicate headings first (defensive)\n    pattern = rf\"^{re.escape(section)}\\s*$\"\n    matches = len(re.findall(pattern, content, flags=re.MULTILINE))\n    if matches > 1:\n        raise ValueError("
    },
    {
      "name": "get_task_section",
      "qualified_name": "scripts.ralph.flowctl.py.get_task_section",
      "file": "scripts/ralph/flowctl.py",
      "line": 1836,
      "language": "python",
      "unit_type": "function",
      "signature": "def get_task_section(content: str, section: str) -> str",
      "docstring": "Get content under a task section heading.",
      "calls": [],
      "called_by": ["cmd_block", "cmd_block"],
      "cfg_summary": "complexity:6, blocks:15",
      "dfg_summary": "vars:6, def-use chains:6",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def get_task_section(content: str, section: str) -> str:\n    \"\"\"Get content under a task section heading.\"\"\"\n    lines = content.split(\"\\n\")\n    in_target = False\n    collected = []\n    for line in lines:\n        if line.startswith(\"## \"):\n            if line.strip() == section:\n                in_target = True\n                continue"
    },
    {
      "name": "validate_task_spec_headings",
      "qualified_name": "scripts.ralph.flowctl.py.validate_task_spec_headings",
      "file": "scripts/ralph/flowctl.py",
      "line": 1853,
      "language": "python",
      "unit_type": "function",
      "signature": "def validate_task_spec_headings(content: str) -> list[str]",
      "docstring": "Validate task spec has required headings exactly once. Returns errors.",
      "calls": [],
      "called_by": ["validate_epic", "validate_epic"],
      "cfg_summary": "complexity:4, blocks:10",
      "dfg_summary": "vars:8, def-use chains:8",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def validate_task_spec_headings(content: str) -> list[str]:\n    \"\"\"Validate task spec has required headings exactly once. Returns errors.\"\"\"\n    errors = []\n    for heading in TASK_SPEC_HEADINGS:\n        # Use regex anchored to line start to avoid matching inside code blocks\n        pattern = rf\"^{re.escape(heading)}\\s*$\"\n        count = len(re.findall(pattern, content, flags=re.MULTILINE))\n        if count == 0:\n            errors.append(f\"Missing required heading: {heading}\")\n        elif count > 1:"
    },
    {
      "name": "clear_task_evidence",
      "qualified_name": "scripts.ralph.flowctl.py.clear_task_evidence",
      "file": "scripts/ralph/flowctl.py",
      "line": 1867,
      "language": "python",
      "unit_type": "function",
      "signature": "def clear_task_evidence(task_id: str) -> None",
      "docstring": "Clear ## Evidence section contents but keep the heading with empty template.",
      "calls": ["atomic_write", "get_flow_dir", "get_flow_dir", "atomic_write"],
      "called_by": ["cmd_task_reset", "cmd_task_reset"],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:11, def-use chains:11",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def clear_task_evidence(task_id: str) -> None:\n    \"\"\"Clear ## Evidence section contents but keep the heading with empty template.\"\"\"\n    flow_dir = get_flow_dir()\n    spec_path = flow_dir / TASKS_DIR / f\"{task_id}.md\"\n    if not spec_path.exists():\n        return\n    content = spec_path.read_text(encoding=\"utf-8\")\n\n    # Replace contents under ## Evidence with empty template, keeping heading\n    # Pattern: ## Evidence\\n<content until next ## or end of file>"
    },
    {
      "name": "find_dependents",
      "qualified_name": "scripts.ralph.flowctl.py.find_dependents",
      "file": "scripts/ralph/flowctl.py",
      "line": 1886,
      "language": "python",
      "unit_type": "function",
      "signature": "def find_dependents(task_id: str, same_epic: bool) -> list[str]",
      "docstring": "Find tasks that depend on task_id (recursive). Returns list of dependent task IDs.",
      "calls": ["load_json", "get_flow_dir", "is_task_id", "load_json", "is_task_id"],
      "called_by": ["cmd_task_reset", "cmd_task_reset"],
      "cfg_summary": "complexity:9, blocks:25",
      "dfg_summary": "vars:20, def-use chains:18",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def find_dependents(task_id: str, same_epic: bool = False) -> list[str]:\n    \"\"\"Find tasks that depend on task_id (recursive). Returns list of dependent task IDs.\"\"\"\n    flow_dir = get_flow_dir()\n    tasks_dir = flow_dir / TASKS_DIR\n    if not tasks_dir.exists():\n        return []\n\n    epic_id = epic_id_from_task(task_id) if same_epic else None\n    dependents: set[str] = set()  # Use set to avoid duplicates\n    to_check = [task_id]"
    },
    {
      "name": "find_active_runs",
      "qualified_name": "scripts.ralph.flowctl.py.find_active_runs",
      "file": "scripts/ralph/flowctl.py",
      "line": 1929,
      "language": "python",
      "unit_type": "function",
      "signature": "def find_active_runs() -> list[dict]",
      "docstring": "Find active Ralph runs by scanning scripts/ralph/runs/*/progress.txt.\nA run is active if progress.txt exists AND does NOT contain 'promise=COMPLETE'.\nReturns list of dicts with run info.",
      "calls": ["get_repo_root", "get_repo_root"],
      "called_by": ["cmd_status", "cmd_status", "find_active_run", "find_active_run"],
      "cfg_summary": "complexity:9, blocks:23",
      "dfg_summary": "vars:14, def-use chains:26",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def find_active_runs() -> list[dict]:\n    \"\"\"\n    Find active Ralph runs by scanning scripts/ralph/runs/*/progress.txt.\n    A run is active if progress.txt exists AND does NOT contain 'promise=COMPLETE'.\n    Returns list of dicts with run info.\n    \"\"\"\n    repo_root = get_repo_root()\n    runs_dir = repo_root / \"scripts\" / \"ralph\" / \"runs\"\n    active_runs = []\n"
    },
    {
      "name": "find_active_run",
      "qualified_name": "scripts.ralph.flowctl.py.find_active_run",
      "file": "scripts/ralph/flowctl.py",
      "line": 1987,
      "language": "python",
      "unit_type": "function",
      "signature": "def find_active_run(run_id: Optional[str], use_json: bool) -> tuple[str, Path]",
      "docstring": "Find a single active run. Auto-detect if run_id is None.\nReturns (run_id, run_dir) tuple.",
      "calls": ["error_exit", "find_active_runs", "error_exit", "find_active_runs"],
      "called_by": [
        "cmd_ralph_pause",
        "cmd_ralph_resume",
        "cmd_ralph_status",
        "cmd_ralph_stop",
        "cmd_ralph_pause"
      ],
      "cfg_summary": "complexity:5, blocks:11",
      "dfg_summary": "vars:10, def-use chains:14",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def find_active_run(\n    run_id: Optional[str] = None, use_json: bool = False\n) -> tuple[str, Path]:\n    \"\"\"\n    Find a single active run. Auto-detect if run_id is None.\n    Returns (run_id, run_dir) tuple.\n    \"\"\"\n    runs = find_active_runs()\n    if run_id:\n        matches = [r for r in runs if r[\"id\"] == run_id]"
    },
    {
      "name": "cmd_init",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_init",
      "file": "scripts/ralph/flowctl.py",
      "line": 2011,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_init(args: argparse.Namespace) -> None",
      "docstring": "Initialize or upgrade .flow/ directory structure (idempotent).",
      "calls": [
        "deep_merge",
        "json_output",
        "atomic_write_json",
        "get_default_config",
        "get_flow_dir"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:9, blocks:21",
      "dfg_summary": "vars:28, def-use chains:21",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_init(args: argparse.Namespace) -> None:\n    \"\"\"Initialize or upgrade .flow/ directory structure (idempotent).\"\"\"\n    flow_dir = get_flow_dir()\n    actions = []\n\n    # Create directories if missing (idempotent, never destroys existing)\n    for subdir in [EPICS_DIR, SPECS_DIR, TASKS_DIR, MEMORY_DIR]:\n        dir_path = flow_dir / subdir\n        if not dir_path.exists():\n            dir_path.mkdir(parents=True)"
    },
    {
      "name": "cmd_detect",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_detect",
      "file": "scripts/ralph/flowctl.py",
      "line": 2062,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_detect(args: argparse.Namespace) -> None",
      "docstring": "Check if .flow/ exists and is valid.",
      "calls": ["get_flow_dir", "get_flow_dir", "load_json", "is_supported_schema", "load_json"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:11, blocks:27",
      "dfg_summary": "vars:25, def-use chains:28",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_detect(args: argparse.Namespace) -> None:\n    \"\"\"Check if .flow/ exists and is valid.\"\"\"\n    flow_dir = get_flow_dir()\n    exists = flow_dir.exists()\n    valid = False\n    issues = []\n\n    if exists:\n        meta_path = flow_dir / META_FILE\n        if not meta_path.exists():"
    },
    {
      "name": "cmd_status",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_status",
      "file": "scripts/ralph/flowctl.py",
      "line": 2110,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_status(args: argparse.Namespace) -> None",
      "docstring": "Show .flow state and active Ralph runs.",
      "calls": [
        "load_task_with_state",
        "get_flow_dir",
        "find_active_runs",
        "load_json",
        "load_task_with_state"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:17, blocks:41",
      "dfg_summary": "vars:31, def-use chains:48",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_status(args: argparse.Namespace) -> None:\n    \"\"\"Show .flow state and active Ralph runs.\"\"\"\n    flow_dir = get_flow_dir()\n    flow_exists = flow_dir.exists()\n\n    # Count epics and tasks by status\n    epic_counts = {\"open\": 0, \"done\": 0}\n    task_counts = {\"todo\": 0, \"in_progress\": 0, \"blocked\": 0, \"done\": 0}\n\n    if flow_exists:"
    },
    {
      "name": "cmd_ralph_pause",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_ralph_pause",
      "file": "scripts/ralph/flowctl.py",
      "line": 2203,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_ralph_pause(args: argparse.Namespace) -> None",
      "docstring": "Pause a Ralph run.",
      "calls": ["json_output", "find_active_run", "json_output", "find_active_run"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:7, def-use chains:7",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_ralph_pause(args: argparse.Namespace) -> None:\n    \"\"\"Pause a Ralph run.\"\"\"\n    run_id, run_dir = find_active_run(args.run, use_json=args.json)\n    pause_file = run_dir / \"PAUSE\"\n    pause_file.touch()\n    if args.json:\n        json_output({\"success\": True, \"run\": run_id, \"action\": \"paused\"})\n    else:"
    },
    {
      "name": "cmd_ralph_resume",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_ralph_resume",
      "file": "scripts/ralph/flowctl.py",
      "line": 2214,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_ralph_resume(args: argparse.Namespace) -> None",
      "docstring": "Resume a paused Ralph run.",
      "calls": ["find_active_run", "json_output", "json_output", "find_active_run"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:7, def-use chains:7",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_ralph_resume(args: argparse.Namespace) -> None:\n    \"\"\"Resume a paused Ralph run.\"\"\"\n    run_id, run_dir = find_active_run(args.run, use_json=args.json)\n    pause_file = run_dir / \"PAUSE\"\n    pause_file.unlink(missing_ok=True)\n    if args.json:\n        json_output({\"success\": True, \"run\": run_id, \"action\": \"resumed\"})\n    else:"
    },
    {
      "name": "cmd_ralph_stop",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_ralph_stop",
      "file": "scripts/ralph/flowctl.py",
      "line": 2225,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_ralph_stop(args: argparse.Namespace) -> None",
      "docstring": "Request a Ralph run to stop.",
      "calls": ["json_output", "find_active_run", "json_output", "find_active_run"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:7, def-use chains:7",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_ralph_stop(args: argparse.Namespace) -> None:\n    \"\"\"Request a Ralph run to stop.\"\"\"\n    run_id, run_dir = find_active_run(args.run, use_json=args.json)\n    stop_file = run_dir / \"STOP\"\n    stop_file.touch()\n    if args.json:\n        json_output({\"success\": True, \"run\": run_id, \"action\": \"stop_requested\"})\n    else:"
    },
    {
      "name": "cmd_ralph_status",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_ralph_status",
      "file": "scripts/ralph/flowctl.py",
      "line": 2236,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_ralph_status(args: argparse.Namespace) -> None",
      "docstring": "Show Ralph run status.",
      "calls": ["json_output", "find_active_run", "json_output", "find_active_run"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:10, blocks:21",
      "dfg_summary": "vars:22, def-use chains:43",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_ralph_status(args: argparse.Namespace) -> None:\n    \"\"\"Show Ralph run status.\"\"\"\n    run_id, run_dir = find_active_run(args.run, use_json=args.json)\n    paused = (run_dir / \"PAUSE\").exists()\n    stopped = (run_dir / \"STOP\").exists()\n\n    # Read progress.txt for more info\n    progress_file = run_dir / \"progress.txt\"\n    iteration = None\n    current_epic = None"
    },
    {
      "name": "cmd_config_get",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_config_get",
      "file": "scripts/ralph/flowctl.py",
      "line": 2288,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_config_get(args: argparse.Namespace) -> None",
      "docstring": "Get a config value.",
      "calls": ["get_config", "error_exit", "json_output", "get_config", "json_output"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:5, blocks:12",
      "dfg_summary": "vars:9, def-use chains:12",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_config_get(args: argparse.Namespace) -> None:\n    \"\"\"Get a config value.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    value = get_config(args.key)\n    if args.json:\n        json_output({\"key\": args.key, \"value\": value})"
    },
    {
      "name": "cmd_config_set",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_config_set",
      "file": "scripts/ralph/flowctl.py",
      "line": 2307,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_config_set(args: argparse.Namespace) -> None",
      "docstring": "Set a config value.",
      "calls": ["get_config", "json_output", "get_config", "json_output", "set_config"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:3, blocks:6",
      "dfg_summary": "vars:8, def-use chains:10",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_config_set(args: argparse.Namespace) -> None:\n    \"\"\"Set a config value.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    set_config(args.key, args.value)\n    new_value = get_config(args.key)\n"
    },
    {
      "name": "cmd_review_backend",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_review_backend",
      "file": "scripts/ralph/flowctl.py",
      "line": 2323,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_review_backend(args: argparse.Namespace) -> None",
      "docstring": "Get review backend for skill conditionals. Returns ASK if not configured.",
      "calls": ["ensure_flow_exists", "get_config", "json_output", "get_config", "json_output"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:5, blocks:13",
      "dfg_summary": "vars:10, def-use chains:17",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_review_backend(args: argparse.Namespace) -> None:\n    \"\"\"Get review backend for skill conditionals. Returns ASK if not configured.\"\"\"\n    # Priority: FLOW_REVIEW_BACKEND env > config > ASK\n    env_val = os.environ.get(\"FLOW_REVIEW_BACKEND\", \"\").strip()\n    if env_val and env_val in (\"rp\", \"codex\", \"none\"):\n        backend = env_val\n        source = \"env\"\n    elif ensure_flow_exists():\n        cfg_val = get_config(\"review.backend\")\n        if cfg_val and cfg_val in (\"rp\", \"codex\", \"none\"):"
    },
    {
      "name": "cmd_memory_init",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_memory_init",
      "file": "scripts/ralph/flowctl.py",
      "line": 2370,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_memory_init(args: argparse.Namespace) -> None",
      "docstring": "Initialize memory directory with templates.",
      "calls": ["ensure_flow_exists", "get_flow_dir", "atomic_write", "error_exit", "get_config"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:9, blocks:22",
      "dfg_summary": "vars:19, def-use chains:9",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_memory_init(args: argparse.Namespace) -> None:\n    \"\"\"Initialize memory directory with templates.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    # Check if memory is enabled\n    if not get_config(\"memory.enabled\", False):\n        if args.json:"
    },
    {
      "name": "require_memory_enabled",
      "qualified_name": "scripts.ralph.flowctl.py.require_memory_enabled",
      "file": "scripts/ralph/flowctl.py",
      "line": 2423,
      "language": "python",
      "unit_type": "function",
      "signature": "def require_memory_enabled(args) -> Path",
      "docstring": "Check memory is enabled and return memory dir. Exits on error.",
      "calls": ["get_config", "error_exit", "json_output", "get_config", "json_output"],
      "called_by": [
        "cmd_memory_add",
        "cmd_memory_search",
        "cmd_memory_list",
        "cmd_memory_read",
        "cmd_memory_read"
      ],
      "cfg_summary": "complexity:6, blocks:14",
      "dfg_summary": "vars:13, def-use chains:7",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def require_memory_enabled(args) -> Path:\n    \"\"\"Check memory is enabled and return memory dir. Exits on error.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    if not get_config(\"memory.enabled\", False):\n        if args.json:\n            json_output("
    },
    {
      "name": "cmd_memory_add",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_memory_add",
      "file": "scripts/ralph/flowctl.py",
      "line": 2460,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_memory_add(args: argparse.Namespace) -> None",
      "docstring": "Add a memory entry manually.",
      "calls": [
        "require_memory_enabled",
        "error_exit",
        "error_exit",
        "json_output",
        "require_memory_enabled"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:4, blocks:8",
      "dfg_summary": "vars:14, def-use chains:24",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_memory_add(args: argparse.Namespace) -> None:\n    \"\"\"Add a memory entry manually.\"\"\"\n    memory_dir = require_memory_enabled(args)\n\n    # Map type to file\n    type_map = {\n        \"pitfall\": \"pitfalls.md\",\n        \"pitfalls\": \"pitfalls.md\",\n        \"convention\": \"conventions.md\",\n        \"conventions\": \"conventions.md\","
    },
    {
      "name": "cmd_memory_read",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_memory_read",
      "file": "scripts/ralph/flowctl.py",
      "line": 2513,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_memory_read(args: argparse.Namespace) -> None",
      "docstring": "Read memory entries.",
      "calls": ["error_exit", "error_exit", "json_output", "require_memory_enabled", "json_output"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:8, blocks:20",
      "dfg_summary": "vars:12, def-use chains:16",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_memory_read(args: argparse.Namespace) -> None:\n    \"\"\"Read memory entries.\"\"\"\n    memory_dir = require_memory_enabled(args)\n\n    # Determine which files to read\n    if args.type:\n        type_map = {\n            \"pitfall\": \"pitfalls.md\",\n            \"pitfalls\": \"pitfalls.md\",\n            \"convention\": \"conventions.md\","
    },
    {
      "name": "cmd_memory_list",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_memory_list",
      "file": "scripts/ralph/flowctl.py",
      "line": 2555,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_memory_list(args: argparse.Namespace) -> None",
      "docstring": "List memory entry counts.",
      "calls": ["json_output", "require_memory_enabled", "json_output", "require_memory_enabled"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:5, blocks:13",
      "dfg_summary": "vars:15, def-use chains:12",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_memory_list(args: argparse.Namespace) -> None:\n    \"\"\"List memory entry counts.\"\"\"\n    memory_dir = require_memory_enabled(args)\n\n    counts = {}\n    for filename in [\"pitfalls.md\", \"conventions.md\", \"decisions.md\"]:\n        filepath = memory_dir / filename\n        if filepath.exists():\n            text = filepath.read_text(encoding=\"utf-8\")\n            # Count ## entries (each entry starts with ## date)"
    },
    {
      "name": "cmd_memory_search",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_memory_search",
      "file": "scripts/ralph/flowctl.py",
      "line": 2580,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_memory_search(args: argparse.Namespace) -> None",
      "docstring": "Search memory entries.",
      "calls": ["json_output", "require_memory_enabled", "error_exit", "error_exit", "json_output"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:9, blocks:24",
      "dfg_summary": "vars:17, def-use chains:9",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_memory_search(args: argparse.Namespace) -> None:\n    \"\"\"Search memory entries.\"\"\"\n    memory_dir = require_memory_enabled(args)\n\n    pattern = args.pattern\n\n    # Validate regex pattern\n    try:\n        re.compile(pattern)\n    except re.error as e:"
    },
    {
      "name": "cmd_epic_create",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_epic_create",
      "file": "scripts/ralph/flowctl.py",
      "line": 2622,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_epic_create(args: argparse.Namespace) -> None",
      "docstring": "Create a new epic.",
      "calls": [
        "scan_max_epic_id",
        "now_iso",
        "atomic_write",
        "json_output",
        "generate_epic_suffix"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:4, blocks:8",
      "dfg_summary": "vars:27, def-use chains:37",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_epic_create(args: argparse.Namespace) -> None:\n    \"\"\"Create a new epic.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    flow_dir = get_flow_dir()\n    meta_path = flow_dir / META_FILE\n    load_json_or_exit(meta_path, \"meta.json\", use_json=args.json)"
    },
    {
      "name": "cmd_task_create",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_task_create",
      "file": "scripts/ralph/flowctl.py",
      "line": 2686,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_task_create(args: argparse.Namespace) -> None",
      "docstring": "Create a new task under an epic.",
      "calls": [
        "json_output",
        "ensure_flow_exists",
        "epic_id_from_task",
        "atomic_write_json",
        "get_flow_dir"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:10, blocks:21",
      "dfg_summary": "vars:33, def-use chains:63",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_task_create(args: argparse.Namespace) -> None:\n    \"\"\"Create a new task under an epic.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    if not is_epic_id(args.epic):\n        error_exit(\n            f\"Invalid epic ID: {args.epic}. Expected format: fn-N or fn-N-xxx\", use_json=args.json"
    },
    {
      "name": "cmd_dep_add",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_dep_add",
      "file": "scripts/ralph/flowctl.py",
      "line": 2782,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_dep_add(args: argparse.Namespace) -> None",
      "docstring": "Add a dependency to a task.",
      "calls": [
        "json_output",
        "load_json_or_exit",
        "epic_id_from_task",
        "json_output",
        "atomic_write_json"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:8, blocks:16",
      "dfg_summary": "vars:17, def-use chains:36",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_dep_add(args: argparse.Namespace) -> None:\n    \"\"\"Add a dependency to a task.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    if not is_task_id(args.task):\n        error_exit(\n            f\"Invalid task ID: {args.task}. Expected format: fn-N.M or fn-N-xxx.M\", use_json=args.json"
    },
    {
      "name": "cmd_show",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_show",
      "file": "scripts/ralph/flowctl.py",
      "line": 2835,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_show(args: argparse.Namespace) -> None",
      "docstring": "Show epic or task details.",
      "calls": ["task_sort_key", "is_task_id", "is_epic_id", "ensure_flow_exists", "get_flow_dir"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:11, blocks:29",
      "dfg_summary": "vars:30, def-use chains:53",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_show(args: argparse.Namespace) -> None:\n    \"\"\"Show epic or task details.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    flow_dir = get_flow_dir()\n\n    if is_epic_id(args.id):"
    },
    {
      "name": "task_sort_key",
      "qualified_name": "scripts.ralph.flowctl.py.task_sort_key",
      "file": "scripts/ralph/flowctl.py",
      "line": 2872,
      "language": "python",
      "unit_type": "function",
      "signature": "def task_sort_key(t)",
      "docstring": "",
      "calls": ["parse_id", "parse_id"],
      "called_by": ["cmd_show", "cmd_tasks", "cmd_tasks", "cmd_show"],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:4, def-use chains:1",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "        def task_sort_key(t):\n            _, task_num = parse_id(t[\"id\"])"
    },
    {
      "name": "cmd_epics",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_epics",
      "file": "scripts/ralph/flowctl.py",
      "line": 2915,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_epics(args: argparse.Namespace) -> None",
      "docstring": "List all epics.",
      "calls": ["json_output", "normalize_epic", "is_task_id", "parse_id", "epic_sort_key"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:11, blocks:27",
      "dfg_summary": "vars:31, def-use chains:40",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_epics(args: argparse.Namespace) -> None:\n    \"\"\"List all epics.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    flow_dir = get_flow_dir()\n    epics_dir = flow_dir / EPICS_DIR\n"
    },
    {
      "name": "epic_sort_key",
      "qualified_name": "scripts.ralph.flowctl.py.epic_sort_key",
      "file": "scripts/ralph/flowctl.py",
      "line": 3063,
      "language": "python",
      "unit_type": "function",
      "signature": "def epic_sort_key(e)",
      "docstring": "",
      "calls": ["parse_id", "parse_id"],
      "called_by": ["cmd_list", "cmd_epics", "cmd_list", "cmd_epics"],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:4, def-use chains:3",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "    def epic_sort_key(e):\n        epic_num, _ = parse_id(e[\"id\"])"
    },
    {
      "name": "cmd_tasks",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_tasks",
      "file": "scripts/ralph/flowctl.py",
      "line": 2978,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_tasks(args: argparse.Namespace) -> None",
      "docstring": "List tasks.",
      "calls": [
        "ensure_flow_exists",
        "get_flow_dir",
        "ensure_flow_exists",
        "get_flow_dir",
        "error_exit"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:10, blocks:26",
      "dfg_summary": "vars:26, def-use chains:46",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_tasks(args: argparse.Namespace) -> None:\n    \"\"\"List tasks.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    flow_dir = get_flow_dir()\n    tasks_dir = flow_dir / TASKS_DIR\n"
    },
    {
      "name": "task_sort_key",
      "qualified_name": "scripts.ralph.flowctl.py.task_sort_key",
      "file": "scripts/ralph/flowctl.py",
      "line": 2872,
      "language": "python",
      "unit_type": "function",
      "signature": "def task_sort_key(t)",
      "docstring": "",
      "calls": ["parse_id", "parse_id"],
      "called_by": ["cmd_show", "cmd_tasks", "cmd_tasks", "cmd_show"],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:4, def-use chains:1",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "        def task_sort_key(t):\n            _, task_num = parse_id(t[\"id\"])"
    },
    {
      "name": "cmd_list",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_list",
      "file": "scripts/ralph/flowctl.py",
      "line": 3040,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_list(args: argparse.Namespace) -> None",
      "docstring": "List all epics and their tasks.",
      "calls": [
        "is_task_id",
        "epic_sort_key",
        "load_json_or_exit",
        "json_output",
        "ensure_flow_exists"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:15, blocks:39",
      "dfg_summary": "vars:40, def-use chains:69",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_list(args: argparse.Namespace) -> None:\n    \"\"\"List all epics and their tasks.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    flow_dir = get_flow_dir()\n    epics_dir = flow_dir / EPICS_DIR\n    tasks_dir = flow_dir / TASKS_DIR"
    },
    {
      "name": "epic_sort_key",
      "qualified_name": "scripts.ralph.flowctl.py.epic_sort_key",
      "file": "scripts/ralph/flowctl.py",
      "line": 3063,
      "language": "python",
      "unit_type": "function",
      "signature": "def epic_sort_key(e)",
      "docstring": "",
      "calls": ["parse_id", "parse_id"],
      "called_by": ["cmd_list", "cmd_epics", "cmd_list", "cmd_epics"],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:4, def-use chains:3",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "    def epic_sort_key(e):\n        epic_num, _ = parse_id(e[\"id\"])"
    },
    {
      "name": "cmd_cat",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_cat",
      "file": "scripts/ralph/flowctl.py",
      "line": 3147,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_cat(args: argparse.Namespace) -> None",
      "docstring": "Print markdown spec for epic or task.",
      "calls": [
        "is_task_id",
        "read_text_or_exit",
        "get_flow_dir",
        "read_text_or_exit",
        "is_epic_id"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:4, blocks:10",
      "dfg_summary": "vars:13, def-use chains:7",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_cat(args: argparse.Namespace) -> None:\n    \"\"\"Print markdown spec for epic or task.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\".flow/ does not exist. Run 'flowctl init' first.\", use_json=False)\n\n    flow_dir = get_flow_dir()\n\n    if is_epic_id(args.id):\n        spec_path = flow_dir / SPECS_DIR / f\"{args.id}.md\"\n    elif is_task_id(args.id):"
    },
    {
      "name": "cmd_epic_set_plan",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_epic_set_plan",
      "file": "scripts/ralph/flowctl.py",
      "line": 3169,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_epic_set_plan(args: argparse.Namespace) -> None",
      "docstring": "Set/overwrite entire epic spec from file.",
      "calls": [
        "ensure_flow_exists",
        "get_flow_dir",
        "atomic_write",
        "error_exit",
        "read_file_or_stdin"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:5, blocks:10",
      "dfg_summary": "vars:20, def-use chains:25",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_epic_set_plan(args: argparse.Namespace) -> None:\n    \"\"\"Set/overwrite entire epic spec from file.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    if not is_epic_id(args.id):\n        error_exit(\n            f\"Invalid epic ID: {args.id}. Expected format: fn-N or fn-N-xxx\", use_json=args.json"
    },
    {
      "name": "cmd_epic_set_plan_review_status",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_epic_set_plan_review_status",
      "file": "scripts/ralph/flowctl.py",
      "line": 3212,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_epic_set_plan_review_status(args: argparse.Namespace) -> None",
      "docstring": "Set plan review status for an epic.",
      "calls": ["ensure_flow_exists", "get_flow_dir", "error_exit", "now_iso", "load_json_or_exit"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:5, blocks:10",
      "dfg_summary": "vars:15, def-use chains:23",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_epic_set_plan_review_status(args: argparse.Namespace) -> None:\n    \"\"\"Set plan review status for an epic.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    if not is_epic_id(args.id):\n        error_exit(\n            f\"Invalid epic ID: {args.id}. Expected format: fn-N or fn-N-xxx\", use_json=args.json"
    },
    {
      "name": "cmd_epic_set_branch",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_epic_set_branch",
      "file": "scripts/ralph/flowctl.py",
      "line": 3251,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_epic_set_branch(args: argparse.Namespace) -> None",
      "docstring": "Set epic branch name.",
      "calls": [
        "now_iso",
        "load_json_or_exit",
        "json_output",
        "ensure_flow_exists",
        "normalize_epic"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:5, blocks:10",
      "dfg_summary": "vars:15, def-use chains:22",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_epic_set_branch(args: argparse.Namespace) -> None:\n    \"\"\"Set epic branch name.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    if not is_epic_id(args.id):\n        error_exit(\n            f\"Invalid epic ID: {args.id}. Expected format: fn-N or fn-N-xxx\", use_json=args.json"
    },
    {
      "name": "cmd_epic_add_dep",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_epic_add_dep",
      "file": "scripts/ralph/flowctl.py",
      "line": 3288,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_epic_add_dep(args: argparse.Namespace) -> None",
      "docstring": "Add epic-level dependency.",
      "calls": ["get_flow_dir", "get_flow_dir", "error_exit", "is_epic_id", "ensure_flow_exists"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:10, blocks:22",
      "dfg_summary": "vars:18, def-use chains:46",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_epic_add_dep(args: argparse.Namespace) -> None:\n    \"\"\"Add epic-level dependency.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    epic_id = args.epic\n    dep_id = args.depends_on\n"
    },
    {
      "name": "cmd_epic_rm_dep",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_epic_rm_dep",
      "file": "scripts/ralph/flowctl.py",
      "line": 3356,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_epic_rm_dep(args: argparse.Namespace) -> None",
      "docstring": "Remove epic-level dependency.",
      "calls": ["now_iso", "json_output", "load_json_or_exit", "atomic_write_json", "is_epic_id"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:7, blocks:16",
      "dfg_summary": "vars:17, def-use chains:35",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_epic_rm_dep(args: argparse.Namespace) -> None:\n    \"\"\"Remove epic-level dependency.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    epic_id = args.epic\n    dep_id = args.depends_on\n"
    },
    {
      "name": "cmd_epic_set_backend",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_epic_set_backend",
      "file": "scripts/ralph/flowctl.py",
      "line": 3414,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_epic_set_backend(args: argparse.Namespace) -> None",
      "docstring": "Set epic default backend specs for impl/review/sync.",
      "calls": ["now_iso", "json_output", "normalize_epic", "atomic_write_json", "is_epic_id"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:9, blocks:18",
      "dfg_summary": "vars:16, def-use chains:42",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_epic_set_backend(args: argparse.Namespace) -> None:\n    \"\"\"Set epic default backend specs for impl/review/sync.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    if not is_epic_id(args.id):\n        error_exit(\n            f\"Invalid epic ID: {args.id}. Expected format: fn-N or fn-N-xxx\","
    },
    {
      "name": "cmd_task_set_backend",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_task_set_backend",
      "file": "scripts/ralph/flowctl.py",
      "line": 3473,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_task_set_backend(args: argparse.Namespace) -> None",
      "docstring": "Set task backend specs for impl/review/sync.",
      "calls": [
        "load_json_or_exit",
        "json_output",
        "atomic_write_json",
        "json_output",
        "atomic_write_json"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:9, blocks:18",
      "dfg_summary": "vars:15, def-use chains:43",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_task_set_backend(args: argparse.Namespace) -> None:\n    \"\"\"Set task backend specs for impl/review/sync.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    task_id = args.id\n    if not is_task_id(task_id):\n        error_exit("
    },
    {
      "name": "cmd_task_show_backend",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_task_show_backend",
      "file": "scripts/ralph/flowctl.py",
      "line": 3530,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_task_show_backend(args: argparse.Namespace) -> None",
      "docstring": "Show effective backend specs for a task (task + epic levels only).",
      "calls": ["error_exit", "normalize_epic", "normalize_task", "resolve_spec", "fmt"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:7, blocks:14",
      "dfg_summary": "vars:33, def-use chains:50",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_task_show_backend(args: argparse.Namespace) -> None:\n    \"\"\"Show effective backend specs for a task (task + epic levels only).\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    task_id = args.id\n    if not is_task_id(task_id):\n        error_exit("
    },
    {
      "name": "resolve_spec",
      "qualified_name": "scripts.ralph.flowctl.py.resolve_spec",
      "file": "scripts/ralph/flowctl.py",
      "line": 3565,
      "language": "python",
      "unit_type": "function",
      "signature": "def resolve_spec(task_key: str, epic_key: str) -> tuple",
      "docstring": "Return (spec, source) tuple.",
      "calls": [],
      "called_by": ["cmd_task_show_backend", "cmd_task_show_backend"],
      "cfg_summary": "complexity:4, blocks:10",
      "dfg_summary": "vars:6, def-use chains:6",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "    def resolve_spec(task_key: str, epic_key: str) -> tuple:\n        \"\"\"Return (spec, source) tuple.\"\"\"\n        task_val = task_data.get(task_key)\n        if task_val:\n            return (task_val, \"task\")\n        if epic_data:\n            epic_val = epic_data.get(epic_key)\n            if epic_val:\n                return (epic_val, \"epic\")"
    },
    {
      "name": "fmt",
      "qualified_name": "scripts.ralph.flowctl.py.fmt",
      "file": "scripts/ralph/flowctl.py",
      "line": 3591,
      "language": "python",
      "unit_type": "function",
      "signature": "def fmt(spec, source)",
      "docstring": "",
      "calls": [],
      "called_by": ["cmd_task_show_backend", "cmd_task_show_backend"],
      "cfg_summary": "complexity:2, blocks:5",
      "dfg_summary": "vars:2, def-use chains:3",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "        def fmt(spec, source):\n            if spec:\n                return f\"{spec} ({source})\""
    },
    {
      "name": "cmd_task_set_description",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_task_set_description",
      "file": "scripts/ralph/flowctl.py",
      "line": 3601,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_task_set_description(args: argparse.Namespace) -> None",
      "docstring": "Set task description section.",
      "calls": ["_task_set_section", "_task_set_section"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:2, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_task_set_description(args: argparse.Namespace) -> None:\n    \"\"\"Set task description section.\"\"\""
    },
    {
      "name": "cmd_task_set_acceptance",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_task_set_acceptance",
      "file": "scripts/ralph/flowctl.py",
      "line": 3606,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_task_set_acceptance(args: argparse.Namespace) -> None",
      "docstring": "Set task acceptance section.",
      "calls": ["_task_set_section", "_task_set_section"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:2, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_task_set_acceptance(args: argparse.Namespace) -> None:\n    \"\"\"Set task acceptance section.\"\"\""
    },
    {
      "name": "cmd_task_set_spec",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_task_set_spec",
      "file": "scripts/ralph/flowctl.py",
      "line": 3611,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_task_set_spec(args: argparse.Namespace) -> None",
      "docstring": "Set task spec - full replacement (--file) or section patches.\n\nFull replacement mode: --file replaces entire spec content (like epic set-plan).\nSection patch mode: --description and/or --acceptance update specific sections.",
      "calls": [
        "patch_task_section",
        "now_iso",
        "patch_task_section",
        "load_json_or_exit",
        "read_text_or_exit"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:10, blocks:22",
      "dfg_summary": "vars:30, def-use chains:66",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_task_set_spec(args: argparse.Namespace) -> None:\n    \"\"\"Set task spec - full replacement (--file) or section patches.\n\n    Full replacement mode: --file replaces entire spec content (like epic set-plan).\n    Section patch mode: --description and/or --acceptance update specific sections.\n    \"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )"
    },
    {
      "name": "cmd_task_reset",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_task_reset",
      "file": "scripts/ralph/flowctl.py",
      "line": 3705,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_task_reset(args: argparse.Namespace) -> None",
      "docstring": "Reset task status to todo.",
      "calls": ["ensure_flow_exists", "get_flow_dir", "epic_id_from_task", "now_iso", "error_exit"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:14, blocks:33",
      "dfg_summary": "vars:34, def-use chains:67",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_task_reset(args: argparse.Namespace) -> None:\n    \"\"\"Reset task status to todo.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    task_id = args.task_id\n    if not is_task_id(task_id):\n        error_exit("
    },
    {
      "name": "_task_set_section",
      "qualified_name": "scripts.ralph.flowctl.py._task_set_section",
      "file": "scripts/ralph/flowctl.py",
      "line": 3815,
      "language": "python",
      "unit_type": "function",
      "signature": "def _task_set_section(task_id: str, section: str, file_path: str, use_json: bool) -> None",
      "docstring": "Helper to set a task spec section.",
      "calls": ["is_task_id", "patch_task_section", "now_iso", "patch_task_section", "now_iso"],
      "called_by": [
        "cmd_task_set_acceptance",
        "cmd_task_set_description",
        "cmd_task_set_acceptance",
        "cmd_task_set_description"
      ],
      "cfg_summary": "complexity:5, blocks:10",
      "dfg_summary": "vars:27, def-use chains:35",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def _task_set_section(\n    task_id: str, section: str, file_path: str, use_json: bool\n) -> None:\n    \"\"\"Helper to set a task spec section.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=use_json\n        )\n\n    if not is_task_id(task_id):"
    },
    {
      "name": "cmd_ready",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_ready",
      "file": "scripts/ralph/flowctl.py",
      "line": 3871,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_ready(args: argparse.Namespace) -> None",
      "docstring": "List ready tasks for an epic.",
      "calls": ["sort_key", "get_actor", "parse_id", "json_output", "task_priority"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:23, blocks:60",
      "dfg_summary": "vars:37, def-use chains:62",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_ready(args: argparse.Namespace) -> None:\n    \"\"\"List ready tasks for an epic.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    if not is_epic_id(args.epic):\n        error_exit(\n            f\"Invalid epic ID: {args.epic}. Expected format: fn-N or fn-N-xxx\", use_json=args.json"
    },
    {
      "name": "sort_key",
      "qualified_name": "scripts.ralph.flowctl.py.sort_key",
      "file": "scripts/ralph/flowctl.py",
      "line": 4035,
      "language": "python",
      "unit_type": "function",
      "signature": "def sort_key(t: dict) -> tuple[int, int]",
      "docstring": "",
      "calls": ["task_priority", "parse_id", "task_priority", "parse_id"],
      "called_by": ["cmd_next", "cmd_ready", "cmd_ready", "cmd_next"],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:5, def-use chains:1",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "    def sort_key(t: dict) -> tuple[int, int]:\n        _, task_num = parse_id(t[\"id\"])"
    },
    {
      "name": "cmd_next",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_next",
      "file": "scripts/ralph/flowctl.py",
      "line": 4000,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_next(args: argparse.Namespace) -> None",
      "docstring": "Select the next plan/work unit.",
      "calls": [
        "sort_key",
        "load_task_with_state",
        "load_json_or_exit",
        "is_epic_id",
        "json_output"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:38, blocks:102",
      "dfg_summary": "vars:55, def-use chains:87",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_next(args: argparse.Namespace) -> None:\n    \"\"\"Select the next plan/work unit.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    flow_dir = get_flow_dir()\n\n    # Resolve epics list"
    },
    {
      "name": "sort_key",
      "qualified_name": "scripts.ralph.flowctl.py.sort_key",
      "file": "scripts/ralph/flowctl.py",
      "line": 4035,
      "language": "python",
      "unit_type": "function",
      "signature": "def sort_key(t: dict) -> tuple[int, int]",
      "docstring": "",
      "calls": ["task_priority", "parse_id", "task_priority", "parse_id"],
      "called_by": ["cmd_next", "cmd_ready", "cmd_ready", "cmd_next"],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:5, def-use chains:1",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "    def sort_key(t: dict) -> tuple[int, int]:\n        _, task_num = parse_id(t[\"id\"])"
    },
    {
      "name": "cmd_start",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_start",
      "file": "scripts/ralph/flowctl.py",
      "line": 4173,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_start(args: argparse.Namespace) -> None",
      "docstring": "Start a task (set status to in_progress).",
      "calls": [
        "normalize_task",
        "get_state_store",
        "is_task_id",
        "get_actor",
        "ensure_flow_exists"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:18, blocks:38",
      "dfg_summary": "vars:24, def-use chains:73",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_start(args: argparse.Namespace) -> None:\n    \"\"\"Start a task (set status to in_progress).\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    if not is_task_id(args.id):\n        error_exit(\n            f\"Invalid task ID: {args.id}. Expected format: fn-N.M or fn-N-xxx.M\", use_json=args.json"
    },
    {
      "name": "cmd_done",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_done",
      "file": "scripts/ralph/flowctl.py",
      "line": 4281,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_done(args: argparse.Namespace) -> None",
      "docstring": "Complete a task with summary and evidence.",
      "calls": ["to_list", "atomic_write", "save_task_runtime", "is_task_id", "get_actor"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:12, blocks:29",
      "dfg_summary": "vars:40, def-use chains:85",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_done(args: argparse.Namespace) -> None:\n    \"\"\"Complete a task with summary and evidence.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    if not is_task_id(args.id):\n        error_exit(\n            f\"Invalid task ID: {args.id}. Expected format: fn-N.M or fn-N-xxx.M\", use_json=args.json"
    },
    {
      "name": "to_list",
      "qualified_name": "scripts.ralph.flowctl.py.to_list",
      "file": "scripts/ralph/flowctl.py",
      "line": 4359,
      "language": "python",
      "unit_type": "function",
      "signature": "def to_list(val: Any) -> list",
      "docstring": "",
      "calls": [],
      "called_by": ["cmd_done", "cmd_done"],
      "cfg_summary": "complexity:3, blocks:8",
      "dfg_summary": "vars:4, def-use chains:5",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "    def to_list(val: Any) -> list:\n        if val is None:\n            return []\n        if isinstance(val, str):\n            return [val] if val else []"
    },
    {
      "name": "cmd_block",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_block",
      "file": "scripts/ralph/flowctl.py",
      "line": 4404,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_block(args: argparse.Namespace) -> None",
      "docstring": "Block a task with a reason.",
      "calls": [
        "save_task_runtime",
        "is_task_id",
        "ensure_flow_exists",
        "patch_task_section",
        "get_flow_dir"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:7, blocks:15",
      "dfg_summary": "vars:25, def-use chains:36",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_block(args: argparse.Namespace) -> None:\n    \"\"\"Block a task with a reason.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    if not is_task_id(args.id):\n        error_exit(\n            f\"Invalid task ID: {args.id}. Expected format: fn-N.M or fn-N-xxx.M\", use_json=args.json"
    },
    {
      "name": "cmd_state_path",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_state_path",
      "file": "scripts/ralph/flowctl.py",
      "line": 4460,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_state_path(args: argparse.Namespace) -> None",
      "docstring": "Show resolved state directory path.",
      "calls": ["error_exit", "json_output", "get_state_dir", "get_state_dir", "is_task_id"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:5, blocks:12",
      "dfg_summary": "vars:9, def-use chains:13",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_state_path(args: argparse.Namespace) -> None:\n    \"\"\"Show resolved state directory path.\"\"\"\n    state_dir = get_state_dir()\n\n    if args.task:\n        if not is_task_id(args.task):\n            error_exit(\n                f\"Invalid task ID: {args.task}. Expected format: fn-N.M or fn-N-xxx.M\",\n                use_json=args.json,\n            )"
    },
    {
      "name": "cmd_migrate_state",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_migrate_state",
      "file": "scripts/ralph/flowctl.py",
      "line": 4482,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_migrate_state(args: argparse.Namespace) -> None",
      "docstring": "Migrate runtime state from definition files to state-dir.",
      "calls": ["load_json", "is_task_id", "atomic_write_json", "get_state_store", "json_output"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:13, blocks:33",
      "dfg_summary": "vars:26, def-use chains:48",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_migrate_state(args: argparse.Namespace) -> None:\n    \"\"\"Migrate runtime state from definition files to state-dir.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    flow_dir = get_flow_dir()\n    tasks_dir = flow_dir / TASKS_DIR\n    store = get_state_store()"
    },
    {
      "name": "cmd_epic_close",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_epic_close",
      "file": "scripts/ralph/flowctl.py",
      "line": 4551,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_epic_close(args: argparse.Namespace) -> None",
      "docstring": "Close an epic (all tasks must be done).",
      "calls": ["is_epic_id", "ensure_flow_exists", "get_flow_dir", "error_exit", "is_task_id"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:10, blocks:22",
      "dfg_summary": "vars:22, def-use chains:31",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_epic_close(args: argparse.Namespace) -> None:\n    \"\"\"Close an epic (all tasks must be done).\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    if not is_epic_id(args.id):\n        error_exit(\n            f\"Invalid epic ID: {args.id}. Expected format: fn-N or fn-N-xxx\", use_json=args.json"
    },
    {
      "name": "validate_flow_root",
      "qualified_name": "scripts.ralph.flowctl.py.validate_flow_root",
      "file": "scripts/ralph/flowctl.py",
      "line": 4604,
      "language": "python",
      "unit_type": "function",
      "signature": "def validate_flow_root(flow_dir: Path) -> list[str]",
      "docstring": "Validate .flow/ root invariants. Returns list of errors.",
      "calls": ["is_supported_schema", "load_json", "load_json", "is_supported_schema"],
      "called_by": ["cmd_validate", "cmd_validate"],
      "cfg_summary": "complexity:5, blocks:12",
      "dfg_summary": "vars:16, def-use chains:14",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def validate_flow_root(flow_dir: Path) -> list[str]:\n    \"\"\"Validate .flow/ root invariants. Returns list of errors.\"\"\"\n    errors = []\n\n    # Check meta.json exists and is valid\n    meta_path = flow_dir / META_FILE\n    if not meta_path.exists():\n        errors.append(f\"meta.json missing: {meta_path}\")\n    else:\n        try:"
    },
    {
      "name": "validate_epic",
      "qualified_name": "scripts.ralph.flowctl.py.validate_epic",
      "file": "scripts/ralph/flowctl.py",
      "line": 4633,
      "language": "python",
      "unit_type": "function",
      "signature": "def validate_epic(flow_dir: Path, epic_id: str, use_json: bool) -> tuple[list[str], list[str], int]",
      "docstring": "Validate a single epic. Returns (errors, warnings, task_count).",
      "calls": [
        "has_cycle",
        "load_json_or_exit",
        "validate_task_spec_headings",
        "load_json_or_exit",
        "normalize_epic"
      ],
      "called_by": ["cmd_validate", "cmd_validate"],
      "cfg_summary": "complexity:26, blocks:67",
      "dfg_summary": "vars:42, def-use chains:93",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def validate_epic(\n    flow_dir: Path, epic_id: str, use_json: bool = True\n) -> tuple[list[str], list[str], int]:\n    \"\"\"Validate a single epic. Returns (errors, warnings, task_count).\"\"\"\n    errors = []\n    warnings = []\n\n    epic_path = flow_dir / EPICS_DIR / f\"{epic_id}.json\"\n\n    if not epic_path.exists():"
    },
    {
      "name": "has_cycle",
      "qualified_name": "scripts.ralph.flowctl.py.has_cycle",
      "file": "scripts/ralph/flowctl.py",
      "line": 4719,
      "language": "python",
      "unit_type": "function",
      "signature": "def has_cycle(task_id: str, visited: set, rec_stack: set) -> list[str]",
      "docstring": "",
      "calls": ["has_cycle", "has_cycle"],
      "called_by": ["validate_epic", "has_cycle", "validate_epic", "has_cycle"],
      "cfg_summary": "complexity:5, blocks:14",
      "dfg_summary": "vars:7, def-use chains:15",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "    def has_cycle(task_id: str, visited: set, rec_stack: set) -> list[str]:\n        visited.add(task_id)\n        rec_stack.add(task_id)\n\n        for dep in tasks.get(task_id, {}).get(\"depends_on\", []):\n            if dep not in visited:\n                cycle = has_cycle(dep, visited, rec_stack)\n                if cycle:\n                    return [task_id] + cycle\n            elif dep in rec_stack:"
    },
    {
      "name": "cmd_prep_chat",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_prep_chat",
      "file": "scripts/ralph/flowctl.py",
      "line": 4753,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_prep_chat(args: argparse.Namespace) -> None",
      "docstring": "Prepare JSON payload for rp-cli chat_send. Handles escaping safely.",
      "calls": [
        "read_text_or_exit",
        "read_text_or_exit",
        "build_chat_payload",
        "atomic_write",
        "atomic_write"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:9, def-use chains:11",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_prep_chat(args: argparse.Namespace) -> None:\n    \"\"\"Prepare JSON payload for rp-cli chat_send. Handles escaping safely.\"\"\"\n    # Read message from file\n    message = read_text_or_exit(Path(args.message_file), \"Message file\", use_json=False)\n    json_str = build_chat_payload(\n        message=message,\n        mode=args.mode,\n        new_chat=args.new_chat,\n        chat_name=args.chat_name,\n        selected_paths=args.selected_paths,"
    },
    {
      "name": "cmd_rp_windows",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_rp_windows",
      "file": "scripts/ralph/flowctl.py",
      "line": 4772,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_rp_windows(args: argparse.Namespace) -> None",
      "docstring": "",
      "calls": ["run_rp_cli", "parse_windows", "run_rp_cli", "parse_windows"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:8, def-use chains:5",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_rp_windows(args: argparse.Namespace) -> None:\n    result = run_rp_cli([\"--raw-json\", \"-e\", \"windows\"])\n    raw = result.stdout or \"\"\n    if args.json:\n        windows = parse_windows(raw)\n        print(json.dumps(windows))\n    else:"
    },
    {
      "name": "cmd_rp_pick_window",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_rp_pick_window",
      "file": "scripts/ralph/flowctl.py",
      "line": 4782,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_rp_pick_window(args: argparse.Namespace) -> None",
      "docstring": "",
      "calls": [
        "normalize_repo_root",
        "parse_windows",
        "extract_window_id",
        "normalize_repo_root",
        "run_rp_cli"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:9, blocks:24",
      "dfg_summary": "vars:17, def-use chains:19",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_rp_pick_window(args: argparse.Namespace) -> None:\n    repo_root = args.repo_root\n    roots = normalize_repo_root(repo_root)\n    result = run_rp_cli([\"--raw-json\", \"-e\", \"windows\"])\n    windows = parse_windows(result.stdout or \"\")\n    if len(windows) == 1 and not extract_root_paths(windows[0]):\n        win_id = extract_window_id(windows[0])\n        if win_id is None:\n            error_exit(\"No window matches repo root\", use_json=False, code=2)\n        if args.json:"
    },
    {
      "name": "cmd_rp_ensure_workspace",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_rp_ensure_workspace",
      "file": "scripts/ralph/flowctl.py",
      "line": 4810,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_rp_ensure_workspace(args: argparse.Namespace) -> None",
      "docstring": "",
      "calls": ["run_rp_cli", "error_exit", "error_exit", "run_rp_cli", "extract_names"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:24, def-use chains:31",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_rp_ensure_workspace(args: argparse.Namespace) -> None:\n    window = args.window\n    repo_root = os.path.realpath(args.repo_root)\n    ws_name = os.path.basename(repo_root)\n\n    list_cmd = [\n        \"--raw-json\",\n        \"-w\",\n        str(window),\n        \"-e\","
    },
    {
      "name": "extract_names",
      "qualified_name": "scripts.ralph.flowctl.py.extract_names",
      "file": "scripts/ralph/flowctl.py",
      "line": 4828,
      "language": "python",
      "unit_type": "function",
      "signature": "def extract_names(obj: Any) -> set[str]",
      "docstring": "",
      "calls": [],
      "called_by": ["cmd_rp_ensure_workspace", "cmd_rp_ensure_workspace"],
      "cfg_summary": "complexity:10, blocks:24",
      "dfg_summary": "vars:9, def-use chains:20",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "    def extract_names(obj: Any) -> set[str]:\n        names: set[str] = set()\n        if isinstance(obj, dict):\n            if \"workspaces\" in obj:\n                obj = obj[\"workspaces\"]\n            elif \"result\" in obj:\n                obj = obj[\"result\"]\n        if isinstance(obj, list):\n            for item in obj:\n                if isinstance(item, str):"
    },
    {
      "name": "cmd_rp_builder",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_rp_builder",
      "file": "scripts/ralph/flowctl.py",
      "line": 4865,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_rp_builder(args: argparse.Namespace) -> None",
      "docstring": "",
      "calls": ["parse_builder_tab", "run_rp_cli", "run_rp_cli", "parse_builder_tab"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:6, blocks:14",
      "dfg_summary": "vars:19, def-use chains:39",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_rp_builder(args: argparse.Namespace) -> None:\n    window = args.window\n    summary = args.summary\n    response_type = getattr(args, \"response_type\", None)\n\n    # Build builder command with optional --type flag (shorthand for response_type)\n    builder_expr = f\"builder {json.dumps(summary)}\"\n    if response_type:\n        builder_expr += f\" --type {response_type}\"\n"
    },
    {
      "name": "cmd_rp_prompt_get",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_rp_prompt_get",
      "file": "scripts/ralph/flowctl.py",
      "line": 4924,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_rp_prompt_get(args: argparse.Namespace) -> None",
      "docstring": "",
      "calls": ["run_rp_cli", "run_rp_cli"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_rp_prompt_get(args: argparse.Namespace) -> None:\n    cmd = [\"-w\", str(args.window), \"-t\", args.tab, \"-e\", \"prompt get\"]\n    res = run_rp_cli(cmd)"
    },
    {
      "name": "cmd_rp_prompt_set",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_rp_prompt_set",
      "file": "scripts/ralph/flowctl.py",
      "line": 4930,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_rp_prompt_set(args: argparse.Namespace) -> None",
      "docstring": "",
      "calls": ["read_text_or_exit", "run_rp_cli", "run_rp_cli", "read_text_or_exit"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:11, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_rp_prompt_set(args: argparse.Namespace) -> None:\n    message = read_text_or_exit(Path(args.message_file), \"Message file\", use_json=False)\n    payload = json.dumps({\"op\": \"set\", \"text\": message})\n    cmd = [\n        \"-w\",\n        str(args.window),\n        \"-t\",\n        args.tab,\n        \"-e\",\n        f\"call prompt {payload}\","
    },
    {
      "name": "cmd_rp_select_get",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_rp_select_get",
      "file": "scripts/ralph/flowctl.py",
      "line": 4945,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_rp_select_get(args: argparse.Namespace) -> None",
      "docstring": "",
      "calls": ["run_rp_cli", "run_rp_cli"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:6, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_rp_select_get(args: argparse.Namespace) -> None:\n    cmd = [\"-w\", str(args.window), \"-t\", args.tab, \"-e\", \"select get\"]\n    res = run_rp_cli(cmd)"
    },
    {
      "name": "cmd_rp_select_add",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_rp_select_add",
      "file": "scripts/ralph/flowctl.py",
      "line": 4951,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_rp_select_add(args: argparse.Namespace) -> None",
      "docstring": "",
      "calls": ["error_exit", "run_rp_cli", "error_exit", "run_rp_cli"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:2, blocks:3",
      "dfg_summary": "vars:10, def-use chains:1",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_rp_select_add(args: argparse.Namespace) -> None:\n    if not args.paths:\n        error_exit(\"select-add requires at least one path\", use_json=False, code=2)\n    quoted = \" \".join(shlex.quote(p) for p in args.paths)\n    cmd = [\"-w\", str(args.window), \"-t\", args.tab, \"-e\", f\"select add {quoted}\"]\n    res = run_rp_cli(cmd)"
    },
    {
      "name": "cmd_rp_chat_send",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_rp_chat_send",
      "file": "scripts/ralph/flowctl.py",
      "line": 4960,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_rp_chat_send(args: argparse.Namespace) -> None",
      "docstring": "",
      "calls": [
        "build_chat_payload",
        "parse_chat_id",
        "run_rp_cli",
        "parse_chat_id",
        "build_chat_payload"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:2, blocks:4",
      "dfg_summary": "vars:18, def-use chains:20",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_rp_chat_send(args: argparse.Namespace) -> None:\n    message = read_text_or_exit(Path(args.message_file), \"Message file\", use_json=False)\n    chat_id_arg = getattr(args, \"chat_id\", None)\n    mode = getattr(args, \"mode\", \"chat\") or \"chat\"\n    payload = build_chat_payload(\n        message=message,\n        mode=mode,\n        new_chat=args.new_chat,\n        chat_name=args.chat_name,\n        chat_id=chat_id_arg,"
    },
    {
      "name": "cmd_rp_prompt_export",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_rp_prompt_export",
      "file": "scripts/ralph/flowctl.py",
      "line": 4989,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_rp_prompt_export(args: argparse.Namespace) -> None",
      "docstring": "",
      "calls": ["run_rp_cli", "run_rp_cli"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:7, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_rp_prompt_export(args: argparse.Namespace) -> None:\n    cmd = [\n        \"-w\",\n        str(args.window),\n        \"-t\",\n        args.tab,\n        \"-e\",\n        f\"prompt export {shlex.quote(args.out)}\",\n    ]\n    res = run_rp_cli(cmd)"
    },
    {
      "name": "cmd_rp_setup_review",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_rp_setup_review",
      "file": "scripts/ralph/flowctl.py",
      "line": 5002,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_rp_setup_review(args: argparse.Namespace) -> None",
      "docstring": "Atomic setup: pick-window + builder.\n\nReturns W=<window> T=<tab> on success, exits non-zero on failure.\nWith --response-type review, also returns CHAT_ID and review findings.\nWrites state file for ralph-guard to verify pick-window ran.\n\nNote: ensure-workspace removed - if user opens RP on a folder, workspace\nalready exists. pick-window matches by folder path.\n\nRequires RepoPrompt 1.6.0+ for --response-type review.",
      "calls": [
        "extract_window_id",
        "parse_builder_tab",
        "normalize_repo_root",
        "run_rp_cli",
        "error_exit"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:18, blocks:44",
      "dfg_summary": "vars:41, def-use chains:98",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_rp_setup_review(args: argparse.Namespace) -> None:\n    \"\"\"Atomic setup: pick-window + builder.\n\n    Returns W=<window> T=<tab> on success, exits non-zero on failure.\n    With --response-type review, also returns CHAT_ID and review findings.\n    Writes state file for ralph-guard to verify pick-window ran.\n\n    Note: ensure-workspace removed - if user opens RP on a folder, workspace\n    already exists. pick-window matches by folder path.\n"
    },
    {
      "name": "cmd_codex_check",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_codex_check",
      "file": "scripts/ralph/flowctl.py",
      "line": 5132,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_codex_check(args: argparse.Namespace) -> None",
      "docstring": "Check if codex CLI is available and return version.",
      "calls": ["json_output", "get_codex_version", "json_output", "get_codex_version"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:3, blocks:7",
      "dfg_summary": "vars:8, def-use chains:7",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_codex_check(args: argparse.Namespace) -> None:\n    \"\"\"Check if codex CLI is available and return version.\"\"\"\n    codex = shutil.which(\"codex\")\n    available = codex is not None\n    version = get_codex_version() if available else None\n\n    if args.json:\n        json_output({\"available\": available, \"version\": version})\n    else:\n        if available:"
    },
    {
      "name": "build_standalone_review_prompt",
      "qualified_name": "scripts.ralph.flowctl.py.build_standalone_review_prompt",
      "file": "scripts/ralph/flowctl.py",
      "line": 5147,
      "language": "python",
      "unit_type": "function",
      "signature": "def build_standalone_review_prompt(base_branch: str, focus: Optional[str], diff_summary: str, files_embedded: bool) -> str",
      "docstring": "Build review prompt for standalone branch review (no task context).\n\nfiles_embedded: True if files are embedded (Windows), False if Codex can read from disk (Unix)",
      "calls": [],
      "called_by": ["cmd_codex_impl_review", "cmd_codex_impl_review"],
      "cfg_summary": "complexity:3, blocks:7",
      "dfg_summary": "vars:6, def-use chains:4",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def build_standalone_review_prompt(\n    base_branch: str, focus: Optional[str], diff_summary: str, files_embedded: bool = True\n) -> str:\n    \"\"\"Build review prompt for standalone branch review (no task context).\n\n    files_embedded: True if files are embedded (Windows), False if Codex can read from disk (Unix)\n    \"\"\"\n    focus_section = \"\"\n    if focus:\n        focus_section = f\"\"\""
    },
    {
      "name": "cmd_codex_impl_review",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_codex_impl_review",
      "file": "scripts/ralph/flowctl.py",
      "line": 5239,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_codex_impl_review(args: argparse.Namespace) -> None",
      "docstring": "Run implementation review via codex exec.",
      "calls": ["resolve_codex_sandbox", "now_iso", "get_repo_root", "run_codex_exec", "now_iso"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:28, blocks:60",
      "dfg_summary": "vars:67, def-use chains:139",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_codex_impl_review(args: argparse.Namespace) -> None:\n    \"\"\"Run implementation review via codex exec.\"\"\"\n    task_id = args.task\n    base_branch = args.base\n    focus = getattr(args, \"focus\", None)\n\n    # Standalone mode (no task ID) - review branch without task context\n    standalone = task_id is None\n\n    if not standalone:"
    },
    {
      "name": "cmd_codex_plan_review",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_codex_plan_review",
      "file": "scripts/ralph/flowctl.py",
      "line": 5472,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_codex_plan_review(args: argparse.Namespace) -> None",
      "docstring": "Run plan review via codex exec.",
      "calls": [
        "gather_context_hints",
        "ensure_flow_exists",
        "get_flow_dir",
        "error_exit",
        "build_rereview_preamble"
      ],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:26, blocks:58",
      "dfg_summary": "vars:67, def-use chains:100",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_codex_plan_review(args: argparse.Namespace) -> None:\n    \"\"\"Run plan review via codex exec.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\".flow/ does not exist\", use_json=args.json)\n\n    epic_id = args.epic\n\n    # Validate epic ID\n    if not is_epic_id(epic_id):\n        error_exit(f\"Invalid epic ID: {epic_id}\", use_json=args.json)"
    },
    {
      "name": "cmd_checkpoint_save",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_checkpoint_save",
      "file": "scripts/ralph/flowctl.py",
      "line": 5696,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_checkpoint_save(args: argparse.Namespace) -> None",
      "docstring": "Save full epic + tasks state to checkpoint file.\n\nCreates .flow/.checkpoint-fn-N.json with complete state snapshot.\nUse before plan-review or other long operations to enable recovery\nif context compaction occurs.",
      "calls": ["error_exit", "ensure_flow_exists", "get_flow_dir", "error_exit", "now_iso"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:10, blocks:22",
      "dfg_summary": "vars:36, def-use chains:47",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_checkpoint_save(args: argparse.Namespace) -> None:\n    \"\"\"Save full epic + tasks state to checkpoint file.\n\n    Creates .flow/.checkpoint-fn-N.json with complete state snapshot.\n    Use before plan-review or other long operations to enable recovery\n    if context compaction occurs.\n    \"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json"
    },
    {
      "name": "cmd_checkpoint_restore",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_checkpoint_restore",
      "file": "scripts/ralph/flowctl.py",
      "line": 5780,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_checkpoint_restore(args: argparse.Namespace) -> None",
      "docstring": "Restore epic + tasks state from checkpoint file.\n\nReads .flow/.checkpoint-fn-N.json and overwrites current state.\nUse to recover after context compaction or to rollback changes.",
      "calls": ["delete_task_runtime", "atomic_write", "now_iso", "atomic_write", "json_output"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:10, blocks:22",
      "dfg_summary": "vars:33, def-use chains:49",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_checkpoint_restore(args: argparse.Namespace) -> None:\n    \"\"\"Restore epic + tasks state from checkpoint file.\n\n    Reads .flow/.checkpoint-fn-N.json and overwrites current state.\n    Use to recover after context compaction or to rollback changes.\n    \"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )"
    },
    {
      "name": "cmd_checkpoint_delete",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_checkpoint_delete",
      "file": "scripts/ralph/flowctl.py",
      "line": 5864,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_checkpoint_delete(args: argparse.Namespace) -> None",
      "docstring": "Delete checkpoint file for an epic.",
      "calls": ["json_output", "json_output", "get_flow_dir", "is_epic_id", "is_epic_id"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:6, blocks:14",
      "dfg_summary": "vars:10, def-use chains:17",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_checkpoint_delete(args: argparse.Namespace) -> None:\n    \"\"\"Delete checkpoint file for an epic.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    epic_id = args.epic\n    if not is_epic_id(epic_id):\n        error_exit("
    },
    {
      "name": "cmd_validate",
      "qualified_name": "scripts.ralph.flowctl.py.cmd_validate",
      "file": "scripts/ralph/flowctl.py",
      "line": 5904,
      "language": "python",
      "unit_type": "function",
      "signature": "def cmd_validate(args: argparse.Namespace) -> None",
      "docstring": "Validate epic structure or all epics.",
      "calls": ["error_exit", "json_output", "validate_flow_root", "is_epic_id", "validate_epic"],
      "called_by": ["main", "main"],
      "cfg_summary": "complexity:21, blocks:50",
      "dfg_summary": "vars:33, def-use chains:63",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def cmd_validate(args: argparse.Namespace) -> None:\n    \"\"\"Validate epic structure or all epics.\"\"\"\n    if not ensure_flow_exists():\n        error_exit(\n            \".flow/ does not exist. Run 'flowctl init' first.\", use_json=args.json\n        )\n\n    # Require either --epic or --all\n    if not args.epic and not getattr(args, \"all\", False):\n        error_exit(\"Must specify --epic or --all\", use_json=args.json)"
    },
    {
      "name": "main",
      "qualified_name": "scripts.ralph.flowctl.py.main",
      "file": "scripts/ralph/flowctl.py",
      "line": 6032,
      "language": "python",
      "unit_type": "function",
      "signature": "def main() -> None",
      "docstring": "",
      "calls": [
        "cmd_rp_setup_review",
        "cmd_epic_set_plan",
        "cmd_migrate_state",
        "cmd_task_set_backend",
        "cmd_ralph_resume"
      ],
      "called_by": ["<module>", "<module>", "<module>"],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:147, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": "def main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"flowctl - CLI for .flow/ task tracking\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n    subparsers = parser.add_subparsers(dest=\"command\", required=True)\n\n    # init\n    p_init = subparsers.add_parser(\"init\", help=\"Initialize .flow/ directory\")\n    p_init.add_argument(\"--json\", action=\"store_true\", help=\"JSON output\")"
    },
    {
      "name": "load_runtime",
      "qualified_name": "scripts.ralph.flowctl.py.load_runtime",
      "file": "scripts/ralph/flowctl.py",
      "line": 1,
      "language": "python",
      "unit_type": "function",
      "signature": "def load_runtime(...)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:2, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": ""
    },
    {
      "name": "save_runtime",
      "qualified_name": "scripts.ralph.flowctl.py.save_runtime",
      "file": "scripts/ralph/flowctl.py",
      "line": 1,
      "language": "python",
      "unit_type": "function",
      "signature": "def save_runtime(...)",
      "docstring": "",
      "calls": ["atomic_write", "atomic_write"],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": ""
    },
    {
      "name": "lock_task",
      "qualified_name": "scripts.ralph.flowctl.py.lock_task",
      "file": "scripts/ralph/flowctl.py",
      "line": 1,
      "language": "python",
      "unit_type": "function",
      "signature": "def lock_task(...)",
      "docstring": "",
      "calls": ["_flock", "_flock"],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:2, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": ""
    },
    {
      "name": "list_runtime_files",
      "qualified_name": "scripts.ralph.flowctl.py.list_runtime_files",
      "file": "scripts/ralph/flowctl.py",
      "line": 1,
      "language": "python",
      "unit_type": "function",
      "signature": "def list_runtime_files(...)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:1, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": ""
    },
    {
      "name": "__init__",
      "qualified_name": "scripts.ralph.flowctl.py.__init__",
      "file": "scripts/ralph/flowctl.py",
      "line": 1,
      "language": "python",
      "unit_type": "function",
      "signature": "def __init__(...)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:2, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": ""
    },
    {
      "name": "_state_path",
      "qualified_name": "scripts.ralph.flowctl.py._state_path",
      "file": "scripts/ralph/flowctl.py",
      "line": 1,
      "language": "python",
      "unit_type": "function",
      "signature": "def _state_path(...)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:2, def-use chains:2",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": ""
    },
    {
      "name": "_lock_path",
      "qualified_name": "scripts.ralph.flowctl.py._lock_path",
      "file": "scripts/ralph/flowctl.py",
      "line": 1,
      "language": "python",
      "unit_type": "function",
      "signature": "def _lock_path(...)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:2",
      "dfg_summary": "vars:2, def-use chains:2",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": ""
    },
    {
      "name": "load_runtime",
      "qualified_name": "scripts.ralph.flowctl.py.load_runtime",
      "file": "scripts/ralph/flowctl.py",
      "line": 1,
      "language": "python",
      "unit_type": "function",
      "signature": "def load_runtime(...)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:2, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": ""
    },
    {
      "name": "save_runtime",
      "qualified_name": "scripts.ralph.flowctl.py.save_runtime",
      "file": "scripts/ralph/flowctl.py",
      "line": 1,
      "language": "python",
      "unit_type": "function",
      "signature": "def save_runtime(...)",
      "docstring": "",
      "calls": ["atomic_write", "atomic_write"],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:3, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": ""
    },
    {
      "name": "lock_task",
      "qualified_name": "scripts.ralph.flowctl.py.lock_task",
      "file": "scripts/ralph/flowctl.py",
      "line": 1,
      "language": "python",
      "unit_type": "function",
      "signature": "def lock_task(...)",
      "docstring": "",
      "calls": ["_flock", "_flock"],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:2, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": ""
    },
    {
      "name": "list_runtime_files",
      "qualified_name": "scripts.ralph.flowctl.py.list_runtime_files",
      "file": "scripts/ralph/flowctl.py",
      "line": 1,
      "language": "python",
      "unit_type": "function",
      "signature": "def list_runtime_files(...)",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "complexity:1, blocks:1",
      "dfg_summary": "vars:1, def-use chains:0",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": ""
    },
    {
      "name": "StateStore",
      "qualified_name": "scripts.ralph.flowctl.py.StateStore",
      "file": "scripts/ralph/flowctl.py",
      "line": 138,
      "language": "python",
      "unit_type": "class",
      "signature": "class StateStore",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": ""
    },
    {
      "name": "LocalFileStateStore",
      "qualified_name": "scripts.ralph.flowctl.py.LocalFileStateStore",
      "file": "scripts/ralph/flowctl.py",
      "line": 162,
      "language": "python",
      "unit_type": "class",
      "signature": "class LocalFileStateStore",
      "docstring": "",
      "calls": [],
      "called_by": [],
      "cfg_summary": "",
      "dfg_summary": "",
      "dependencies": "argparse, json, os, re, secrets",
      "code_preview": ""
    }
  ],
  "model": "BAAI/bge-large-en-v1.5",
  "dimension": 1024,
  "count": 169
}
